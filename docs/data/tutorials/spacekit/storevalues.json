{"hierarchy":{"modules":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract","kind":"task"}]}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types"},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","kind":"task"}]}]},{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens"},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"}]},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes"}],"paths":[["doc:\/\/SpaceKit\/tutorials\/SpaceKit","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions"]],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit"},"kind":"project","identifier":{"interfaceLanguage":"swift","url":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues"},"metadata":{"title":"Persist Values Between Executions","categoryPathComponent":"SpaceKit","role":"project","category":"SpaceKit"},"schemaVersion":{"minor":3,"major":0,"patch":0},"variants":[{"paths":["\/tutorials\/spacekit\/storevalues"],"traits":[{"interfaceLanguage":"swift"}]}],"sections":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}]},{"type":"paragraph","inlineContent":[{"text":"However, there are situations where you need to persist data across multiple executions. To support this, SpaceKit provides a built-in “storage” system for every contract.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The storage system is essentially a key-value dictionary where both keys and values are stored as raw data."}]},{"type":"paragraph","inlineContent":[{"text":"SpaceKit abstracts away the complexities of encoding and decoding values, offering simple APIs for interacting with storage.","type":"text"}]},{"inlineContent":[{"type":"text","text":"In this tutorial, you’ll learn two common approaches for storing data using "},{"code":"@Storage","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"@Mapping"},{"text":" annotations. Additionally, SpaceKit provides advanced mechanisms like storage mappers to handle more complex data structures, which will be covered in a later chapter.","type":"text"}],"type":"paragraph"}],"chapter":"Persisting Data Across Executions","title":"Persist Values Between Executions","kind":"hero","estimatedTimeInMinutes":15},{"kind":"tasks","tasks":[{"contentSection":[{"kind":"contentAndMedia","content":[{"inlineContent":[{"type":"text","text":"The "},{"code":"@Storage","type":"codeVoice"},{"text":" annotation allows you to persist a single value under a specified key. The ","type":"text"},{"type":"codeVoice","code":"key"},{"type":"text","text":" parameter defines the storage key, and we recommend matching the key to the variable name for consistency."}],"type":"paragraph"},{"inlineContent":[{"text":"In this section, you’ll implement an endpoint called ","type":"text"},{"code":"increaseStoredValue","type":"codeVoice"},{"text":", which increments a persistent integer each time it is called. If the value reaches 100, it resets to 0.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note: The focus here is on basic implementation. Optimizations, especially for transaction cost reductions, will be introduced in a later chapter."}]}],"mediaPosition":"trailing"}],"anchor":"Working-with-Storage-for-Single-Value-Persistence","title":"Working with @Storage for Single Value Persistence","stepsSection":[{"code":"StoreValuesSection1Step1.swift","runtimePreview":null,"caption":[],"content":[{"inlineContent":[{"type":"text","text":"Begin by setting up the basic structure of the contract."}],"type":"paragraph"}],"media":null,"type":"step"},{"runtimePreview":null,"media":null,"type":"step","caption":[],"content":[{"inlineContent":[{"type":"text","text":"Add a persistent integer to the contract using the "},{"code":"@Storage","type":"codeVoice"},{"text":" annotation. By default, this integer is initialized to 0 unless otherwise specified.","type":"text"}],"type":"paragraph"}],"code":"StoreValuesSection1Step2.swift"},{"runtimePreview":null,"media":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Implement the logic to increment the stored integer whenever the ","type":"text"},{"type":"codeVoice","code":"increaseStoredValue"},{"text":" endpoint is invoked.","type":"text"}]}],"type":"step","caption":[{"inlineContent":[{"text":"Tip: Be mindful that reading from storage increases transaction costs. This section focuses on functionality, and optimization techniques will be covered in later chapters.","type":"text"}],"type":"paragraph"}],"code":"StoreValuesSection1Step3.swift"},{"code":"StoreValuesSection1Step4.swift","caption":[],"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"If the integer reaches 100, reset it to 0.","type":"text"}]}],"media":null,"runtimePreview":null}]},{"contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"@Mapping","type":"codeVoice"},{"type":"text","text":" annotation allows you to store values under dynamically computed keys, effectively creating a nested dictionary in the contract’s storage. SpaceKit automatically handles encoding and decoding, ensuring typed access to both keys and values."}]},{"inlineContent":[{"type":"text","text":"Think of it like this: if Alice and Bob both call your smart contract, each of them will have their own persistent storage SpaceKit. When Alice calls the contract, her address is used to store or retrieve address unique data, and the same happens for Bob with his own key. This way, each user can have their own independent version of the same data, without interference."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this section, you’ll extend the "},{"code":"increaseStoredValue","type":"codeVoice"},{"text":" endpoint so that each user (like Alice and Bob) will have a unique persistent integer tied to their address. The integer will be stored and incremented individually for each user, ensuring their data remains isolated.","type":"text"}]}],"mediaPosition":"trailing"}],"anchor":"Leveraging-Mapping-for-Dynamic-Key-Value-Storage","title":"Leveraging @Mapping for Dynamic Key-Value Storage","stepsSection":[{"caption":[],"media":null,"content":[{"inlineContent":[{"type":"text","text":"Begin by defining the structure of your contract."}],"type":"paragraph"}],"code":"StoreValuesSection2Step1.swift","runtimePreview":null,"type":"step"},{"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Use the ","type":"text"},{"type":"codeVoice","code":"@Mapping<Key, Value>"},{"text":" annotation to associate each user’s address with their own persistent integer.","type":"text"}]}],"media":null,"runtimePreview":null,"caption":[{"inlineContent":[{"text":"Tip: You don’t need to explicitly declare the type of the variable. Specifying the ","type":"text"},{"code":"Key","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"Value"},{"type":"text","text":" generic parameters is sufficient."}],"type":"paragraph"}],"code":"StoreValuesSection2Step2.swift"},{"runtimePreview":null,"type":"step","caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Note: This involves interacting with the "},{"type":"codeVoice","code":"Message"},{"type":"text","text":" object, which will be covered in detail in a future chapter."}]}],"media":null,"code":"StoreValuesSection2Step3.swift","content":[{"type":"paragraph","inlineContent":[{"text":"Retrieve the caller’s address.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Increment the persistent integer associated with the caller’s address."}]}],"type":"step","media":null,"runtimePreview":null,"caption":[],"code":"StoreValuesSection2Step4.swift"},{"caption":[],"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Reset the caller’s integer to 0 once it reaches 100."}]}],"runtimePreview":null,"media":null,"code":"StoreValuesSection2Step5.swift"},{"type":"step","runtimePreview":null,"caption":[{"type":"paragraph","inlineContent":[{"text":"Reminder: A view is an endpoint that does not alter any state on the blockchain.","type":"text"}]}],"code":"StoreValuesSection2Step6.swift","content":[{"inlineContent":[{"type":"text","text":"Implement a view to allow querying of the stored integer value for a given user, enabling off-chain access to the data."}],"type":"paragraph"}],"media":null}]}]},{"title":"Retrieving Information from the Blockchain","action":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","isActive":true,"overridingTitle":"Get started","overridingTitleInlineContent":[{"type":"text","text":"Get started"}],"type":"reference"},"kind":"callToAction","featuredEyebrow":"Tutorial","abstract":[{"text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner.","type":"text"}]}],"references":{"StoreValuesSection2Step5.swift":{"content":["import SpaceKit","","@Controller public struct MyController {","    @Mapping<Address, UInt64>(key: \"storedIntegerForUser\") var storedIntegerForUser","    ","    public func increaseStoredValue() {","        let caller = Message.caller","        ","        guard self.storedIntegerForUser[caller] < 100 else {","            self.storedIntegerForUser[caller] = 0","            return","        }","        ","        self.storedIntegerForUser[caller] = self.storedIntegerForUser[caller] + 1","    }","}"],"highlights":[{"line":9},{"line":10},{"line":11},{"line":12},{"line":13}],"identifier":"StoreValuesSection2Step5.swift","fileType":"swift","type":"file","syntax":"swift","fileName":"lib.swift"},"StoreValuesSection1Step1.swift":{"type":"file","highlights":[],"fileType":"swift","identifier":"StoreValuesSection1Step1.swift","syntax":"swift","fileName":"lib.swift","content":["import SpaceKit","","@Controller public struct MyController {","    public func increaseStoredValue() {","        ","    }","}"]},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Transaction-Context-Data":{"title":"Accessing Transaction Context Data","url":"\/tutorials\/spacekit\/getinfo#Accessing-Transaction-Context-Data","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","type":"section","kind":"section","abstract":[{"text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Perform-an-Asynchronous-Call":{"abstract":[{"text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources.","type":"text"}],"url":"\/tutorials\/spacekit\/asynccalls#Perform-an-Asynchronous-Call","title":"Perform an Asynchronous Call","type":"section","kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call"},"doc://SpaceKit/tutorials/SpaceKit":{"title":"Meet SpaceKit","url":"\/tutorials\/spacekit","role":"overview","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","type":"topic","kind":"overview","abstract":[{"text":"Discover how SpaceKit simplifies blockchain development using Swift. Dive into the world of Web3 with ease and efficiency.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-Vector-Type":{"abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-Vector-Type","title":"Working with the Vector Type","type":"section","kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Perform-a-Synchronous-Call":{"title":"Perform a Synchronous Call","url":"\/tutorials\/spacekit\/synccalls#Perform-a-Synchronous-Call","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","type":"section","kind":"section","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes":{"abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"url":"\/tutorials\/spacekit\/tokenattributes","title":"Enhance Your Contracts with Token Attributes","type":"topic","kind":"project","estimatedTime":"15min","role":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-BigUint-Type":{"title":"Working with the BigUint Type","url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-BigUint-Type","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","type":"section","kind":"section","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract":{"abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"url":"\/tutorials\/spacekit\/installingtools#Initializing-and-Compiling-Your-First-Smart-Contract","title":"Initializing and Compiling Your First Smart Contract","type":"section","kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Interacting-with-Other-Contracts":{"title":"Interacting with Other Contracts","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/interacting-with-other-contracts","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","type":"topic","kind":"article","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens":{"abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens","title":"Managing Non-Fungible Tokens","type":"topic","kind":"project","estimatedTime":"15min","role":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Persisting-Data-Across-Executions":{"title":"Persisting Data Across Executions","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/persisting-data-across-executions","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","type":"topic","kind":"article","abstract":[]},"StoreValuesSection1Step4.swift":{"type":"file","highlights":[{"line":7},{"line":8},{"line":9},{"line":10},{"line":11}],"fileType":"swift","identifier":"StoreValuesSection1Step4.swift","syntax":"swift","fileName":"lib.swift","content":["import SpaceKit","","@Controller public struct MyController {","    @Storage(key: \"storedInteger\") var storedInteger: UInt64","    ","    public func increaseStoredValue() {","        guard self.storedInteger < 100 else {","            self.storedInteger = 0","            return","        }","        ","        self.storedInteger = self.storedInteger + 1","    }","}"]},"StoreValuesSection2Step1.swift":{"content":["import SpaceKit","","@Controller public struct MyController {","    public func increaseStoredValue() {","        ","    }","}"],"highlights":[],"identifier":"StoreValuesSection2Step1.swift","fileType":"swift","type":"file","syntax":"swift","fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Testing-the-Contract":{"abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Testing-the-Contract","title":"Testing the Contract","kind":"section","type":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Burn-Tokens":{"role":"pseudoSymbol","abstract":[{"text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","kind":"section","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Burn-Tokens","type":"section","title":"Burn Tokens"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls","kind":"project","type":"topic","abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}],"role":"project","url":"\/tutorials\/spacekit\/synccalls","estimatedTime":"15min","title":"Interact with Other Contracts"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Building-Your-First-Smart-Contract":{"role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","abstract":[],"kind":"article","url":"\/tutorials\/spacekit\/getting-started\/building-your-first-smart-contract","type":"topic","title":"Building Your First Smart Contract"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens","kind":"project","type":"topic","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"role":"project","url":"\/tutorials\/spacekit\/understandtokens","estimatedTime":"15min","title":"Understand the ESDT Standard"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Setting-Up-the-SpaceKit-CLI":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"kind":"section","url":"\/tutorials\/spacekit\/installingtools#Setting-Up-the-SpaceKit-CLI","type":"section","title":"Setting Up the SpaceKit CLI"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Exploring-SpaceKit's-Types":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","kind":"article","type":"topic","abstract":[],"role":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/exploring-spacekit's-types","title":"Exploring SpaceKit's Types"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Creating-and-Understanding-Tokens":{"role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","abstract":[],"kind":"article","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/creating-and-understanding-tokens","type":"topic","title":"Creating and Understanding Tokens"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Retrieving-Information-from-the-Blockchain":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","kind":"article","type":"topic","abstract":[],"role":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/retrieving-information-from-the-blockchain","title":"Retrieving Information from the Blockchain"},"StoreValuesSection2Step3.swift":{"content":["import SpaceKit","","@Controller public struct MyController {","    @Mapping<Address, UInt64>(key: \"storedIntegerForUser\") var storedIntegerForUser","    ","    public func increaseStoredValue() {","        let caller = Message.caller","    }","}"],"identifier":"StoreValuesSection2Step3.swift","fileType":"swift","type":"file","highlights":[{"line":7}],"fileName":"lib.swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract","kind":"section","type":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Meta-ESDT-from-Your-Contract","title":"Issuing a Meta ESDT from Your Contract"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"kind":"section","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","type":"section","title":"Issuing a Semi-Fungible Token from Your Contract"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes","kind":"project","type":"topic","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"role":"project","url":"\/tutorials\/spacekit\/familiarizewithtypes","estimatedTime":"20min","title":"Exploring SpaceKit's Types"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-unlockFunds-Endpoint":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"kind":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-unlockFunds-Endpoint","type":"section","title":"Implementing the unlockFunds Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Blockchain-Context-Data":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data","kind":"section","type":"section","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/getinfo#Accessing-Blockchain-Context-Data","title":"Accessing Blockchain Context Data"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Writing-the-Contract-Code":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"kind":"section","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Writing-the-Contract-Code","type":"section","title":"Writing the Contract Code"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Create-a-New-Nonce":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce","kind":"section","type":"section","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Create-a-New-Nonce","title":"Create a New Nonce"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"kind":"section","url":"\/tutorials\/spacekit\/storevalues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","type":"section","title":"Leveraging @Mapping for Dynamic Key-Value Storage"},"StoreValuesSection2Step4.swift":{"identifier":"StoreValuesSection2Step4.swift","type":"file","content":["import SpaceKit","","@Controller public struct MyController {","    @Mapping<Address, UInt64>(key: \"storedIntegerForUser\") var storedIntegerForUser","    ","    public func increaseStoredValue() {","        let caller = Message.caller","        ","        self.storedIntegerForUser[caller] = self.storedIntegerForUser[caller] + 1","    }","}"],"fileName":"lib.swift","syntax":"swift","fileType":"swift","highlights":[{"line":8},{"line":9}]},"doc://SpaceKit/tutorials/SpaceKit/StoreValues":{"role":"project","estimatedTime":"15min","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"kind":"project","url":"\/tutorials\/spacekit\/storevalues","type":"topic","title":"Persist Values Between Executions"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Declare-the-Callee-Proxy":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","kind":"section","type":"section","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/asynccalls#Declare-the-Callee-Proxy","title":"Declare the Callee Proxy"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract":{"role":"project","estimatedTime":"20min","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"kind":"project","url":"\/tutorials\/spacekit\/codingyourfirstcontract","type":"topic","title":"Building Your First Smart Contract"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","kind":"project","type":"topic","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"role":"project","url":"\/tutorials\/spacekit\/installingtools","estimatedTime":"10min","title":"Install the Necessary Tools"},"StoreValuesSection1Step3.swift":{"fileType":"swift","type":"file","identifier":"StoreValuesSection1Step3.swift","highlights":[{"line":7}],"fileName":"lib.swift","content":["import SpaceKit","","@Controller public struct MyController {","    @Storage(key: \"storedInteger\") var storedInteger: UInt64","    ","    public func increaseStoredValue() {","        self.storedInteger = self.storedInteger + 1","    }","}"],"syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Mint-New-Tokens":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","kind":"section","type":"section","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Mint-New-Tokens","title":"Mint New Tokens"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Initializing-the-Project":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"kind":"section","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Initializing-the-Project","type":"section","title":"Initializing the Project"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Installing-SpaceKits-Dependencies":{"kind":"section","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","url":"\/tutorials\/spacekit\/installingtools#Installing-SpaceKits-Dependencies","title":"Installing SpaceKit's Dependencies","role":"pseudoSymbol"},"StoreValuesSection2Step6.swift":{"identifier":"StoreValuesSection2Step6.swift","syntax":"swift","content":["import SpaceKit","","@Controller public struct MyController {","    @Mapping<Address, UInt64>(key: \"storedIntegerForUser\") var storedIntegerForUser","    ","    public func increaseStoredValue() {","        let caller = Message.caller","        ","        guard self.storedIntegerForUser[caller] < 100 else {","            self.storedIntegerForUser[caller] = 0","            return","        }","        ","        self.storedIntegerForUser[caller] = self.storedIntegerForUser[caller] + 1","    }","    ","    public func getStoredIntegerForUser(user: Address) -> UInt64 {","        return self.storedIntegerForUser[user]","    }","}"],"highlights":[{"line":16},{"line":17},{"line":18},{"line":19}],"type":"file","fileName":"lib.swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Installing-the-Tools":{"abstract":[],"kind":"article","title":"Installing the Tools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools","url":"\/tutorials\/spacekit\/getting-started\/installing-the-tools","type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","kind":"section","abstract":[{"text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with.","type":"text"}],"url":"\/tutorials\/spacekit\/operationsonfungibletokens#Assign-Mint-and-Burn-Roles","title":"Assign Mint and Burn Roles","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Fungible-Tokens":{"abstract":[],"kind":"article","title":"Managing Fungible Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-fungible-tokens","type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","kind":"section","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"text":" ","type":"text"},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","title":"Issuing a Non-Fungible Token from Your Contract","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Burn-Tokens":{"abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"kind":"section","title":"Burn Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Burn-Tokens","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","estimatedTime":"10min","kind":"project","abstract":[{"text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner.","type":"text"}],"url":"\/tutorials\/spacekit\/getinfo","title":"Retrieving Information from the Blockchain","type":"topic","role":"project"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges":{"title":"Handling Heap Allocation Challenges","role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Handling-Heap-Allocation-Challenges","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-lockFunds-Endpoint":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint","kind":"section","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-lockFunds-Endpoint","title":"Implementing the lockFunds Endpoint","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Declare-the-Callee-Proxy":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","url":"\/tutorials\/spacekit\/synccalls#Declare-the-Callee-Proxy","abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}],"kind":"section","title":"Declare the Callee Proxy","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls":{"title":"Interacting with Contracts Across Shards","role":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","kind":"project","type":"topic","estimatedTime":"15min","url":"\/tutorials\/spacekit\/asynccalls","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Understanding-the-Buffer-Type":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","url":"\/tutorials\/spacekit\/familiarizewithtypes#Understanding-the-Buffer-Type","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"kind":"section","title":"Understanding the Buffer Type","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles":{"title":"Assign Create, AddQuantity, and Burn Roles","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","kind":"section","type":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Assign-Create-AddQuantity-and-Burn-Roles","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}]},"StoreValuesSection2Step2.swift":{"identifier":"StoreValuesSection2Step2.swift","syntax":"swift","fileName":"lib.swift","fileType":"swift","type":"file","content":["import SpaceKit","","@Controller public struct MyController {","    @Mapping<Address, UInt64>(key: \"storedIntegerForUser\") var storedIntegerForUser","    ","    public func increaseStoredValue() {","        ","    }","}"],"highlights":[{"line":4},{"line":5}]},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract":{"title":"Issuing a Fungible Token from Your Contract","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","kind":"section","type":"section","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Fungible-Token-from-Your-Contract","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}]},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Calling-Contracts-Across-Shards":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/calling-contracts-across-shards","abstract":[],"kind":"article","title":"Calling Contracts Across Shards","type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce":{"title":"Add Quantity to an Existing Nonce","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce","kind":"section","type":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Add-Quantity-to-an-Existing-Nonce","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}]},"StoreValuesSection1Step2.swift":{"identifier":"StoreValuesSection1Step2.swift","fileType":"swift","type":"file","content":["import SpaceKit","","@Controller public struct MyController {","    @Storage(key: \"storedInteger\") var storedInteger: UInt64","    ","    public func increaseStoredValue() {","        ","    }","}"],"highlights":[{"line":4},{"line":5}],"fileName":"lib.swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens":{"title":"Managing Fungible Tokens","role":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","kind":"project","type":"topic","estimatedTime":"15min","url":"\/tutorials\/spacekit\/operationsonfungibletokens","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}]},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Non-Fungible-Tokens":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-non-fungible-tokens","abstract":[],"kind":"article","title":"Managing Non-Fungible Tokens","type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Creating-Your-Own-Types":{"title":"Creating Your Own Types","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types","kind":"section","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Creating-Your-Own-Types","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}]},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Working-with-Storage-for-Single-Value-Persistence":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence","url":"\/tutorials\/spacekit\/storevalues#Working-with-Storage-for-Single-Value-Persistence","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"kind":"section","title":"Working with @Storage for Single Value Persistence","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint":{"title":"Implementing the changeTokenLockDuration Endpoint","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint","kind":"section","type":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-changeTokenLockDuration-Endpoint","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}]},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Enhancing-Contracts-with-Token-Attributes":{"abstract":[],"title":"Enhancing Contracts with Token Attributes","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/enhancing-contracts-with-token-attributes","kind":"article","role":"article"}}}
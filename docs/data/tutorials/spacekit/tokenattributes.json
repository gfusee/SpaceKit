{"variants":[{"paths":["\/tutorials\/spacekit\/tokenattributes"],"traits":[{"interfaceLanguage":"swift"}]}],"metadata":{"role":"project","category":"SpaceKit","categoryPathComponent":"SpaceKit","title":"Enhance Your Contracts with Token Attributes"},"sections":[{"content":[{"type":"paragraph","inlineContent":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"In this tutorial, you’ll explore a practical use case for this feature by building a smart contract that locks funds inside an NFT for a specified duration. The NFT can be transferred freely, and once the lock period expires, the holder can reclaim the locked funds.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"You’ll implement the following contract endpoints:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"lockFunds"},{"type":"text","text":": Accepts a single payment, locks the funds, mints an NFT with attributes, and transfers it to the caller. "},{"type":"strong","inlineContent":[{"type":"text","text":"Concept covered:"}]},{"type":"text","text":" Creating a token with custom attributes."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"code":"unlockFunds","type":"codeVoice"},{"type":"text","text":": Accepts an NFT payment, verifies the attributes to determine if the funds can be unlocked, and if so, burns the NFT and releases the locked funds. Fails otherwise. "},{"inlineContent":[{"type":"text","text":"Concept covered:"}],"type":"strong"},{"text":" Reading token attributes.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"changeTokenLockDuration"},{"text":": Restricted to the contract owner, this endpoint accepts an NFT payment, updates the lock duration, and returns the modified NFT to the caller. ","type":"text"},{"inlineContent":[{"text":"Concept covered:","type":"text"}],"type":"strong"},{"type":"text","text":" Modifying NFT attributes."}],"type":"paragraph"}]}]}],"title":"Enhance Your Contracts with Token Attributes","kind":"hero","estimatedTimeInMinutes":15,"chapter":"Enhancing Contracts with Token Attributes"},{"tasks":[{"title":"Implementing the lockFunds Endpoint","stepsSection":[{"runtimePreview":null,"media":null,"code":"TokenAttributesSection1Step1.swift","type":"step","content":[{"inlineContent":[{"type":"text","text":"Define the contract structure."}],"type":"paragraph"}],"caption":[{"type":"paragraph","inlineContent":[{"text":"The contract stores the NFT token identifier and the lock duration, both specified by the owner during deployment.","type":"text"}]}]},{"type":"step","media":null,"caption":[{"type":"paragraph","inlineContent":[{"text":"You can use any SpaceKit types, as well as structs annotated with ","type":"text"},{"type":"codeVoice","code":"@Codable"},{"type":"text","text":"."}]}],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define the attributes structure."}]}],"code":"TokenAttributesSection1Step2.swift","runtimePreview":null},{"runtimePreview":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"Implement the "},{"type":"codeVoice","code":"lockFunds"},{"type":"text","text":" endpoint, which returns the nonce of the minted NFT."}],"type":"paragraph"}],"code":"TokenAttributesSection1Step3.swift","media":null,"caption":[]},{"runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Ensure the contract has permission to create NFTs.","type":"text"}]}],"code":"TokenAttributesSection1Step4.swift","type":"step","caption":[],"media":null},{"code":"TokenAttributesSection1Step5.swift","runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"Retrieve and validate the payment to be locked, ensuring it’s greater than zero."}],"type":"paragraph"}],"caption":[],"type":"step","media":null},{"type":"step","content":[{"inlineContent":[{"text":"Construct the attributes to be embedded in the NFT.","type":"text"}],"type":"paragraph"}],"media":null,"caption":[],"runtimePreview":null,"code":"TokenAttributesSection1Step6.swift"},{"content":[{"inlineContent":[{"text":"Mint the NFT and assign the attributes.","type":"text"}],"type":"paragraph"}],"runtimePreview":null,"code":"TokenAttributesSection1Step7.swift","media":null,"type":"step","caption":[]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Transfer the created NFT to the caller."}]}],"runtimePreview":null,"code":"TokenAttributesSection1Step8.swift","media":null,"caption":[],"type":"step"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Return the created nonce."}]}],"caption":[],"type":"step","code":"TokenAttributesSection1Step9.swift","runtimePreview":null,"media":null}],"contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In this section, you’ll create an NFT representing the locked funds sent by the caller. You’ll learn how to embed custom attributes in an NFT."}]},{"type":"paragraph","inlineContent":[{"text":"Before proceeding, ensure that the non-fungible collection is already issued and that the contract possesses the required roles (refer to previous chapters).","type":"text"}]}],"mediaPosition":"trailing"}],"anchor":"Implementing-the-lockFunds-Endpoint"},{"contentSection":[{"mediaPosition":"trailing","content":[{"type":"paragraph","inlineContent":[{"text":"This section covers unlocking funds when the lock period expires. If the NFT meets the criteria, it is burned, and the funds are released.","type":"text"}]},{"inlineContent":[{"type":"text","text":"Note: To access an NFT’s attributes, the contract must temporarily own it. Directly reading attributes from an NFT held by another account is not possible."}],"type":"paragraph"}],"kind":"contentAndMedia"}],"anchor":"Implementing-the-unlockFunds-Endpoint","stepsSection":[{"type":"step","media":null,"content":[{"inlineContent":[{"text":"Reuse the contract structure from the previous section.","type":"text"}],"type":"paragraph"}],"caption":[],"code":"TokenAttributesSection2Step1.swift","runtimePreview":null},{"media":null,"runtimePreview":null,"caption":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Note:","type":"text"}],"type":"strong"},{"text":" This function is not an endpoint and remains private.","type":"text"}]}],"content":[{"type":"paragraph","inlineContent":[{"text":"Implement a helper function to retrieve NFT attributes.","type":"text"}]}],"type":"step","code":"TokenAttributesSection2Step2.swift"},{"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Use ","type":"text"},{"code":"Blockchain.getTokenAttributes","type":"codeVoice"},{"type":"text","text":" to retrieve attributes."}]}],"runtimePreview":null,"caption":[],"media":null,"code":"TokenAttributesSection2Step3.swift"},{"caption":[],"code":"TokenAttributesSection2Step4.swift","media":null,"type":"step","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Declare the "},{"type":"codeVoice","code":"unlockFunds"},{"type":"text","text":" endpoint, returning the unlocked amount."}]}]},{"type":"step","content":[{"inlineContent":[{"type":"text","text":"Verify that the contract has permission to burn tokens."}],"type":"paragraph"}],"media":null,"runtimePreview":null,"code":"TokenAttributesSection2Step5.swift","caption":[]},{"type":"step","caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Retrieve the NFT payment and validate its token identifier."}]}],"media":null,"code":"TokenAttributesSection2Step6.swift","runtimePreview":null},{"caption":[],"runtimePreview":null,"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Extract the attributes using the helper function."}]}],"code":"TokenAttributesSection2Step7.swift","media":null},{"media":null,"runtimePreview":null,"type":"step","caption":[],"content":[{"inlineContent":[{"type":"text","text":"Determine whether funds can be unlocked based on attributes."}],"type":"paragraph"}],"code":"TokenAttributesSection2Step8.swift"},{"runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Burn the NFT if conditions are met.","type":"text"}]}],"type":"step","media":null,"caption":[],"code":"TokenAttributesSection2Step9.swift"},{"code":"TokenAttributesSection2Step10.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Transfer the unlocked funds to the caller."}]}],"runtimePreview":null,"type":"step","caption":[],"media":null},{"runtimePreview":null,"type":"step","content":[{"inlineContent":[{"text":"Return the amount of funds unlocked.","type":"text"}],"type":"paragraph"}],"media":null,"code":"TokenAttributesSection2Step11.swift","caption":[]}],"title":"Implementing the unlockFunds Endpoint"},{"title":"Implementing the changeTokenLockDuration Endpoint","stepsSection":[{"media":null,"code":"TokenAttributesSection3Step1.swift","runtimePreview":null,"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Reuse the contract structure from the previous section.","type":"text"}]}],"caption":[]},{"runtimePreview":null,"type":"step","media":null,"code":"TokenAttributesSection3Step2.swift","content":[{"inlineContent":[{"text":"Declare the ","type":"text"},{"code":"changeTokenLockDuration","type":"codeVoice"},{"type":"text","text":" endpoint, restricting access to the contract owner. It accepts the new lock duration as a parameter."}],"type":"paragraph"}],"caption":[]},{"type":"step","media":null,"runtimePreview":null,"code":"TokenAttributesSection3Step3.swift","caption":[],"content":[{"inlineContent":[{"text":"Verify that the contract has the permission to modify NFT attributes.","type":"text"}],"type":"paragraph"}]},{"type":"step","caption":[],"code":"TokenAttributesSection3Step4.swift","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Retrieve and validate the NFT payment.","type":"text"}]}],"media":null},{"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Extract the attributes as a mutable variable."}]}],"caption":[],"media":null,"code":"TokenAttributesSection3Step5.swift","runtimePreview":null},{"content":[{"type":"paragraph","inlineContent":[{"text":"Update the lock duration with the new value.","type":"text"}]}],"media":null,"caption":[],"code":"TokenAttributesSection3Step6.swift","type":"step","runtimePreview":null},{"code":"TokenAttributesSection3Step7.swift","content":[{"type":"paragraph","inlineContent":[{"text":"Call ","type":"text"},{"type":"codeVoice","code":"Blockchain.updateNftAttributes"},{"type":"text","text":" to persist the new attributes."}]}],"media":null,"type":"step","caption":[],"runtimePreview":null},{"content":[{"inlineContent":[{"type":"text","text":"Transfer the modified NFT back to the caller."}],"type":"paragraph"}],"type":"step","media":null,"code":"TokenAttributesSection3Step8.swift","runtimePreview":null,"caption":[]}],"anchor":"Implementing-the-changeTokenLockDuration-Endpoint","contentSection":[{"mediaPosition":"trailing","kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"text":"This section covers modifying an NFT’s lock duration, a feature restricted to the contract owner.","type":"text"}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Important:","type":"text"}],"type":"strong"},{"type":"text","text":" NFT attributes can only be modified for non-fungible tokens. This operation is not supported for semi-fungible tokens or meta-ESDTs."}]}]}]}],"kind":"tasks"}],"identifier":{"url":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","interfaceLanguage":"swift"},"hierarchy":{"modules":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types","kind":"task"}]}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions"},{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls"}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards"},{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens"},{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint","kind":"task"}]}]}],"paths":[["doc:\/\/SpaceKit\/tutorials\/SpaceKit","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes"]],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit"},"schemaVersion":{"major":0,"patch":0,"minor":3},"kind":"project","references":{"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Fungible-Tokens":{"abstract":[],"kind":"article","title":"Managing Fungible Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-fungible-tokens","type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Understanding-the-Buffer-Type":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","url":"\/tutorials\/spacekit\/familiarizewithtypes#Understanding-the-Buffer-Type","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"kind":"section","title":"Understanding the Buffer Type","type":"section","role":"pseudoSymbol"},"TokenAttributesSection3Step2.swift":{"highlights":[{"line":96},{"line":97},{"line":98},{"line":99}],"syntax":"swift","fileType":"swift","identifier":"TokenAttributesSection3Step2.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileName":"lib.swift","type":"file"},"TokenAttributesSection2Step2.swift":{"fileType":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        ","    }","}",""],"type":"file","identifier":"TokenAttributesSection2Step2.swift","highlights":[{"line":62},{"line":63},{"line":64},{"line":65}],"syntax":"swift","fileName":"lib.swift"},"TokenAttributesSection2Step8.swift":{"highlights":[{"line":77},{"line":78},{"line":79},{"line":80},{"line":81},{"line":82}],"syntax":"swift","fileType":"swift","identifier":"TokenAttributesSection2Step8.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileName":"lib.swift","type":"file"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Writing-the-Contract-Code":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"kind":"section","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Writing-the-Contract-Code","type":"section","title":"Writing the Contract Code"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-lockFunds-Endpoint":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint","kind":"section","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-lockFunds-Endpoint","title":"Implementing the lockFunds Endpoint","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","kind":"section","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"text":" ","type":"text"},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","title":"Issuing a Non-Fungible Token from Your Contract","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract":{"title":"Issuing a Fungible Token from Your Contract","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","kind":"section","type":"section","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Fungible-Token-from-Your-Contract","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}]},"TokenAttributesSection2Step3.swift":{"identifier":"TokenAttributesSection2Step3.swift","type":"file","syntax":"swift","fileType":"swift","fileName":"lib.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"highlights":[{"line":64},{"line":65},{"line":66},{"line":67},{"line":68}]},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes":{"abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"url":"\/tutorials\/spacekit\/tokenattributes","title":"Enhance Your Contracts with Token Attributes","type":"topic","kind":"project","estimatedTime":"15min","role":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes"},"TokenAttributesSection1Step3.swift":{"highlights":[{"line":22},{"line":23},{"line":24},{"line":25}],"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        ","    }","}",""],"type":"file","fileName":"lib.swift","fileType":"swift","syntax":"swift","identifier":"TokenAttributesSection1Step3.swift"},"TokenAttributesSection3Step4.swift":{"fileName":"lib.swift","identifier":"TokenAttributesSection3Step4.swift","highlights":[{"line":104},{"line":105},{"line":106},{"line":107},{"line":108},{"line":109}],"syntax":"swift","fileType":"swift","type":"file","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"kind":"section","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","type":"section","title":"Issuing a Semi-Fungible Token from Your Contract"},"TokenAttributesSection2Step10.swift":{"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"syntax":"swift","highlights":[{"line":89},{"line":90},{"line":91}],"type":"file","fileName":"lib.swift","identifier":"TokenAttributesSection2Step10.swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles":{"title":"Assign Create, AddQuantity, and Burn Roles","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","kind":"section","type":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Assign-Create-AddQuantity-and-Burn-Roles","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Creating-Your-Own-Types":{"title":"Creating Your Own Types","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types","kind":"section","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Creating-Your-Own-Types","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}]},"TokenAttributesSection2Step6.swift":{"type":"file","highlights":[{"line":69},{"line":70},{"line":71},{"line":72},{"line":73},{"line":74}],"fileType":"swift","identifier":"TokenAttributesSection2Step6.swift","syntax":"swift","fileName":"lib.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Interacting-with-Other-Contracts":{"title":"Interacting with Other Contracts","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/interacting-with-other-contracts","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","type":"topic","kind":"article","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Perform-a-Synchronous-Call":{"title":"Perform a Synchronous Call","url":"\/tutorials\/spacekit\/synccalls#Perform-a-Synchronous-Call","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","type":"section","kind":"section","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Setting-Up-the-SpaceKit-CLI":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"kind":"section","url":"\/tutorials\/spacekit\/installingtools#Setting-Up-the-SpaceKit-CLI","type":"section","title":"Setting Up the SpaceKit CLI"},"TokenAttributesSection3Step6.swift":{"syntax":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        var attributes = self.getTokenAttributes(nonce: payment.nonce)","        attributes.lockDuration = newLockDuration","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"highlights":[{"line":112}],"type":"file","fileName":"lib.swift","identifier":"TokenAttributesSection3Step6.swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes","kind":"project","type":"topic","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"role":"project","url":"\/tutorials\/spacekit\/familiarizewithtypes","estimatedTime":"20min","title":"Exploring SpaceKit's Types"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Burn-Tokens":{"role":"pseudoSymbol","abstract":[{"text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","kind":"section","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Burn-Tokens","type":"section","title":"Burn Tokens"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Non-Fungible-Tokens":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-non-fungible-tokens","abstract":[],"kind":"article","title":"Managing Non-Fungible Tokens","type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Transaction-Context-Data":{"title":"Accessing Transaction Context Data","url":"\/tutorials\/spacekit\/getinfo#Accessing-Transaction-Context-Data","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","type":"section","kind":"section","abstract":[{"text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract":{"role":"project","estimatedTime":"20min","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"kind":"project","url":"\/tutorials\/spacekit\/codingyourfirstcontract","type":"topic","title":"Building Your First Smart Contract"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Enhancing-Contracts-with-Token-Attributes":{"abstract":[],"title":"Enhancing Contracts with Token Attributes","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/enhancing-contracts-with-token-attributes","kind":"article","role":"article"},"TokenAttributesSection2Step7.swift":{"type":"file","highlights":[{"line":75},{"line":76}],"fileType":"swift","identifier":"TokenAttributesSection2Step7.swift","syntax":"swift","fileName":"lib.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""]},"TokenAttributesSection1Step4.swift":{"syntax":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","    }","}",""],"highlights":[{"line":24},{"line":26},{"line":27},{"line":28}],"type":"file","fileName":"lib.swift","identifier":"TokenAttributesSection1Step4.swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","kind":"project","type":"topic","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"role":"project","url":"\/tutorials\/spacekit\/installingtools","estimatedTime":"10min","title":"Install the Necessary Tools"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens":{"title":"Managing Fungible Tokens","role":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","kind":"project","type":"topic","estimatedTime":"15min","url":"\/tutorials\/spacekit\/operationsonfungibletokens","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}]},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Initializing-the-Project":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"kind":"section","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Initializing-the-Project","type":"section","title":"Initializing the Project"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce":{"title":"Add Quantity to an Existing Nonce","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce","kind":"section","type":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Add-Quantity-to-an-Existing-Nonce","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}]},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint":{"title":"Implementing the changeTokenLockDuration Endpoint","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint","kind":"section","type":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-changeTokenLockDuration-Endpoint","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}]},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Perform-an-Asynchronous-Call":{"abstract":[{"text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources.","type":"text"}],"url":"\/tutorials\/spacekit\/asynccalls#Perform-an-Asynchronous-Call","title":"Perform an Asynchronous Call","type":"section","kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call"},"TokenAttributesSection1Step9.swift":{"type":"file","highlights":[{"line":59},{"line":60}],"fileType":"swift","identifier":"TokenAttributesSection1Step9.swift","syntax":"swift","fileName":"lib.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","}",""]},"TokenAttributesSection1Step2.swift":{"syntax":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","}",""],"highlights":[{"line":3},{"line":4},{"line":5},{"line":6},{"line":7},{"line":8},{"line":23}],"type":"file","fileName":"lib.swift","identifier":"TokenAttributesSection1Step2.swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Calling-Contracts-Across-Shards":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/calling-contracts-across-shards","abstract":[],"kind":"article","title":"Calling Contracts Across Shards","type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges":{"title":"Handling Heap Allocation Challenges","role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Handling-Heap-Allocation-Challenges","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues":{"role":"project","estimatedTime":"15min","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"kind":"project","url":"\/tutorials\/spacekit\/storevalues","type":"topic","title":"Persist Values Between Executions"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Creating-and-Understanding-Tokens":{"role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","abstract":[],"kind":"article","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/creating-and-understanding-tokens","type":"topic","title":"Creating and Understanding Tokens"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-Vector-Type":{"abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-Vector-Type","title":"Working with the Vector Type","type":"section","kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens","kind":"project","type":"topic","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"role":"project","url":"\/tutorials\/spacekit\/understandtokens","estimatedTime":"15min","title":"Understand the ESDT Standard"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Building-Your-First-Smart-Contract":{"role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","abstract":[],"kind":"article","url":"\/tutorials\/spacekit\/getting-started\/building-your-first-smart-contract","type":"topic","title":"Building Your First Smart Contract"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Installing-the-Tools":{"abstract":[],"kind":"article","title":"Installing the Tools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools","url":"\/tutorials\/spacekit\/getting-started\/installing-the-tools","type":"topic","role":"article"},"TokenAttributesSection2Step4.swift":{"type":"file","highlights":[{"line":63},{"line":64},{"line":65},{"line":66}],"fileType":"swift","identifier":"TokenAttributesSection2Step4.swift","syntax":"swift","fileName":"lib.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        ","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""]},"TokenAttributesSection1Step7.swift":{"highlights":[{"line":41},{"line":42},{"line":43},{"line":44},{"line":45},{"line":46},{"line":47},{"line":48},{"line":49},{"line":50},{"line":51}],"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","    }","}",""],"type":"file","fileName":"lib.swift","fileType":"swift","syntax":"swift","identifier":"TokenAttributesSection1Step7.swift"},"TokenAttributesSection1Step1.swift":{"identifier":"TokenAttributesSection1Step1.swift","type":"file","syntax":"swift","content":["import SpaceKit","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","}"],"fileName":"lib.swift","fileType":"swift","highlights":[]},"TokenAttributesSection2Step11.swift":{"highlights":[{"line":92},{"line":93}],"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"type":"file","fileName":"lib.swift","fileType":"swift","syntax":"swift","identifier":"TokenAttributesSection2Step11.swift"},"TokenAttributesSection2Step5.swift":{"fileType":"swift","identifier":"TokenAttributesSection2Step5.swift","highlights":[{"line":64},{"line":66},{"line":67},{"line":68}],"syntax":"swift","type":"file","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-unlockFunds-Endpoint":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"kind":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-unlockFunds-Endpoint","type":"section","title":"Implementing the unlockFunds Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Installing-SpaceKits-Dependencies":{"kind":"section","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","url":"\/tutorials\/spacekit\/installingtools#Installing-SpaceKits-Dependencies","title":"Installing SpaceKit's Dependencies","role":"pseudoSymbol"},"TokenAttributesSection1Step6.swift":{"fileName":"lib.swift","syntax":"swift","highlights":[{"line":35},{"line":36},{"line":37},{"line":38},{"line":39},{"line":40}],"fileType":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","    }","}",""],"type":"file","identifier":"TokenAttributesSection1Step6.swift"},"TokenAttributesSection3Step8.swift":{"fileType":"swift","identifier":"TokenAttributesSection3Step8.swift","highlights":[{"line":120},{"line":121},{"line":122},{"line":123},{"line":124},{"line":125},{"line":126}],"syntax":"swift","type":"file","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        var attributes = self.getTokenAttributes(nonce: payment.nonce)","        attributes.lockDuration = newLockDuration","        ","        Blockchain","            .updateNftAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: payment.nonce,","                attributes: attributes","            )","        ","        Message.caller","            .send(","                tokenIdentifier: payment.tokenIdentifier,","                nonce: payment.nonce,","                amount: payment.amount","            )","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileName":"lib.swift"},"TokenAttributesSection3Step3.swift":{"fileName":"lib.swift","syntax":"swift","highlights":[{"line":98},{"line":99},{"line":100},{"line":101},{"line":102},{"line":103}],"fileType":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"type":"file","identifier":"TokenAttributesSection3Step3.swift"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"kind":"section","url":"\/tutorials\/spacekit\/storevalues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","type":"section","title":"Leveraging @Mapping for Dynamic Key-Value Storage"},"TokenAttributesSection1Step5.swift":{"fileType":"swift","identifier":"TokenAttributesSection1Step5.swift","highlights":[{"line":29},{"line":30},{"line":31},{"line":32},{"line":33},{"line":34}],"syntax":"swift","type":"file","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","    }","}",""],"fileName":"lib.swift"},"TokenAttributesSection3Step1.swift":{"fileName":"lib.swift","syntax":"swift","highlights":[],"fileType":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"type":"file","identifier":"TokenAttributesSection3Step1.swift"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Working-with-Storage-for-Single-Value-Persistence":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence","url":"\/tutorials\/spacekit\/storevalues#Working-with-Storage-for-Single-Value-Persistence","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"kind":"section","title":"Working with @Storage for Single Value Persistence","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-BigUint-Type":{"title":"Working with the BigUint Type","url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-BigUint-Type","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","type":"section","kind":"section","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Declare-the-Callee-Proxy":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","kind":"section","type":"section","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/asynccalls#Declare-the-Callee-Proxy","title":"Declare the Callee Proxy"},"doc://SpaceKit/tutorials/SpaceKit":{"title":"Meet SpaceKit","url":"\/tutorials\/spacekit","role":"overview","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","type":"topic","kind":"overview","abstract":[{"text":"Discover how SpaceKit simplifies blockchain development using Swift. Dive into the world of Web3 with ease and efficiency.","type":"text"}]},"TokenAttributesSection3Step5.swift":{"highlights":[{"line":110},{"line":111}],"syntax":"swift","fileType":"swift","identifier":"TokenAttributesSection3Step5.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        var attributes = self.getTokenAttributes(nonce: payment.nonce)","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileName":"lib.swift","type":"file"},"TokenAttributesSection3Step7.swift":{"identifier":"TokenAttributesSection3Step7.swift","fileType":"swift","type":"file","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        var attributes = self.getTokenAttributes(nonce: payment.nonce)","        attributes.lockDuration = newLockDuration","        ","        Blockchain","            .updateNftAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: payment.nonce,","                attributes: attributes","            )","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"highlights":[{"line":113},{"line":114},{"line":115},{"line":116},{"line":117},{"line":118},{"line":119}],"fileName":"lib.swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","estimatedTime":"10min","kind":"project","abstract":[{"text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner.","type":"text"}],"url":"\/tutorials\/spacekit\/getinfo","title":"Retrieving Information from the Blockchain","type":"topic","role":"project"},"TokenAttributesSection2Step9.swift":{"fileName":"lib.swift","fileType":"swift","syntax":"swift","type":"file","identifier":"TokenAttributesSection2Step9.swift","highlights":[{"line":83},{"line":84},{"line":85},{"line":86},{"line":87},{"line":88}],"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Mint-New-Tokens":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","kind":"section","type":"section","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Mint-New-Tokens","title":"Mint New Tokens"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls","kind":"project","type":"topic","abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}],"role":"project","url":"\/tutorials\/spacekit\/synccalls","estimatedTime":"15min","title":"Interact with Other Contracts"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens":{"abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens","title":"Managing Non-Fungible Tokens","type":"topic","kind":"project","estimatedTime":"15min","role":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Create-a-New-Nonce":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce","kind":"section","type":"section","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Create-a-New-Nonce","title":"Create a New Nonce"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Testing-the-Contract":{"abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Testing-the-Contract","title":"Testing the Contract","kind":"section","type":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Retrieving-Information-from-the-Blockchain":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","kind":"article","type":"topic","abstract":[],"role":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/retrieving-information-from-the-blockchain","title":"Retrieving Information from the Blockchain"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Persisting-Data-Across-Executions":{"title":"Persisting Data Across Executions","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/persisting-data-across-executions","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","type":"topic","kind":"article","abstract":[]},"TokenAttributesSection1Step8.swift":{"identifier":"TokenAttributesSection1Step8.swift","fileType":"swift","type":"file","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","    }","}",""],"highlights":[{"line":52},{"line":53},{"line":54},{"line":55},{"line":56},{"line":57},{"line":58}],"fileName":"lib.swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract":{"abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"url":"\/tutorials\/spacekit\/installingtools#Initializing-and-Compiling-Your-First-Smart-Contract","title":"Initializing and Compiling Your First Smart Contract","type":"section","kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","kind":"section","abstract":[{"text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with.","type":"text"}],"url":"\/tutorials\/spacekit\/operationsonfungibletokens#Assign-Mint-and-Burn-Roles","title":"Assign Mint and Burn Roles","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Exploring-SpaceKit's-Types":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","kind":"article","type":"topic","abstract":[],"role":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/exploring-spacekit's-types","title":"Exploring SpaceKit's Types"},"TokenAttributesSection2Step1.swift":{"fileName":"lib.swift","fileType":"swift","syntax":"swift","type":"file","identifier":"TokenAttributesSection2Step1.swift","highlights":[],"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Declare-the-Callee-Proxy":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","url":"\/tutorials\/spacekit\/synccalls#Declare-the-Callee-Proxy","abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}],"kind":"section","title":"Declare the Callee Proxy","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls":{"title":"Interacting with Contracts Across Shards","role":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","kind":"project","type":"topic","estimatedTime":"15min","url":"\/tutorials\/spacekit\/asynccalls","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Burn-Tokens":{"abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"kind":"section","title":"Burn Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Burn-Tokens","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Blockchain-Context-Data":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data","kind":"section","type":"section","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/getinfo#Accessing-Blockchain-Context-Data","title":"Accessing Blockchain Context Data"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract","kind":"section","type":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Meta-ESDT-from-Your-Contract","title":"Issuing a Meta ESDT from Your Contract"}}}

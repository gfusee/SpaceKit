{"schemaVersion":{"major":0,"minor":3,"patch":0},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/tutorials\/spacekit\/tokenattributes"]}],"metadata":{"categoryPathComponent":"SpaceKit","category":"SpaceKit","role":"project","title":"Enhance Your Contracts with Token Attributes"},"kind":"project","sections":[{"kind":"hero","title":"Enhance Your Contracts with Token Attributes","estimatedTimeInMinutes":15,"content":[{"type":"paragraph","inlineContent":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"In this tutorial, you’ll explore a practical use case for this feature by building a smart contract that locks funds inside an NFT for a specified duration. The NFT can be transferred freely, and once the lock period expires, the holder can reclaim the locked funds.","type":"text"}]},{"inlineContent":[{"text":"You’ll implement the following contract endpoints:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"lockFunds"},{"type":"text","text":": Accepts a single payment, locks the funds, mints an NFT with attributes, and transfers it to the caller. "},{"inlineContent":[{"type":"text","text":"Concept covered:"}],"type":"strong"},{"text":" Creating a token with custom attributes.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"unlockFunds"},{"type":"text","text":": Accepts an NFT payment, verifies the attributes to determine if the funds can be unlocked, and if so, burns the NFT and releases the locked funds. Fails otherwise. "},{"type":"strong","inlineContent":[{"text":"Concept covered:","type":"text"}]},{"type":"text","text":" Reading token attributes."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"changeTokenLockDuration"},{"type":"text","text":": Restricted to the contract owner, this endpoint accepts an NFT payment, updates the lock duration, and returns the modified NFT to the caller. "},{"inlineContent":[{"type":"text","text":"Concept covered:"}],"type":"strong"},{"text":" Modifying NFT attributes.","type":"text"}]}]}],"type":"unorderedList"}],"chapter":"Enhancing Contracts with Token Attributes"},{"kind":"tasks","tasks":[{"anchor":"Implementing-the-lockFunds-Endpoint","title":"Implementing the lockFunds Endpoint","contentSection":[{"kind":"contentAndMedia","content":[{"inlineContent":[{"type":"text","text":"In this section, you’ll create an NFT representing the locked funds sent by the caller. You’ll learn how to embed custom attributes in an NFT."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Before proceeding, ensure that the non-fungible collection is already issued and that the contract possesses the required roles (refer to previous chapters)."}],"type":"paragraph"}],"mediaPosition":"trailing"}],"stepsSection":[{"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Define the contract structure.","type":"text"}]}],"media":null,"caption":[{"inlineContent":[{"type":"text","text":"The contract stores the NFT token identifier and the lock duration, both specified by the owner during deployment."}],"type":"paragraph"}],"code":"TokenAttributesSection1Step1.swift","runtimePreview":null},{"type":"step","media":null,"runtimePreview":null,"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use any SpaceKit types, as well as structs annotated with "},{"code":"@Codable","type":"codeVoice"},{"text":".","type":"text"}]}],"code":"TokenAttributesSection1Step2.swift","content":[{"inlineContent":[{"text":"Define the attributes structure.","type":"text"}],"type":"paragraph"}]},{"runtimePreview":null,"code":"TokenAttributesSection1Step3.swift","type":"step","media":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Implement the "},{"type":"codeVoice","code":"lockFunds"},{"type":"text","text":" endpoint, which returns the nonce of the minted NFT."}]}],"caption":[]},{"caption":[],"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Ensure the contract has permission to create NFTs.","type":"text"}]}],"media":null,"code":"TokenAttributesSection1Step4.swift","runtimePreview":null},{"runtimePreview":null,"type":"step","caption":[],"media":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Retrieve and validate the payment to be locked, ensuring it’s greater than zero."}]}],"code":"TokenAttributesSection1Step5.swift"},{"type":"step","media":null,"code":"TokenAttributesSection1Step6.swift","runtimePreview":null,"caption":[],"content":[{"inlineContent":[{"text":"Construct the attributes to be embedded in the NFT.","type":"text"}],"type":"paragraph"}]},{"media":null,"code":"TokenAttributesSection1Step7.swift","caption":[],"content":[{"inlineContent":[{"text":"Mint the NFT and assign the attributes.","type":"text"}],"type":"paragraph"}],"type":"step","runtimePreview":null},{"type":"step","media":null,"caption":[],"code":"TokenAttributesSection1Step8.swift","runtimePreview":null,"content":[{"inlineContent":[{"text":"Transfer the created NFT to the caller.","type":"text"}],"type":"paragraph"}]},{"runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"Return the created nonce."}],"type":"paragraph"}],"caption":[],"media":null,"type":"step","code":"TokenAttributesSection1Step9.swift"}]},{"title":"Implementing the unlockFunds Endpoint","anchor":"Implementing-the-unlockFunds-Endpoint","stepsSection":[{"runtimePreview":null,"code":"TokenAttributesSection2Step1.swift","caption":[],"content":[{"type":"paragraph","inlineContent":[{"text":"Reuse the contract structure from the previous section.","type":"text"}]}],"type":"step","media":null},{"media":null,"runtimePreview":null,"code":"TokenAttributesSection2Step2.swift","caption":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Note:","type":"text"}]},{"type":"text","text":" This function is not an endpoint and remains private."}],"type":"paragraph"}],"type":"step","content":[{"inlineContent":[{"type":"text","text":"Implement a helper function to retrieve NFT attributes."}],"type":"paragraph"}]},{"runtimePreview":null,"media":null,"type":"step","caption":[],"content":[{"inlineContent":[{"type":"text","text":"Use "},{"code":"Blockchain.getTokenAttributes","type":"codeVoice"},{"type":"text","text":" to retrieve attributes."}],"type":"paragraph"}],"code":"TokenAttributesSection2Step3.swift"},{"media":null,"code":"TokenAttributesSection2Step4.swift","type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Declare the ","type":"text"},{"type":"codeVoice","code":"unlockFunds"},{"type":"text","text":" endpoint, returning the unlocked amount."}]}],"runtimePreview":null,"caption":[]},{"caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Verify that the contract has permission to burn tokens."}]}],"code":"TokenAttributesSection2Step5.swift","type":"step","runtimePreview":null,"media":null},{"code":"TokenAttributesSection2Step6.swift","runtimePreview":null,"media":null,"caption":[],"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Retrieve the NFT payment and validate its token identifier.","type":"text"}]}]},{"runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Extract the attributes using the helper function.","type":"text"}]}],"caption":[],"type":"step","media":null,"code":"TokenAttributesSection2Step7.swift"},{"runtimePreview":null,"media":null,"type":"step","caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Determine whether funds can be unlocked based on attributes."}]}],"code":"TokenAttributesSection2Step8.swift"},{"runtimePreview":null,"type":"step","content":[{"inlineContent":[{"text":"Burn the NFT if conditions are met.","type":"text"}],"type":"paragraph"}],"code":"TokenAttributesSection2Step9.swift","caption":[],"media":null},{"type":"step","caption":[],"runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"Transfer the unlocked funds to the caller."}],"type":"paragraph"}],"code":"TokenAttributesSection2Step10.swift","media":null},{"runtimePreview":null,"code":"TokenAttributesSection2Step11.swift","content":[{"inlineContent":[{"type":"text","text":"Return the amount of funds unlocked."}],"type":"paragraph"}],"caption":[],"media":null,"type":"step"}],"contentSection":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This section covers unlocking funds when the lock period expires. If the NFT meets the criteria, it is burned, and the funds are released."}]},{"type":"paragraph","inlineContent":[{"text":"Note: To access an NFT’s attributes, the contract must temporarily own it. Directly reading attributes from an NFT held by another account is not possible.","type":"text"}]}],"mediaPosition":"trailing","kind":"contentAndMedia"}]},{"contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This section covers modifying an NFT’s lock duration, a feature restricted to the contract owner."}]},{"inlineContent":[{"inlineContent":[{"type":"text","text":"Important:"}],"type":"strong"},{"type":"text","text":" NFT attributes can only be modified for non-fungible tokens. This operation is not supported for semi-fungible tokens or meta-ESDTs."}],"type":"paragraph"}],"mediaPosition":"trailing"}],"anchor":"Implementing-the-changeTokenLockDuration-Endpoint","title":"Implementing the changeTokenLockDuration Endpoint","stepsSection":[{"caption":[],"content":[{"type":"paragraph","inlineContent":[{"text":"Reuse the contract structure from the previous section.","type":"text"}]}],"media":null,"runtimePreview":null,"type":"step","code":"TokenAttributesSection3Step1.swift"},{"runtimePreview":null,"media":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Declare the "},{"type":"codeVoice","code":"changeTokenLockDuration"},{"type":"text","text":" endpoint, restricting access to the contract owner. It accepts the new lock duration as a parameter."}]}],"type":"step","caption":[],"code":"TokenAttributesSection3Step2.swift"},{"runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Verify that the contract has the permission to modify NFT attributes.","type":"text"}]}],"type":"step","caption":[],"media":null,"code":"TokenAttributesSection3Step3.swift"},{"caption":[],"runtimePreview":null,"type":"step","media":null,"code":"TokenAttributesSection3Step4.swift","content":[{"type":"paragraph","inlineContent":[{"text":"Retrieve and validate the NFT payment.","type":"text"}]}]},{"runtimePreview":null,"content":[{"inlineContent":[{"text":"Extract the attributes as a mutable variable.","type":"text"}],"type":"paragraph"}],"type":"step","media":null,"code":"TokenAttributesSection3Step5.swift","caption":[]},{"media":null,"code":"TokenAttributesSection3Step6.swift","runtimePreview":null,"type":"step","caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Update the lock duration with the new value."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Call "},{"type":"codeVoice","code":"Blockchain.updateNftAttributes"},{"text":" to persist the new attributes.","type":"text"}],"type":"paragraph"}],"caption":[],"media":null,"code":"TokenAttributesSection3Step7.swift","runtimePreview":null,"type":"step"},{"type":"step","runtimePreview":null,"media":null,"code":"TokenAttributesSection3Step8.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Transfer the modified NFT back to the caller."}]}],"caption":[]}]}]}],"hierarchy":{"modules":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues"}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens","projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint","kind":"task"}]}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","paths":[["doc:\/\/SpaceKit\/tutorials\/SpaceKit","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes"]]},"references":{"TokenAttributesSection2Step8.swift":{"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileType":"swift","syntax":"swift","type":"file","fileName":"lib.swift","highlights":[{"line":77},{"line":78},{"line":79},{"line":80},{"line":81},{"line":82}],"identifier":"TokenAttributesSection2Step8.swift"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage":{"role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/storevalues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","kind":"section","title":"Leveraging @Mapping for Dynamic Key-Value Storage","abstract":[{"text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage"},"TokenAttributesSection1Step6.swift":{"fileType":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","    }","}",""],"highlights":[{"line":35},{"line":36},{"line":37},{"line":38},{"line":39},{"line":40}],"type":"file","fileName":"lib.swift","syntax":"swift","identifier":"TokenAttributesSection1Step6.swift"},"TokenAttributesSection1Step9.swift":{"fileType":"swift","type":"file","highlights":[{"line":59},{"line":60}],"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","}",""],"syntax":"swift","fileName":"lib.swift","identifier":"TokenAttributesSection1Step9.swift"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Add-Quantity-to-an-Existing-Nonce","title":"Add Quantity to an Existing Nonce","kind":"section","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce","role":"pseudoSymbol","type":"section"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Calling-Contracts-Across-Shards":{"role":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/calling-contracts-across-shards","kind":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","type":"topic","abstract":[],"title":"Calling Contracts Across Shards"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint":{"title":"Implementing the changeTokenLockDuration Endpoint","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint","type":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-changeTokenLockDuration-Endpoint","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}]},"TokenAttributesSection2Step10.swift":{"identifier":"TokenAttributesSection2Step10.swift","type":"file","highlights":[{"line":89},{"line":90},{"line":91}],"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileName":"lib.swift","fileType":"swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Testing-the-Contract":{"type":"section","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Testing-the-Contract","abstract":[{"text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions.","type":"text"}],"title":"Testing the Contract","kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"text":" ","type":"text"},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"type":"topic","estimatedTime":"15min","title":"Understand the ESDT Standard","kind":"project","url":"\/tutorials\/spacekit\/understandtokens","role":"project"},"TokenAttributesSection1Step2.swift":{"fileType":"swift","type":"file","highlights":[{"line":3},{"line":4},{"line":5},{"line":6},{"line":7},{"line":8},{"line":23}],"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","}",""],"syntax":"swift","fileName":"lib.swift","identifier":"TokenAttributesSection1Step2.swift"},"TokenAttributesSection1Step7.swift":{"identifier":"TokenAttributesSection1Step7.swift","type":"file","highlights":[{"line":41},{"line":42},{"line":43},{"line":44},{"line":45},{"line":46},{"line":47},{"line":48},{"line":49},{"line":50},{"line":51}],"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","    }","}",""],"fileName":"lib.swift","fileType":"swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Writing-the-Contract-Code":{"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Writing-the-Contract-Code","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","type":"section","abstract":[{"text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions.","type":"text"}],"title":"Writing the Contract Code"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens":{"title":"Managing Fungible Tokens","role":"project","kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","estimatedTime":"15min","type":"topic","url":"\/tutorials\/spacekit\/operationsonfungibletokens","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}]},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Blockchain-Context-Data":{"kind":"section","role":"pseudoSymbol","title":"Accessing Blockchain Context Data","url":"\/tutorials\/spacekit\/getinfo#Accessing-Blockchain-Context-Data","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data","abstract":[{"text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner.","type":"text"}],"type":"section"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Mint-New-Tokens":{"url":"\/tutorials\/spacekit\/operationsonfungibletokens#Mint-New-Tokens","type":"section","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"kind":"section","title":"Mint New Tokens","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Working-with-Storage-for-Single-Value-Persistence":{"role":"pseudoSymbol","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence","kind":"section","url":"\/tutorials\/spacekit\/storevalues#Working-with-Storage-for-Single-Value-Persistence","title":"Working with @Storage for Single Value Persistence","abstract":[{"text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract":{"role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","kind":"section","title":"Issuing a Non-Fungible Token from Your Contract","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"type":"text","text":" "},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract"},"TokenAttributesSection3Step1.swift":{"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"highlights":[],"type":"file","identifier":"TokenAttributesSection3Step1.swift","syntax":"swift","fileType":"swift","fileName":"lib.swift"},"TokenAttributesSection3Step5.swift":{"type":"file","syntax":"swift","fileName":"lib.swift","identifier":"TokenAttributesSection3Step5.swift","fileType":"swift","highlights":[{"line":110},{"line":111}],"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        var attributes = self.getTokenAttributes(nonce: payment.nonce)","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Persisting-Data-Across-Executions":{"url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/persisting-data-across-executions","kind":"article","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","role":"article","abstract":[],"title":"Persisting Data Across Executions"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Exploring-SpaceKit's-Types":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","role":"article","abstract":[],"title":"Exploring SpaceKit's Types","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/exploring-spacekit's-types","type":"topic","kind":"article"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Enhancing-Contracts-with-Token-Attributes":{"kind":"article","role":"article","title":"Enhancing Contracts with Token Attributes","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/enhancing-contracts-with-token-attributes","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes","abstract":[],"type":"topic"},"TokenAttributesSection2Step5.swift":{"type":"file","syntax":"swift","fileName":"lib.swift","fileType":"swift","identifier":"TokenAttributesSection2Step5.swift","highlights":[{"line":64},{"line":66},{"line":67},{"line":68}],"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit":{"role":"overview","type":"topic","url":"\/tutorials\/spacekit","kind":"overview","title":"Meet SpaceKit","abstract":[{"text":"Discover how SpaceKit simplifies blockchain development using Swift. Dive into the world of Web3 with ease and efficiency.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit"},"TokenAttributesSection3Step8.swift":{"syntax":"swift","identifier":"TokenAttributesSection3Step8.swift","type":"file","fileName":"lib.swift","fileType":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        var attributes = self.getTokenAttributes(nonce: payment.nonce)","        attributes.lockDuration = newLockDuration","        ","        Blockchain","            .updateNftAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: payment.nonce,","                attributes: attributes","            )","        ","        Message.caller","            .send(","                tokenIdentifier: payment.tokenIdentifier,","                nonce: payment.nonce,","                amount: payment.amount","            )","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"highlights":[{"line":120},{"line":121},{"line":122},{"line":123},{"line":124},{"line":125},{"line":126}]},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","title":"Interacting with Contracts Across Shards","abstract":[{"text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources.","type":"text"}],"type":"topic","estimatedTime":"15min","role":"project","url":"\/tutorials\/spacekit\/asynccalls","kind":"project"},"TokenAttributesSection2Step2.swift":{"syntax":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        ","    }","}",""],"fileType":"swift","type":"file","fileName":"lib.swift","highlights":[{"line":62},{"line":63},{"line":64},{"line":65}],"identifier":"TokenAttributesSection2Step2.swift"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract","role":"pseudoSymbol","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"title":"Initializing and Compiling Your First Smart Contract","url":"\/tutorials\/spacekit\/installingtools#Initializing-and-Compiling-Your-First-Smart-Contract","type":"section","kind":"section"},"TokenAttributesSection2Step1.swift":{"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","}",""],"highlights":[],"type":"file","identifier":"TokenAttributesSection2Step1.swift","fileType":"swift","syntax":"swift","fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract":{"type":"topic","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract","estimatedTime":"20min","title":"Building Your First Smart Contract","kind":"project","url":"\/tutorials\/spacekit\/codingyourfirstcontract","role":"project"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-BigUint-Type":{"url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-BigUint-Type","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","role":"pseudoSymbol","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"title":"Working with the BigUint Type"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Understanding-the-Buffer-Type":{"kind":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Understanding-the-Buffer-Type","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"role":"pseudoSymbol","type":"section","title":"Understanding the Buffer Type"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract":{"url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Meta-ESDT-from-Your-Contract","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract","role":"pseudoSymbol","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"title":"Issuing a Meta ESDT from Your Contract"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","title":"Issuing a Semi-Fungible Token from Your Contract","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"type":"text","text":" "},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"type":"section","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Declare-the-Callee-Proxy":{"title":"Declare the Callee Proxy","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","kind":"section","type":"section","url":"\/tutorials\/spacekit\/synccalls#Declare-the-Callee-Proxy","abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-Vector-Type":{"role":"pseudoSymbol","title":"Working with the Vector Type","kind":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-Vector-Type","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"type":"section"},"TokenAttributesSection3Step4.swift":{"syntax":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileType":"swift","type":"file","fileName":"lib.swift","highlights":[{"line":104},{"line":105},{"line":106},{"line":107},{"line":108},{"line":109}],"identifier":"TokenAttributesSection3Step4.swift"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes":{"type":"topic","title":"Exploring SpaceKit's Types","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes","role":"project","url":"\/tutorials\/spacekit\/familiarizewithtypes","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"kind":"project","estimatedTime":"20min"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls":{"role":"project","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls","kind":"project","url":"\/tutorials\/spacekit\/synccalls","estimatedTime":"15min","title":"Interact with Other Contracts","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}]},"TokenAttributesSection2Step11.swift":{"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"highlights":[{"line":92},{"line":93}],"type":"file","identifier":"TokenAttributesSection2Step11.swift","fileType":"swift","syntax":"swift","fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Installing-the-Tools":{"type":"topic","title":"Installing the Tools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools","role":"article","url":"\/tutorials\/spacekit\/getting-started\/installing-the-tools","abstract":[],"kind":"article"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles":{"url":"\/tutorials\/spacekit\/operationsonfungibletokens#Assign-Mint-and-Burn-Roles","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","role":"pseudoSymbol","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"title":"Assign Mint and Burn Roles"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools":{"type":"topic","title":"Install the Necessary Tools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","role":"project","url":"\/tutorials\/spacekit\/installingtools","abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"kind":"project","estimatedTime":"10min"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","title":"Retrieving Information from the Blockchain","abstract":[{"text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner.","type":"text"}],"type":"topic","estimatedTime":"10min","role":"project","url":"\/tutorials\/spacekit\/getinfo","kind":"project"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Creating-and-Understanding-Tokens":{"role":"article","type":"topic","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/creating-and-understanding-tokens","kind":"article","title":"Creating and Understanding Tokens","abstract":[],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Perform-a-Synchronous-Call":{"role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/synccalls#Perform-a-Synchronous-Call","kind":"section","title":"Perform a Synchronous Call","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Non-Fungible-Tokens":{"type":"topic","title":"Managing Non-Fungible Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","role":"article","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-non-fungible-tokens","abstract":[],"kind":"article"},"TokenAttributesSection1Step5.swift":{"syntax":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","    }","}",""],"fileType":"swift","type":"file","fileName":"lib.swift","highlights":[{"line":29},{"line":30},{"line":31},{"line":32},{"line":33},{"line":34}],"identifier":"TokenAttributesSection1Step5.swift"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Building-Your-First-Smart-Contract":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","url":"\/tutorials\/spacekit\/getting-started\/building-your-first-smart-contract","abstract":[],"role":"article","type":"topic","kind":"article","title":"Building Your First Smart Contract"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges":{"kind":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Handling-Heap-Allocation-Challenges","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","role":"pseudoSymbol","type":"section","title":"Handling Heap Allocation Challenges"},"TokenAttributesSection1Step3.swift":{"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        ","    }","}",""],"highlights":[{"line":22},{"line":23},{"line":24},{"line":25}],"type":"file","identifier":"TokenAttributesSection1Step3.swift","fileType":"swift","syntax":"swift","fileName":"lib.swift"},"TokenAttributesSection2Step3.swift":{"syntax":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileType":"swift","type":"file","fileName":"lib.swift","highlights":[{"line":64},{"line":65},{"line":66},{"line":67},{"line":68}],"identifier":"TokenAttributesSection2Step3.swift"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Creating-Your-Own-Types":{"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/familiarizewithtypes#Creating-Your-Own-Types","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types","type":"section","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"title":"Creating Your Own Types"},"TokenAttributesSection1Step4.swift":{"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","    }","}",""],"highlights":[{"line":24},{"line":26},{"line":27},{"line":28}],"type":"file","identifier":"TokenAttributesSection1Step4.swift","fileType":"swift","syntax":"swift","fileName":"lib.swift"},"TokenAttributesSection3Step2.swift":{"syntax":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileType":"swift","type":"file","fileName":"lib.swift","highlights":[{"line":96},{"line":97},{"line":98},{"line":99}],"identifier":"TokenAttributesSection3Step2.swift"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-unlockFunds-Endpoint":{"role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-unlockFunds-Endpoint","kind":"section","title":"Implementing the unlockFunds Endpoint","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues":{"type":"topic","url":"\/tutorials\/spacekit\/storevalues","abstract":[{"text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory.","type":"text"}],"title":"Persist Values Between Executions","estimatedTime":"15min","kind":"project","role":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Create-a-New-Nonce":{"kind":"section","role":"pseudoSymbol","title":"Create a New Nonce","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Create-a-New-Nonce","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"type":"section"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes":{"title":"Enhance Your Contracts with Token Attributes","role":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","kind":"project","estimatedTime":"15min","type":"topic","url":"\/tutorials\/spacekit\/tokenattributes","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}]},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Perform-an-Asynchronous-Call":{"url":"\/tutorials\/spacekit\/asynccalls#Perform-an-Asynchronous-Call","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","role":"pseudoSymbol","abstract":[{"text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources.","type":"text"}],"title":"Perform an Asynchronous Call"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-lockFunds-Endpoint":{"type":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-lockFunds-Endpoint","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"title":"Implementing the lockFunds Endpoint","kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Interacting-with-Other-Contracts":{"type":"topic","title":"Interacting with Other Contracts","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","role":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/interacting-with-other-contracts","abstract":[],"kind":"article"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Burn-Tokens":{"url":"\/tutorials\/spacekit\/operationsonfungibletokens#Burn-Tokens","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","role":"pseudoSymbol","abstract":[{"text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with.","type":"text"}],"title":"Burn Tokens"},"TokenAttributesSection1Step1.swift":{"content":["import SpaceKit","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","}"],"fileName":"lib.swift","type":"file","syntax":"swift","highlights":[],"fileType":"swift","identifier":"TokenAttributesSection1Step1.swift"},"TokenAttributesSection2Step4.swift":{"syntax":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        ","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileType":"swift","type":"file","fileName":"lib.swift","highlights":[{"line":63},{"line":64},{"line":65},{"line":66}],"identifier":"TokenAttributesSection2Step4.swift"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","title":"Issuing a Fungible Token from Your Contract","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"type":"text","text":" "},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"type":"section","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Fungible-Token-from-Your-Contract","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"type":"section","title":"Assign Create, AddQuantity, and Burn Roles","kind":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Assign-Create-AddQuantity-and-Burn-Roles","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens","kind":"project","type":"topic","estimatedTime":"15min","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens","role":"project","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"title":"Managing Non-Fungible Tokens"},"TokenAttributesSection2Step6.swift":{"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"highlights":[{"line":69},{"line":70},{"line":71},{"line":72},{"line":73},{"line":74}],"type":"file","identifier":"TokenAttributesSection2Step6.swift","fileType":"swift","syntax":"swift","fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Retrieving-Information-from-the-Blockchain":{"url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/retrieving-information-from-the-blockchain","kind":"article","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","role":"article","abstract":[],"title":"Retrieving Information from the Blockchain"},"TokenAttributesSection2Step9.swift":{"syntax":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileType":"swift","type":"file","fileName":"lib.swift","highlights":[{"line":83},{"line":84},{"line":85},{"line":86},{"line":87},{"line":88}],"identifier":"TokenAttributesSection2Step9.swift"},"TokenAttributesSection3Step7.swift":{"fileType":"swift","type":"file","identifier":"TokenAttributesSection3Step7.swift","syntax":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        var attributes = self.getTokenAttributes(nonce: payment.nonce)","        attributes.lockDuration = newLockDuration","        ","        Blockchain","            .updateNftAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: payment.nonce,","                attributes: attributes","            )","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"highlights":[{"line":113},{"line":114},{"line":115},{"line":116},{"line":117},{"line":118},{"line":119}],"fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Declare-the-Callee-Proxy":{"type":"section","url":"\/tutorials\/spacekit\/asynccalls#Declare-the-Callee-Proxy","abstract":[{"text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources.","type":"text"}],"title":"Declare the Callee Proxy","kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Transaction-Context-Data":{"role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/getinfo#Accessing-Transaction-Context-Data","kind":"section","title":"Accessing Transaction Context Data","abstract":[{"text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Setting-Up-the-SpaceKit-CLI":{"role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/installingtools#Setting-Up-the-SpaceKit-CLI","kind":"section","title":"Setting Up the SpaceKit CLI","abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Fungible-Tokens":{"type":"topic","title":"Managing Fungible Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens","role":"article","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-fungible-tokens","abstract":[],"kind":"article"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Installing-SpaceKits-Dependencies":{"role":"pseudoSymbol","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","kind":"section","url":"\/tutorials\/spacekit\/installingtools#Installing-SpaceKits-Dependencies","title":"Installing SpaceKit's Dependencies","abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}]},"TokenAttributesSection2Step7.swift":{"fileType":"swift","identifier":"TokenAttributesSection2Step7.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"type":"file","syntax":"swift","highlights":[{"line":75},{"line":76}],"fileName":"lib.swift"},"TokenAttributesSection3Step3.swift":{"fileName":"lib.swift","type":"file","syntax":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"identifier":"TokenAttributesSection3Step3.swift","highlights":[{"line":98},{"line":99},{"line":100},{"line":101},{"line":102},{"line":103}],"fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Burn-Tokens":{"type":"section","title":"Burn Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Burn-Tokens","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"kind":"section"},"TokenAttributesSection1Step8.swift":{"highlights":[{"line":52},{"line":53},{"line":54},{"line":55},{"line":56},{"line":57},{"line":58}],"fileType":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","    }","}",""],"fileName":"lib.swift","type":"file","syntax":"swift","identifier":"TokenAttributesSection1Step8.swift"},"TokenAttributesSection3Step6.swift":{"highlights":[{"line":112}],"fileType":"swift","fileName":"lib.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    let lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: Buffer,","    lockDuration: UInt64",") {","    var controller = MyContract()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: Buffer","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        var attributes = self.getTokenAttributes(nonce: payment.nonce)","        attributes.lockDuration = newLockDuration","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"syntax":"swift","type":"file","identifier":"TokenAttributesSection3Step6.swift"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Initializing-the-Project":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Initializing-the-Project","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","role":"pseudoSymbol","abstract":[{"text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions.","type":"text"}],"title":"Initializing the Project"}}}
{"hierarchy":{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","modules":[{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract"}]},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data"}]}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts"},{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards"},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens"}]}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes"}]},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro#Set-Up-the-Project"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Build-a-Coin-Flip-Smart-Contract"},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Flip-Structure"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Implement-Contract-Storage","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Contract-Init","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Define-the-Storage-for-the-Flip-Contract"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Add-Administrative-Endpoints-to-the-Flip-Contract","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-the-Minimum-Block-Bounty-Delay"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-Maximum-Bet-Limits","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Increase-Contract-Reserves"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Withdraw-Contract-Reserves","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Implement-the-Game-Logic-for-the-Flip-Contract","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-flip-Endpoint"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-makeFlip-Function","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Define-the-bounty-Endpoint","kind":"task"}]}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Set-Up-the-Test-Project"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Declare-Constants-for-the-Test-Environment"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Configure-the-Initial-Blockchain-State","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Write-Tests-for-the-Setup-Helpers","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Set-Up-Testing-in-the-SwiftVM"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Admin-Endpoints","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-the-Maximum-Bet-Configuration-Endpoints"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-increaseReserve-Endpoint"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-withdrawReserve-Endpoint","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin"}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Create-Utility-Functions-for-flip-and-bounty","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Cases-for-the-flip-Endpoint","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Successful-Calls-to-the-flip-Endpoint"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Case-for-the-bounty-Endpoint","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-the-bounty-Endpoint","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Game-Logic-for-the-Flip-Contract"}],"paths":[["doc:\/\/SpaceKit\/tutorials\/SpaceKit","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes"]]},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/tutorials\/spacekit\/tokenattributes"]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes"},"kind":"project","schemaVersion":{"major":0,"minor":3,"patch":0},"metadata":{"title":"Enhance Your Contracts with Token Attributes","categoryPathComponent":"SpaceKit","category":"SpaceKit","role":"project"},"sections":[{"chapter":"Enhancing Contracts with Token Attributes","title":"Enhance Your Contracts with Token Attributes","kind":"hero","estimatedTimeInMinutes":15,"content":[{"type":"paragraph","inlineContent":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}]},{"inlineContent":[{"text":"In this tutorial, you’ll explore a practical use case for this feature by building a smart contract that locks funds inside an NFT for a specified duration. The NFT can be transferred freely, and once the lock period expires, the holder can reclaim the locked funds.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"You’ll implement the following contract endpoints:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"lockFunds","type":"codeVoice"},{"text":": Accepts a single payment, locks the funds, mints an NFT with attributes, and transfers it to the caller. ","type":"text"},{"type":"strong","inlineContent":[{"type":"text","text":"Concept covered:"}]},{"type":"text","text":" Creating a token with custom attributes."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"unlockFunds"},{"type":"text","text":": Accepts an NFT payment, verifies the attributes to determine if the funds can be unlocked, and if so, burns the NFT and releases the locked funds. Fails otherwise. "},{"type":"strong","inlineContent":[{"type":"text","text":"Concept covered:"}]},{"type":"text","text":" Reading token attributes."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"changeTokenLockDuration"},{"type":"text","text":": Restricted to the contract owner, this endpoint accepts an NFT payment, updates the lock duration, and returns the modified NFT to the caller. "},{"type":"strong","inlineContent":[{"type":"text","text":"Concept covered:"}]},{"text":" Modifying NFT attributes.","type":"text"}]}]}]}]},{"kind":"tasks","tasks":[{"title":"Implementing the lockFunds Endpoint","stepsSection":[{"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The contract stores the NFT token identifier and the lock duration, both specified by the owner during deployment."}]}],"code":"TokenAttributesSection1Step1.swift","runtimePreview":null,"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define the contract structure."}]}],"media":null},{"type":"step","media":null,"content":[{"inlineContent":[{"type":"text","text":"Define the attributes structure."}],"type":"paragraph"}],"runtimePreview":null,"caption":[{"inlineContent":[{"text":"You can use any SpaceKit types, as well as structs annotated with ","type":"text"},{"code":"@Codable","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}],"code":"TokenAttributesSection1Step2.swift"},{"caption":[],"code":"TokenAttributesSection1Step3.swift","runtimePreview":null,"media":null,"content":[{"inlineContent":[{"type":"text","text":"Implement the "},{"code":"lockFunds","type":"codeVoice"},{"text":" endpoint, which returns the nonce of the minted NFT.","type":"text"}],"type":"paragraph"}],"type":"step"},{"content":[{"inlineContent":[{"type":"text","text":"Ensure the contract has permission to create NFTs."}],"type":"paragraph"}],"caption":[],"media":null,"runtimePreview":null,"code":"TokenAttributesSection1Step4.swift","type":"step"},{"type":"step","media":null,"runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Retrieve and validate the payment to be locked, ensuring it’s greater than zero."}]}],"caption":[],"code":"TokenAttributesSection1Step5.swift"},{"type":"step","caption":[],"media":null,"code":"TokenAttributesSection1Step6.swift","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Construct the attributes to be embedded in the NFT."}]}]},{"code":"TokenAttributesSection1Step7.swift","type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Mint the NFT and assign the attributes."}]}],"caption":[],"media":null,"runtimePreview":null},{"media":null,"code":"TokenAttributesSection1Step8.swift","runtimePreview":null,"caption":[],"content":[{"inlineContent":[{"type":"text","text":"Transfer the created NFT to the caller."}],"type":"paragraph"}],"type":"step"},{"type":"step","code":"TokenAttributesSection1Step9.swift","runtimePreview":null,"media":null,"content":[{"inlineContent":[{"text":"Return the created nonce.","type":"text"}],"type":"paragraph"}],"caption":[]}],"anchor":"Implementing-the-lockFunds-Endpoint","contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In this section, you’ll create an NFT representing the locked funds sent by the caller. You’ll learn how to embed custom attributes in an NFT."}]},{"inlineContent":[{"text":"Before proceeding, ensure that the non-fungible collection is already issued and that the contract possesses the required roles (refer to previous chapters).","type":"text"}],"type":"paragraph"}],"mediaPosition":"trailing"}]},{"stepsSection":[{"content":[{"inlineContent":[{"type":"text","text":"Reuse the contract structure from the previous section."}],"type":"paragraph"}],"caption":[],"code":"TokenAttributesSection2Step1.swift","type":"step","runtimePreview":null,"media":null},{"media":null,"type":"step","caption":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Note:"}]},{"text":" This function is not an endpoint and remains private.","type":"text"}]}],"code":"TokenAttributesSection2Step2.swift","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Implement a helper function to retrieve NFT attributes."}]}]},{"code":"TokenAttributesSection2Step3.swift","type":"step","media":null,"runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"Use "},{"type":"codeVoice","code":"Blockchain.getTokenAttributes"},{"text":" to retrieve attributes.","type":"text"}],"type":"paragraph"}],"caption":[]},{"media":null,"content":[{"inlineContent":[{"type":"text","text":"Declare the "},{"type":"codeVoice","code":"unlockFunds"},{"type":"text","text":" endpoint, returning the unlocked amount."}],"type":"paragraph"}],"code":"TokenAttributesSection2Step4.swift","runtimePreview":null,"caption":[],"type":"step"},{"runtimePreview":null,"caption":[],"code":"TokenAttributesSection2Step5.swift","type":"step","content":[{"inlineContent":[{"type":"text","text":"Verify that the contract has permission to burn tokens."}],"type":"paragraph"}],"media":null},{"caption":[],"code":"TokenAttributesSection2Step6.swift","runtimePreview":null,"media":null,"content":[{"inlineContent":[{"type":"text","text":"Retrieve the NFT payment and validate its token identifier."}],"type":"paragraph"}],"type":"step"},{"code":"TokenAttributesSection2Step7.swift","caption":[],"runtimePreview":null,"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Extract the attributes using the helper function."}]}],"media":null},{"runtimePreview":null,"code":"TokenAttributesSection2Step8.swift","caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Determine whether funds can be unlocked based on attributes."}]}],"type":"step","media":null},{"type":"step","media":null,"code":"TokenAttributesSection2Step9.swift","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Burn the NFT if conditions are met."}]}],"caption":[]},{"type":"step","runtimePreview":null,"code":"TokenAttributesSection2Step10.swift","caption":[],"media":null,"content":[{"inlineContent":[{"type":"text","text":"Transfer the unlocked funds to the caller."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Return the amount of funds unlocked.","type":"text"}],"type":"paragraph"}],"type":"step","code":"TokenAttributesSection2Step11.swift","runtimePreview":null,"caption":[],"media":null}],"anchor":"Implementing-the-unlockFunds-Endpoint","contentSection":[{"content":[{"type":"paragraph","inlineContent":[{"text":"This section covers unlocking funds when the lock period expires. If the NFT meets the criteria, it is burned, and the funds are released.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note: To access an NFT’s attributes, the contract must temporarily own it. Directly reading attributes from an NFT held by another account is not possible."}]}],"kind":"contentAndMedia","mediaPosition":"trailing"}],"title":"Implementing the unlockFunds Endpoint"},{"contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"text":"This section covers modifying an NFT’s lock duration, a feature restricted to the contract owner.","type":"text"}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Important:"}],"type":"strong"},{"type":"text","text":" NFT attributes can only be modified for non-fungible tokens. This operation is not supported for semi-fungible tokens or meta-ESDTs."}]}],"mediaPosition":"trailing"}],"stepsSection":[{"runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Reuse the contract structure from the previous section."}]}],"caption":[],"media":null,"type":"step","code":"TokenAttributesSection3Step1.swift"},{"code":"TokenAttributesSection3Step2.swift","media":null,"runtimePreview":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"Declare the "},{"type":"codeVoice","code":"changeTokenLockDuration"},{"text":" endpoint, restricting access to the contract owner. It accepts the new lock duration as a parameter.","type":"text"}],"type":"paragraph"}],"caption":[]},{"media":null,"type":"step","content":[{"inlineContent":[{"text":"Verify that the contract has the permission to modify NFT attributes.","type":"text"}],"type":"paragraph"}],"caption":[],"code":"TokenAttributesSection3Step3.swift","runtimePreview":null},{"caption":[],"code":"TokenAttributesSection3Step4.swift","type":"step","runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"Retrieve and validate the NFT payment."}],"type":"paragraph"}],"media":null},{"code":"TokenAttributesSection3Step5.swift","media":null,"runtimePreview":null,"content":[{"inlineContent":[{"text":"Extract the attributes as a mutable variable.","type":"text"}],"type":"paragraph"}],"caption":[],"type":"step"},{"media":null,"code":"TokenAttributesSection3Step6.swift","runtimePreview":null,"caption":[],"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Update the lock duration with the new value.","type":"text"}]}]},{"code":"TokenAttributesSection3Step7.swift","type":"step","runtimePreview":null,"media":null,"content":[{"inlineContent":[{"type":"text","text":"Call "},{"type":"codeVoice","code":"Blockchain.updateNftAttributes"},{"type":"text","text":" to persist the new attributes."}],"type":"paragraph"}],"caption":[]},{"type":"step","content":[{"inlineContent":[{"type":"text","text":"Transfer the modified NFT back to the caller."}],"type":"paragraph"}],"caption":[],"runtimePreview":null,"media":null,"code":"TokenAttributesSection3Step8.swift"}],"title":"Implementing the changeTokenLockDuration Endpoint","anchor":"Implementing-the-changeTokenLockDuration-Endpoint"}]}],"references":{"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Assign-Create-AddQuantity-and-Burn-Roles","kind":"section","type":"section","role":"pseudoSymbol","title":"Assign Create, AddQuantity, and Burn Roles","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Exploring-SpaceKit's-Types":{"abstract":[],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","title":"Exploring SpaceKit's Types","type":"topic","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/exploring-spacekit's-types","kind":"article","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Test-the-Admin-Endpoints":{"type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Admin-Endpoints","role":"article","abstract":[],"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/test-the-admin-endpoints","kind":"article","title":"Test the Admin Endpoints"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Setting-Up-the-SpaceKit-CLI":{"url":"\/tutorials\/spacekit\/installingtools#Setting-Up-the-SpaceKit-CLI","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI","kind":"section","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"role":"pseudoSymbol","title":"Setting Up the SpaceKit CLI"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Test-the-Game-Logic-for-the-Flip-Contract":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/test-the-game-logic-for-the-flip-contract","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Game-Logic-for-the-Flip-Contract","kind":"article","abstract":[],"role":"article","title":"Test the Game Logic for the Flip Contract"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame#Implement-the-flip-Endpoint":{"kind":"section","abstract":[{"type":"text","text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics."}],"type":"section","url":"\/tutorials\/spacekit\/flipcontractwritethegame#Implement-the-flip-Endpoint","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-flip-Endpoint","title":"Implement the flip Endpoint"},"TokenAttributesSection2Step9.swift":{"highlights":[{"line":83},{"line":84},{"line":85},{"line":86},{"line":87},{"line":88}],"fileType":"swift","type":"file","fileName":"lib.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"syntax":"swift","identifier":"TokenAttributesSection2Step9.swift"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Writing-the-Contract-Code":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Writing-the-Contract-Code","role":"pseudoSymbol","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","type":"section","title":"Writing the Contract Code","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit":{"title":"Meet SpaceKit","abstract":[{"type":"text","text":"Discover how SpaceKit simplifies blockchain development using Swift. Dive into the world of Web3 with ease and efficiency."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","url":"\/tutorials\/spacekit","role":"overview","kind":"overview","type":"topic"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract":{"title":"Issuing a Meta ESDT from Your Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"kind":"section","role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Meta-ESDT-from-Your-Contract"},"TokenAttributesSection3Step8.swift":{"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        var attributes = self.getTokenAttributes(nonce: payment.nonce)","        attributes.lockDuration = newLockDuration","        ","        Blockchain","            .updateNftAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: payment.nonce,","                attributes: attributes","            )","        ","        Message.caller","            .send(","                tokenIdentifier: payment.tokenIdentifier,","                nonce: payment.nonce,","                amount: payment.amount","            )","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"syntax":"swift","type":"file","identifier":"TokenAttributesSection3Step8.swift","highlights":[{"line":120},{"line":121},{"line":122},{"line":123},{"line":124},{"line":125},{"line":126}],"fileType":"swift","fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint":{"abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"role":"pseudoSymbol","kind":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-changeTokenLockDuration-Endpoint","type":"section","title":"Implementing the changeTokenLockDuration Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Increase-Contract-Reserves":{"url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Increase-Contract-Reserves","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Increase-Contract-Reserves","kind":"section","abstract":[{"type":"text","text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets."}],"role":"pseudoSymbol","title":"Increase Contract Reserves"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage#Implement-Contract-Storage":{"url":"\/tutorials\/spacekit\/flipcontractwritethestorage#Implement-Contract-Storage","kind":"section","type":"section","role":"pseudoSymbol","title":"Implement Contract Storage","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Implement-Contract-Storage","abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}]},"TokenAttributesSection3Step6.swift":{"highlights":[{"line":112}],"type":"file","fileName":"lib.swift","identifier":"TokenAttributesSection3Step6.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        var attributes = self.getTokenAttributes(nonce: payment.nonce)","        attributes.lockDuration = newLockDuration","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileType":"swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Burn-Tokens":{"url":"\/tutorials\/spacekit\/operationsonfungibletokens#Burn-Tokens","kind":"section","type":"section","role":"pseudoSymbol","title":"Burn Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","abstract":[{"text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Creating-and-Understanding-Tokens":{"url":"\/tutorials\/spacekit\/create-and-manage-tokens\/creating-and-understanding-tokens","kind":"article","type":"topic","role":"article","title":"Creating and Understanding Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","abstract":[]},"TokenAttributesSection1Step6.swift":{"type":"file","highlights":[{"line":35},{"line":36},{"line":37},{"line":38},{"line":39},{"line":40}],"fileType":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","    }","}",""],"syntax":"swift","identifier":"TokenAttributesSection1Step6.swift","fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract":{"type":"section","kind":"section","url":"\/tutorials\/spacekit\/installingtools#Initializing-and-Compiling-Your-First-Smart-Contract","abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"title":"Initializing and Compiling Your First Smart Contract","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage#Define-the-Contract-Init":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Contract-Init","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/flipcontractwritethestorage#Define-the-Contract-Init","abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}],"title":"Define the Contract Init","type":"section","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractIntro":{"type":"topic","url":"\/tutorials\/spacekit\/flipcontractintro","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro","estimatedTime":"20min","role":"project","kind":"project","title":"Build a Coin Flip Smart Contract","abstract":[{"text":"In this tutorial, you’ll write and test a complete smart contract that relies on random number generation to implement a coin flip mechanic. Players wager a chosen amount of any token and face a 50% chance of doubling their bet—or losing it. A small fee is deducted from each wager and sent to the developer’s wallet.","type":"text"}]},"TokenAttributesSection1Step8.swift":{"identifier":"TokenAttributesSection1Step8.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","    }","}",""],"fileName":"lib.swift","fileType":"swift","type":"file","syntax":"swift","highlights":[{"line":52},{"line":53},{"line":54},{"line":55},{"line":56},{"line":57},{"line":58}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract":{"url":"\/tutorials\/spacekit\/flipcontractinittests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract","role":"pseudoSymbol","kind":"section","title":"Create Helper Functions to Deploy and Configure the Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract","type":"section","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}]},"TokenAttributesSection3Step3.swift":{"fileName":"lib.swift","syntax":"swift","type":"file","fileType":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"identifier":"TokenAttributesSection3Step3.swift","highlights":[{"line":98},{"line":99},{"line":100},{"line":101},{"line":102},{"line":103}]},"TokenAttributesSection1Step5.swift":{"identifier":"TokenAttributesSection1Step5.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","    }","}",""],"type":"file","fileType":"swift","fileName":"lib.swift","syntax":"swift","highlights":[{"line":29},{"line":30},{"line":31},{"line":32},{"line":33},{"line":34}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame#Define-the-bounty-Endpoint":{"abstract":[{"text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics.","type":"text"}],"kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Define-the-bounty-Endpoint","type":"section","title":"Define the bounty Endpoint","url":"\/tutorials\/spacekit\/flipcontractwritethegame#Define-the-bounty-Endpoint"},"TokenAttributesSection2Step2.swift":{"fileName":"lib.swift","syntax":"swift","type":"file","fileType":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        ","    }","}",""],"identifier":"TokenAttributesSection2Step2.swift","highlights":[{"line":62},{"line":63},{"line":64},{"line":65}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests":{"url":"\/tutorials\/spacekit\/flipcontractinittests","type":"topic","kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests","estimatedTime":"20min","abstract":[{"text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential.","type":"text"}],"title":"Set Up Testing in the SwiftVM","role":"project"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-unlockFunds-Endpoint":{"type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-unlockFunds-Endpoint","title":"Implementing the unlockFunds Endpoint","kind":"section","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools":{"title":"Install the Necessary Tools","estimatedTime":"10min","url":"\/tutorials\/spacekit\/installingtools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"role":"project","kind":"project","type":"topic"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Enhancing-Contracts-with-Token-Attributes":{"abstract":[],"role":"article","kind":"article","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/enhancing-contracts-with-token-attributes","type":"topic","title":"Enhancing Contracts with Token Attributes","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls":{"title":"Interacting with Contracts Across Shards","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"kind":"project","role":"project","estimatedTime":"15min","type":"topic","url":"\/tutorials\/spacekit\/asynccalls"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-Failure-Cases-for-the-flip-Endpoint":{"url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-Failure-Cases-for-the-flip-Endpoint","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Cases-for-the-flip-Endpoint","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"code":"GameController","type":"codeVoice"},{"text":".","type":"text"}],"kind":"section","title":"Test Failure Cases for the flip Endpoint","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Set-Maximum-Bet-Limits":{"kind":"section","abstract":[{"type":"text","text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets."}],"type":"section","url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Set-Maximum-Bet-Limits","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-Maximum-Bet-Limits","title":"Set Maximum Bet Limits"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","url":"\/tutorials\/spacekit\/storevalues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","role":"pseudoSymbol","type":"section","kind":"section","abstract":[{"text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory.","type":"text"}],"title":"Leveraging @Mapping for Dynamic Key-Value Storage"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Withdraw-Contract-Reserves":{"url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Withdraw-Contract-Reserves","role":"pseudoSymbol","kind":"section","title":"Withdraw Contract Reserves","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Withdraw-Contract-Reserves","type":"section","abstract":[{"type":"text","text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets."}]},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Testing-the-Contract":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Testing-the-Contract","role":"pseudoSymbol","kind":"section","title":"Testing the Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract","type":"section","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}]},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Fungible-Tokens":{"url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-fungible-tokens","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens","kind":"article","abstract":[],"role":"article","title":"Managing Fungible Tokens"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract","kind":"project","estimatedTime":"20min","type":"topic","role":"project","title":"Building Your First Smart Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract","abstract":[{"text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Non-Fungible-Tokens":{"url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-non-fungible-tokens","kind":"article","type":"topic","role":"article","title":"Managing Non-Fungible Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Create-Utility-Functions-for-flip-and-bounty":{"url":"\/tutorials\/spacekit\/flipcontracttestthegame#Create-Utility-Functions-for-flip-and-bounty","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Create-Utility-Functions-for-flip-and-bounty","kind":"section","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"text":".","type":"text"}],"role":"pseudoSymbol","title":"Create Utility Functions for flip and bounty"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Declare-Constants-for-the-Test-Environment":{"title":"Declare Constants for the Test Environment","role":"pseudoSymbol","kind":"section","abstract":[{"text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/flipcontractinittests#Declare-Constants-for-the-Test-Environment","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Declare-Constants-for-the-Test-Environment"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Blockchain-Context-Data":{"abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"url":"\/tutorials\/spacekit\/getinfo#Accessing-Blockchain-Context-Data","role":"pseudoSymbol","title":"Accessing Blockchain Context Data","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data"},"TokenAttributesSection2Step6.swift":{"fileName":"lib.swift","highlights":[{"line":69},{"line":70},{"line":71},{"line":72},{"line":73},{"line":74}],"identifier":"TokenAttributesSection2Step6.swift","fileType":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"type":"file","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Building-Your-First-Smart-Contract":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","title":"Building Your First Smart Contract","kind":"article","url":"\/tutorials\/spacekit\/getting-started\/building-your-first-smart-contract","abstract":[],"type":"topic","role":"article"},"TokenAttributesSection1Step2.swift":{"identifier":"TokenAttributesSection1Step2.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","}",""],"fileName":"lib.swift","highlights":[{"line":3},{"line":4},{"line":5},{"line":6},{"line":7},{"line":8},{"line":23}],"fileType":"swift","type":"file","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","url":"\/tutorials\/spacekit\/tokenattributes","role":"project","type":"topic","kind":"project","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"estimatedTime":"15min","title":"Enhance Your Contracts with Token Attributes"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Build-a-Coin-Flip-Smart-Contract":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/build-a-coin-flip-smart-contract","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Build-a-Coin-Flip-Smart-Contract","kind":"article","abstract":[],"role":"article","title":"Build a Coin Flip Smart Contract"},"TokenAttributesSection3Step1.swift":{"identifier":"TokenAttributesSection3Step1.swift","syntax":"swift","highlights":[],"type":"file","fileType":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Transaction-Context-Data":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/getinfo#Accessing-Transaction-Context-Data","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"title":"Accessing Transaction Context Data","type":"section","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Define-the-Storage-for-the-Flip-Contract":{"title":"Define the Storage for the Flip Contract","role":"article","kind":"article","abstract":[],"type":"topic","url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/define-the-storage-for-the-flip-contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Define-the-Storage-for-the-Flip-Contract"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-Successful-Calls-to-the-flip-Endpoint":{"title":"Test Successful Calls to the flip Endpoint","role":"pseudoSymbol","kind":"section","abstract":[{"text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the ","type":"text"},{"type":"codeVoice","code":"GameController"},{"type":"text","text":"."}],"type":"section","url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-Successful-Calls-to-the-flip-Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Successful-Calls-to-the-flip-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-BigUint-Type":{"url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-BigUint-Type","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","kind":"section","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"role":"pseudoSymbol","title":"Working with the BigUint Type"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues":{"abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"role":"project","estimatedTime":"15min","kind":"project","url":"\/tutorials\/spacekit\/storevalues","type":"topic","title":"Persist Values Between Executions","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Declare-the-Callee-Proxy":{"type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","url":"\/tutorials\/spacekit\/synccalls#Declare-the-Callee-Proxy","title":"Declare the Callee Proxy","kind":"section","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}],"role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens":{"url":"\/tutorials\/spacekit\/understandtokens","estimatedTime":"15min","role":"project","kind":"project","title":"Understand the ESDT Standard","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens","type":"topic","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}]},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract":{"title":"Issuing a Non-Fungible Token from Your Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","type":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"kind":"section","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Non-Fungible-Token-from-Your-Contract"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin":{"estimatedTime":"20min","url":"\/tutorials\/spacekit\/flipcontractwriteadmin","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin","type":"topic","kind":"project","title":"Add Administrative Endpoints to the Flip Contract","role":"project","abstract":[{"text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens":{"type":"topic","estimatedTime":"15min","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","role":"project","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"url":"\/tutorials\/spacekit\/operationsonfungibletokens","kind":"project","title":"Managing Fungible Tokens"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens":{"estimatedTime":"15min","type":"topic","title":"Managing Non-Fungible Tokens","role":"project","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Test-the-withdrawReserve-Endpoint":{"type":"section","kind":"section","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}],"title":"Test the withdrawReserve Endpoint","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/flipcontracttestadmin#Test-the-withdrawReserve-Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-withdrawReserve-Endpoint"},"TokenAttributesSection2Step8.swift":{"fileName":"lib.swift","identifier":"TokenAttributesSection2Step8.swift","fileType":"swift","highlights":[{"line":77},{"line":78},{"line":79},{"line":80},{"line":81},{"line":82}],"type":"file","syntax":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Test-the-increaseReserve-Endpoint":{"kind":"section","abstract":[{"text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/flipcontracttestadmin#Test-the-increaseReserve-Endpoint","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-increaseReserve-Endpoint","title":"Test the increaseReserve Endpoint"},"TokenAttributesSection2Step3.swift":{"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileName":"lib.swift","syntax":"swift","fileType":"swift","type":"file","identifier":"TokenAttributesSection2Step3.swift","highlights":[{"line":64},{"line":65},{"line":66},{"line":67},{"line":68}]},"TokenAttributesSection1Step1.swift":{"fileName":"lib.swift","identifier":"TokenAttributesSection1Step1.swift","fileType":"swift","highlights":[],"type":"file","syntax":"swift","content":["import SpaceKit","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","}"]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame","estimatedTime":"20min","abstract":[{"type":"text","text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics."}],"role":"project","title":"Implement the Game Logic for the Flip Contract","kind":"project","url":"\/tutorials\/spacekit\/flipcontractwritethegame","type":"topic"},"TokenAttributesSection3Step5.swift":{"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        var attributes = self.getTokenAttributes(nonce: payment.nonce)","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileName":"lib.swift","syntax":"swift","fileType":"swift","type":"file","identifier":"TokenAttributesSection3Step5.swift","highlights":[{"line":110},{"line":111}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage":{"title":"Define the Storage for the Flip Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage","abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}],"kind":"project","role":"project","estimatedTime":"20min","type":"topic","url":"\/tutorials\/spacekit\/flipcontractwritethestorage"},"TokenAttributesSection3Step7.swift":{"fileName":"lib.swift","identifier":"TokenAttributesSection3Step7.swift","fileType":"swift","highlights":[{"line":113},{"line":114},{"line":115},{"line":116},{"line":117},{"line":118},{"line":119}],"type":"file","syntax":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        var attributes = self.getTokenAttributes(nonce: payment.nonce)","        attributes.lockDuration = newLockDuration","        ","        Blockchain","            .updateNftAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: payment.nonce,","                attributes: attributes","            )","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce":{"title":"Add Quantity to an Existing Nonce","role":"pseudoSymbol","kind":"section","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Add-Quantity-to-an-Existing-Nonce","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Installing-the-Tools":{"abstract":[],"role":"article","kind":"article","url":"\/tutorials\/spacekit\/getting-started\/installing-the-tools","type":"topic","title":"Installing the Tools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Burn-Tokens":{"title":"Burn Tokens","role":"pseudoSymbol","kind":"section","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Burn-Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Calling-Contracts-Across-Shards":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","title":"Calling Contracts Across Shards","kind":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/calling-contracts-across-shards","abstract":[],"type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-lockFunds-Endpoint":{"url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-lockFunds-Endpoint","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint","kind":"section","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"role":"pseudoSymbol","title":"Implementing the lockFunds Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-Vector-Type":{"url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-Vector-Type","type":"section","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"title":"Working with the Vector Type","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Write-Tests-for-the-Setup-Helpers":{"type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Write-Tests-for-the-Setup-Helpers","role":"pseudoSymbol","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}],"url":"\/tutorials\/spacekit\/flipcontractinittests#Write-Tests-for-the-Setup-Helpers","kind":"section","title":"Write Tests for the Setup Helpers"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints":{"url":"\/tutorials\/spacekit\/flipcontracttestadmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints","kind":"section","type":"section","role":"pseudoSymbol","title":"Verify That Only the Owner Can Access Admin Endpoints","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges":{"title":"Handling Heap Allocation Challenges","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"kind":"section","role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Handling-Heap-Allocation-Challenges"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Set-Up-Testing-in-the-SwiftVM":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/set-up-testing-in-the-swiftvm","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Set-Up-Testing-in-the-SwiftVM","kind":"article","abstract":[],"role":"article","title":"Set Up Testing in the SwiftVM"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractIntro#Set-Up-the-Project":{"url":"\/tutorials\/spacekit\/flipcontractintro#Set-Up-the-Project","kind":"section","type":"section","role":"pseudoSymbol","title":"Set Up the Project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro#Set-Up-the-Project","abstract":[{"type":"text","text":"In this tutorial, you’ll write and test a complete smart contract that relies on random number generation to implement a coin flip mechanic. Players wager a chosen amount of any token and face a 50% chance of doubling their bet—or losing it. A small fee is deducted from each wager and sent to the developer’s wallet."}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Mint-New-Tokens":{"url":"\/tutorials\/spacekit\/operationsonfungibletokens#Mint-New-Tokens","role":"pseudoSymbol","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","type":"section","title":"Mint New Tokens","kind":"section"},"TokenAttributesSection1Step7.swift":{"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","    }","}",""],"fileName":"lib.swift","syntax":"swift","fileType":"swift","type":"file","identifier":"TokenAttributesSection1Step7.swift","highlights":[{"line":41},{"line":42},{"line":43},{"line":44},{"line":45},{"line":46},{"line":47},{"line":48},{"line":49},{"line":50},{"line":51}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage#Define-the-Flip-Structure":{"abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}],"url":"\/tutorials\/spacekit\/flipcontractwritethestorage#Define-the-Flip-Structure","role":"pseudoSymbol","title":"Define the Flip Structure","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Flip-Structure"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Interacting-with-Other-Contracts":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","title":"Interacting with Other Contracts","kind":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/interacting-with-other-contracts","abstract":[],"type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes":{"type":"topic","url":"\/tutorials\/spacekit\/familiarizewithtypes","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes","estimatedTime":"20min","role":"project","kind":"project","title":"Exploring SpaceKit's Types","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract":{"title":"Issuing a Semi-Fungible Token from Your Contract","type":"section","role":"pseudoSymbol","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"text":" ","type":"text"},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Retrieving-Information-from-the-Blockchain":{"type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","role":"article","abstract":[],"url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/retrieving-information-from-the-blockchain","kind":"article","title":"Retrieving Information from the Blockchain"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin":{"title":"Test the Admin Endpoints","type":"topic","role":"project","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}],"kind":"project","estimatedTime":"20min","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin","url":"\/tutorials\/spacekit\/flipcontracttestadmin"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls":{"title":"Interact with Other Contracts","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls","abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}],"kind":"project","role":"project","estimatedTime":"15min","type":"topic","url":"\/tutorials\/spacekit\/synccalls"},"TokenAttributesSection2Step10.swift":{"fileName":"lib.swift","identifier":"TokenAttributesSection2Step10.swift","fileType":"swift","highlights":[{"line":89},{"line":90},{"line":91}],"type":"file","syntax":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Verify-the-Maximum-Bet-Configuration-Endpoints":{"url":"\/tutorials\/spacekit\/flipcontracttestadmin#Verify-the-Maximum-Bet-Configuration-Endpoints","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-the-Maximum-Bet-Configuration-Endpoints","kind":"section","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}],"role":"pseudoSymbol","title":"Verify the Maximum Bet Configuration Endpoints"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Declare-the-Callee-Proxy":{"url":"\/tutorials\/spacekit\/asynccalls#Declare-the-Callee-Proxy","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"title":"Declare the Callee Proxy","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Perform-a-Synchronous-Call":{"kind":"section","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/synccalls#Perform-a-Synchronous-Call","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","title":"Perform a Synchronous Call"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Configure-the-Initial-Blockchain-State":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Configure-the-Initial-Blockchain-State","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/flipcontractinittests#Configure-the-Initial-Blockchain-State","type":"section","title":"Configure the Initial Blockchain State","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}],"kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Create-a-New-Nonce":{"abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"role":"pseudoSymbol","kind":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Create-a-New-Nonce","type":"section","title":"Create a New Nonce","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-Failure-Case-for-the-bounty-Endpoint":{"url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-Failure-Case-for-the-bounty-Endpoint","role":"pseudoSymbol","kind":"section","title":"Test Failure Case for the bounty Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Case-for-the-bounty-Endpoint","type":"section","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"text":".","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame","title":"Test the Game Logic for the Flip Contract","kind":"project","estimatedTime":"20min","url":"\/tutorials\/spacekit\/flipcontracttestthegame","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"type":"text","text":"."}],"type":"topic","role":"project"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Implement-the-Game-Logic-for-the-Flip-Contract":{"title":"Implement the Game Logic for the Flip Contract","role":"article","kind":"article","abstract":[],"type":"topic","url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/implement-the-game-logic-for-the-flip-contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Implement-the-Game-Logic-for-the-Flip-Contract"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame#Implement-the-makeFlip-Function":{"url":"\/tutorials\/spacekit\/flipcontractwritethegame#Implement-the-makeFlip-Function","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-makeFlip-Function","kind":"section","abstract":[{"type":"text","text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics."}],"role":"pseudoSymbol","title":"Implement the makeFlip Function"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract":{"url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Fungible-Token-from-Your-Contract","role":"pseudoSymbol","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","type":"section","title":"Issuing a Fungible Token from Your Contract","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Initializing-the-Project":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Initializing-the-Project","role":"pseudoSymbol","kind":"section","title":"Initializing the Project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","type":"section","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-the-bounty-Endpoint":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-the-bounty-Endpoint","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"text":".","type":"text"}],"role":"pseudoSymbol","title":"Test the bounty Endpoint","kind":"section","url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-the-bounty-Endpoint","type":"section"},"TokenAttributesSection1Step4.swift":{"fileType":"swift","identifier":"TokenAttributesSection1Step4.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","    }","}",""],"type":"file","highlights":[{"line":24},{"line":26},{"line":27},{"line":28}],"syntax":"swift","fileName":"lib.swift"},"TokenAttributesSection2Step5.swift":{"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"identifier":"TokenAttributesSection2Step5.swift","fileName":"lib.swift","syntax":"swift","highlights":[{"line":64},{"line":66},{"line":67},{"line":68}],"fileType":"swift","type":"file"},"TokenAttributesSection3Step2.swift":{"identifier":"TokenAttributesSection3Step2.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"syntax":"swift","fileName":"lib.swift","fileType":"swift","highlights":[{"line":96},{"line":97},{"line":98},{"line":99}],"type":"file"},"TokenAttributesSection1Step9.swift":{"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","}",""],"fileName":"lib.swift","syntax":"swift","fileType":"swift","type":"file","identifier":"TokenAttributesSection1Step9.swift","highlights":[{"line":59},{"line":60}]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Creating-Your-Own-Types":{"title":"Creating Your Own Types","role":"pseudoSymbol","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"kind":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Creating-Your-Own-Types","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","role":"project","url":"\/tutorials\/spacekit\/getinfo","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"title":"Retrieving Information from the Blockchain","type":"topic","estimatedTime":"10min","kind":"project"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Working-with-Storage-for-Single-Value-Persistence":{"title":"Working with @Storage for Single Value Persistence","role":"pseudoSymbol","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"kind":"section","url":"\/tutorials\/spacekit\/storevalues#Working-with-Storage-for-Single-Value-Persistence","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Persisting-Data-Across-Executions":{"title":"Persisting Data Across Executions","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","type":"topic","abstract":[],"kind":"article","role":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/persisting-data-across-executions"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Perform-an-Asynchronous-Call":{"url":"\/tutorials\/spacekit\/asynccalls#Perform-an-Asynchronous-Call","kind":"section","type":"section","role":"pseudoSymbol","title":"Perform an Asynchronous Call","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles":{"abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Assign-Mint-and-Burn-Roles","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","kind":"section","type":"section","title":"Assign Mint and Burn Roles"},"TokenAttributesSection2Step11.swift":{"identifier":"TokenAttributesSection2Step11.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"syntax":"swift","fileName":"lib.swift","fileType":"swift","highlights":[{"line":92},{"line":93}],"type":"file"},"TokenAttributesSection2Step7.swift":{"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileName":"lib.swift","syntax":"swift","fileType":"swift","type":"file","identifier":"TokenAttributesSection2Step7.swift","highlights":[{"line":75},{"line":76}]},"TokenAttributesSection2Step4.swift":{"identifier":"TokenAttributesSection2Step4.swift","syntax":"swift","highlights":[{"line":63},{"line":64},{"line":65},{"line":66}],"type":"file","fileType":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        ","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Set-the-Minimum-Block-Bounty-Delay":{"url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Set-the-Minimum-Block-Bounty-Delay","role":"pseudoSymbol","kind":"section","title":"Set the Minimum Block Bounty Delay","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-the-Minimum-Block-Bounty-Delay","type":"section","abstract":[{"text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Understanding-the-Buffer-Type":{"title":"Understanding the Buffer Type","role":"pseudoSymbol","kind":"section","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Understanding-the-Buffer-Type","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Set-Up-the-Test-Project":{"title":"Set Up the Test Project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Set-Up-the-Test-Project","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}],"url":"\/tutorials\/spacekit\/flipcontractinittests#Set-Up-the-Test-Project","type":"section","kind":"section","role":"pseudoSymbol"},"TokenAttributesSection1Step3.swift":{"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        ","    }","}",""],"fileName":"lib.swift","syntax":"swift","fileType":"swift","type":"file","identifier":"TokenAttributesSection1Step3.swift","highlights":[{"line":22},{"line":23},{"line":24},{"line":25}]},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Installing-SpaceKits-Dependencies":{"url":"\/tutorials\/spacekit\/installingtools#Installing-SpaceKits-Dependencies","role":"pseudoSymbol","kind":"section","title":"Installing SpaceKit's Dependencies","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","type":"section","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}]},"TokenAttributesSection2Step1.swift":{"identifier":"TokenAttributesSection2Step1.swift","syntax":"swift","highlights":[],"type":"file","fileType":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","}",""],"fileName":"lib.swift"},"TokenAttributesSection3Step4.swift":{"syntax":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileName":"lib.swift","highlights":[{"line":104},{"line":105},{"line":106},{"line":107},{"line":108},{"line":109}],"fileType":"swift","identifier":"TokenAttributesSection3Step4.swift","type":"file"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Add-Administrative-Endpoints-to-the-Flip-Contract":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/add-administrative-endpoints-to-the-flip-contract","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Add-Administrative-Endpoints-to-the-Flip-Contract","kind":"article","abstract":[],"role":"article","title":"Add Administrative Endpoints to the Flip Contract"}}}
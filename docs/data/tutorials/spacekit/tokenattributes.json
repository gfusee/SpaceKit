{"sections":[{"chapter":"Enhancing Contracts with Token Attributes","kind":"hero","content":[{"type":"paragraph","inlineContent":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this tutorial, you’ll explore a practical use case for this feature by building a smart contract that locks funds inside an NFT for a specified duration. The NFT can be transferred freely, and once the lock period expires, the holder can reclaim the locked funds."}]},{"type":"paragraph","inlineContent":[{"text":"You’ll implement the following contract endpoints:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"code":"lockFunds","type":"codeVoice"},{"type":"text","text":": Accepts a single payment, locks the funds, mints an NFT with attributes, and transfers it to the caller. "},{"type":"strong","inlineContent":[{"type":"text","text":"Concept covered:"}]},{"text":" Creating a token with custom attributes.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"unlockFunds","type":"codeVoice"},{"type":"text","text":": Accepts an NFT payment, verifies the attributes to determine if the funds can be unlocked, and if so, burns the NFT and releases the locked funds. Fails otherwise. "},{"type":"strong","inlineContent":[{"text":"Concept covered:","type":"text"}]},{"type":"text","text":" Reading token attributes."}]}]},{"content":[{"inlineContent":[{"code":"changeTokenLockDuration","type":"codeVoice"},{"type":"text","text":": Restricted to the contract owner, this endpoint accepts an NFT payment, updates the lock duration, and returns the modified NFT to the caller. "},{"inlineContent":[{"text":"Concept covered:","type":"text"}],"type":"strong"},{"text":" Modifying NFT attributes.","type":"text"}],"type":"paragraph"}]}]}],"title":"Enhance Your Contracts with Token Attributes","estimatedTimeInMinutes":15},{"kind":"tasks","tasks":[{"title":"Implementing the lockFunds Endpoint","anchor":"Implementing-the-lockFunds-Endpoint","contentSection":[{"mediaPosition":"trailing","kind":"contentAndMedia","content":[{"inlineContent":[{"text":"In this section, you’ll create an NFT representing the locked funds sent by the caller. You’ll learn how to embed custom attributes in an NFT.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Before proceeding, ensure that the non-fungible collection is already issued and that the contract possesses the required roles (refer to previous chapters).","type":"text"}],"type":"paragraph"}]}],"stepsSection":[{"type":"step","code":"TokenAttributesSection1Step1.swift","runtimePreview":null,"media":null,"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The contract stores the NFT token identifier and the lock duration, both specified by the owner during deployment."}]}],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define the contract structure."}]}]},{"runtimePreview":null,"type":"step","caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use any SpaceKit types, as well as structs annotated with "},{"type":"codeVoice","code":"@Codable"},{"type":"text","text":"."}]}],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define the attributes structure."}]}],"media":null,"code":"TokenAttributesSection1Step2.swift"},{"type":"step","content":[{"inlineContent":[{"text":"Implement the ","type":"text"},{"type":"codeVoice","code":"lockFunds"},{"text":" endpoint, which returns the nonce of the minted NFT.","type":"text"}],"type":"paragraph"}],"media":null,"code":"TokenAttributesSection1Step3.swift","runtimePreview":null,"caption":[]},{"media":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Ensure the contract has permission to create NFTs."}]}],"code":"TokenAttributesSection1Step4.swift","type":"step","caption":[],"runtimePreview":null},{"caption":[],"media":null,"code":"TokenAttributesSection1Step5.swift","runtimePreview":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"Retrieve and validate the payment to be locked, ensuring it’s greater than zero."}],"type":"paragraph"}]},{"caption":[],"media":null,"code":"TokenAttributesSection1Step6.swift","runtimePreview":null,"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Construct the attributes to be embedded in the NFT."}]}]},{"caption":[],"code":"TokenAttributesSection1Step7.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Mint the NFT and assign the attributes."}]}],"type":"step","runtimePreview":null,"media":null},{"type":"step","runtimePreview":null,"caption":[],"media":null,"content":[{"inlineContent":[{"text":"Transfer the created NFT to the caller.","type":"text"}],"type":"paragraph"}],"code":"TokenAttributesSection1Step8.swift"},{"runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"Return the created nonce."}],"type":"paragraph"}],"caption":[],"type":"step","media":null,"code":"TokenAttributesSection1Step9.swift"}]},{"title":"Implementing the unlockFunds Endpoint","stepsSection":[{"type":"step","caption":[],"content":[{"type":"paragraph","inlineContent":[{"text":"Reuse the contract structure from the previous section.","type":"text"}]}],"media":null,"code":"TokenAttributesSection2Step1.swift","runtimePreview":null},{"type":"step","runtimePreview":null,"caption":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Note:"}]},{"text":" This function is not an endpoint and remains private.","type":"text"}],"type":"paragraph"}],"media":null,"code":"TokenAttributesSection2Step2.swift","content":[{"inlineContent":[{"type":"text","text":"Implement a helper function to retrieve NFT attributes."}],"type":"paragraph"}]},{"caption":[],"media":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Use ","type":"text"},{"code":"Blockchain.getTokenAttributes","type":"codeVoice"},{"type":"text","text":" to retrieve attributes."}]}],"code":"TokenAttributesSection2Step3.swift","type":"step","runtimePreview":null},{"runtimePreview":null,"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Declare the "},{"type":"codeVoice","code":"unlockFunds"},{"type":"text","text":" endpoint, returning the unlocked amount."}]}],"caption":[],"code":"TokenAttributesSection2Step4.swift","media":null},{"caption":[],"code":"TokenAttributesSection2Step5.swift","type":"step","media":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Verify that the contract has permission to burn tokens."}]}],"runtimePreview":null},{"media":null,"runtimePreview":null,"type":"step","code":"TokenAttributesSection2Step6.swift","caption":[],"content":[{"inlineContent":[{"type":"text","text":"Retrieve the NFT payment and validate its token identifier."}],"type":"paragraph"}]},{"media":null,"code":"TokenAttributesSection2Step7.swift","runtimePreview":null,"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Extract the attributes using the helper function.","type":"text"}]}],"caption":[]},{"type":"step","media":null,"runtimePreview":null,"code":"TokenAttributesSection2Step8.swift","caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Determine whether funds can be unlocked based on attributes."}]}]},{"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Burn the NFT if conditions are met.","type":"text"}]}],"media":null,"code":"TokenAttributesSection2Step9.swift","caption":[],"runtimePreview":null},{"caption":[],"runtimePreview":null,"media":null,"code":"TokenAttributesSection2Step10.swift","type":"step","content":[{"inlineContent":[{"type":"text","text":"Transfer the unlocked funds to the caller."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Return the amount of funds unlocked."}]}],"type":"step","caption":[],"media":null,"code":"TokenAttributesSection2Step11.swift","runtimePreview":null}],"contentSection":[{"mediaPosition":"trailing","kind":"contentAndMedia","content":[{"inlineContent":[{"text":"This section covers unlocking funds when the lock period expires. If the NFT meets the criteria, it is burned, and the funds are released.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Note: To access an NFT’s attributes, the contract must temporarily own it. Directly reading attributes from an NFT held by another account is not possible.","type":"text"}],"type":"paragraph"}]}],"anchor":"Implementing-the-unlockFunds-Endpoint"},{"title":"Implementing the changeTokenLockDuration Endpoint","anchor":"Implementing-the-changeTokenLockDuration-Endpoint","contentSection":[{"kind":"contentAndMedia","mediaPosition":"trailing","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This section covers modifying an NFT’s lock duration, a feature restricted to the contract owner."}]},{"inlineContent":[{"inlineContent":[{"text":"Important:","type":"text"}],"type":"strong"},{"type":"text","text":" NFT attributes can only be modified for non-fungible tokens. This operation is not supported for semi-fungible tokens or meta-ESDTs."}],"type":"paragraph"}]}],"stepsSection":[{"media":null,"code":"TokenAttributesSection3Step1.swift","runtimePreview":null,"caption":[],"content":[{"inlineContent":[{"type":"text","text":"Reuse the contract structure from the previous section."}],"type":"paragraph"}],"type":"step"},{"media":null,"code":"TokenAttributesSection3Step2.swift","content":[{"type":"paragraph","inlineContent":[{"text":"Declare the ","type":"text"},{"type":"codeVoice","code":"changeTokenLockDuration"},{"text":" endpoint, restricting access to the contract owner. It accepts the new lock duration as a parameter.","type":"text"}]}],"runtimePreview":null,"type":"step","caption":[]},{"type":"step","caption":[],"media":null,"runtimePreview":null,"code":"TokenAttributesSection3Step3.swift","content":[{"inlineContent":[{"type":"text","text":"Verify that the contract has the permission to modify NFT attributes."}],"type":"paragraph"}]},{"type":"step","runtimePreview":null,"caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Retrieve and validate the NFT payment."}]}],"code":"TokenAttributesSection3Step4.swift","media":null},{"code":"TokenAttributesSection3Step5.swift","caption":[],"type":"step","media":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Extract the attributes as a mutable variable."}]}],"runtimePreview":null},{"media":null,"type":"step","content":[{"inlineContent":[{"text":"Update the lock duration with the new value.","type":"text"}],"type":"paragraph"}],"code":"TokenAttributesSection3Step6.swift","runtimePreview":null,"caption":[]},{"media":null,"code":"TokenAttributesSection3Step7.swift","type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Call ","type":"text"},{"type":"codeVoice","code":"Blockchain.updateNftAttributes"},{"text":" to persist the new attributes.","type":"text"}]}],"runtimePreview":null,"caption":[]},{"code":"TokenAttributesSection3Step8.swift","caption":[],"runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Transfer the modified NFT back to the caller.","type":"text"}]}],"type":"step","media":null}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"kind":"project","metadata":{"role":"project","title":"Enhance Your Contracts with Token Attributes","category":"SpaceKit","categoryPathComponent":"SpaceKit"},"variants":[{"paths":["\/tutorials\/spacekit\/tokenattributes"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes"},"hierarchy":{"modules":[{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract"}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types"},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes"}],"paths":[["doc:\/\/SpaceKit\/tutorials\/SpaceKit","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes"]],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit"},"references":{"TokenAttributesSection3Step4.swift":{"type":"file","fileName":"lib.swift","highlights":[{"line":104},{"line":105},{"line":106},{"line":107},{"line":108},{"line":109}],"identifier":"TokenAttributesSection3Step4.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"syntax":"swift","fileType":"swift"},"TokenAttributesSection3Step7.swift":{"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        var attributes = self.getTokenAttributes(nonce: payment.nonce)","        attributes.lockDuration = newLockDuration","        ","        Blockchain","            .updateNftAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: payment.nonce,","                attributes: attributes","            )","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"type":"file","fileType":"swift","fileName":"lib.swift","highlights":[{"line":113},{"line":114},{"line":115},{"line":116},{"line":117},{"line":118},{"line":119}],"syntax":"swift","identifier":"TokenAttributesSection3Step7.swift"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Retrieving-Information-from-the-Blockchain":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","title":"Retrieving Information from the Blockchain","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/retrieving-information-from-the-blockchain","abstract":[],"role":"article","kind":"article","type":"topic"},"doc://SpaceKit/tutorials/SpaceKit":{"abstract":[{"text":"Discover how SpaceKit simplifies blockchain development using Swift. Dive into the world of Web3 with ease and efficiency.","type":"text"}],"role":"overview","type":"topic","kind":"overview","title":"Meet SpaceKit","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","url":"\/tutorials\/spacekit"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Create-a-New-Nonce":{"kind":"section","title":"Create a New Nonce","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Create-a-New-Nonce","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"role":"pseudoSymbol","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract":{"abstract":[{"text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions.","type":"text"}],"role":"project","kind":"project","url":"\/tutorials\/spacekit\/codingyourfirstcontract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract","title":"Building Your First Smart Contract","type":"topic","estimatedTime":"20min"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues":{"abstract":[{"text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory.","type":"text"}],"role":"project","kind":"project","url":"\/tutorials\/spacekit\/storevalues","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues","title":"Persist Values Between Executions","type":"topic","estimatedTime":"15min"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-unlockFunds-Endpoint":{"title":"Implementing the unlockFunds Endpoint","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-unlockFunds-Endpoint","role":"pseudoSymbol","type":"section","kind":"section","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage":{"kind":"section","title":"Leveraging @Mapping for Dynamic Key-Value Storage","type":"section","url":"\/tutorials\/spacekit\/storevalues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}]},"TokenAttributesSection1Step9.swift":{"type":"file","fileName":"lib.swift","highlights":[{"line":59},{"line":60}],"identifier":"TokenAttributesSection1Step9.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","}",""],"syntax":"swift","fileType":"swift"},"TokenAttributesSection1Step5.swift":{"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","    }","}",""],"type":"file","fileType":"swift","fileName":"lib.swift","highlights":[{"line":29},{"line":30},{"line":31},{"line":32},{"line":33},{"line":34}],"syntax":"swift","identifier":"TokenAttributesSection1Step5.swift"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls":{"url":"\/tutorials\/spacekit\/synccalls","role":"project","title":"Interact with Other Contracts","estimatedTime":"15min","type":"topic","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}],"kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls"},"TokenAttributesSection3Step6.swift":{"syntax":"swift","fileType":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        var attributes = self.getTokenAttributes(nonce: payment.nonce)","        attributes.lockDuration = newLockDuration","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileName":"lib.swift","identifier":"TokenAttributesSection3Step6.swift","type":"file","highlights":[{"line":112}]},"TokenAttributesSection2Step8.swift":{"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"type":"file","fileType":"swift","fileName":"lib.swift","highlights":[{"line":77},{"line":78},{"line":79},{"line":80},{"line":81},{"line":82}],"syntax":"swift","identifier":"TokenAttributesSection2Step8.swift"},"TokenAttributesSection2Step7.swift":{"syntax":"swift","fileType":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileName":"lib.swift","identifier":"TokenAttributesSection2Step7.swift","type":"file","highlights":[{"line":75},{"line":76}]},"TokenAttributesSection2Step6.swift":{"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"type":"file","fileType":"swift","fileName":"lib.swift","highlights":[{"line":69},{"line":70},{"line":71},{"line":72},{"line":73},{"line":74}],"syntax":"swift","identifier":"TokenAttributesSection2Step6.swift"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Exploring-SpaceKit's-Types":{"kind":"article","title":"Exploring SpaceKit's Types","type":"topic","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/exploring-spacekit's-types","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","abstract":[]},"TokenAttributesSection2Step9.swift":{"syntax":"swift","fileType":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileName":"lib.swift","identifier":"TokenAttributesSection2Step9.swift","type":"file","highlights":[{"line":83},{"line":84},{"line":85},{"line":86},{"line":87},{"line":88}]},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Perform-an-Asynchronous-Call":{"url":"\/tutorials\/spacekit\/asynccalls#Perform-an-Asynchronous-Call","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"type":"section","title":"Perform an Asynchronous Call"},"TokenAttributesSection1Step3.swift":{"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        ","    }","}",""],"type":"file","fileType":"swift","fileName":"lib.swift","highlights":[{"line":22},{"line":23},{"line":24},{"line":25}],"syntax":"swift","identifier":"TokenAttributesSection1Step3.swift"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract":{"abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","type":"section","title":"Issuing a Non-Fungible Token from Your Contract","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","role":"pseudoSymbol","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Fungible-Tokens":{"kind":"article","title":"Managing Fungible Tokens","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-fungible-tokens","abstract":[],"role":"article","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens"},"TokenAttributesSection3Step8.swift":{"highlights":[{"line":120},{"line":121},{"line":122},{"line":123},{"line":124},{"line":125},{"line":126}],"fileName":"lib.swift","identifier":"TokenAttributesSection3Step8.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        var attributes = self.getTokenAttributes(nonce: payment.nonce)","        attributes.lockDuration = newLockDuration","        ","        Blockchain","            .updateNftAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: payment.nonce,","                attributes: attributes","            )","        ","        Message.caller","            .send(","                tokenIdentifier: payment.tokenIdentifier,","                nonce: payment.nonce,","                amount: payment.amount","            )","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"type":"file","fileType":"swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Blockchain-Context-Data":{"kind":"section","title":"Accessing Blockchain Context Data","type":"section","url":"\/tutorials\/spacekit\/getinfo#Accessing-Blockchain-Context-Data","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}]},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Installing-the-Tools":{"kind":"article","title":"Installing the Tools","type":"topic","url":"\/tutorials\/spacekit\/getting-started\/installing-the-tools","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools","abstract":[]},"TokenAttributesSection3Step3.swift":{"syntax":"swift","identifier":"TokenAttributesSection3Step3.swift","highlights":[{"line":98},{"line":99},{"line":100},{"line":101},{"line":102},{"line":103}],"fileType":"swift","type":"file","fileName":"lib.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""]},"TokenAttributesSection1Step7.swift":{"highlights":[{"line":41},{"line":42},{"line":43},{"line":44},{"line":45},{"line":46},{"line":47},{"line":48},{"line":49},{"line":50},{"line":51}],"type":"file","fileName":"lib.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","    }","}",""],"identifier":"TokenAttributesSection1Step7.swift","fileType":"swift","syntax":"swift"},"TokenAttributesSection1Step4.swift":{"syntax":"swift","highlights":[{"line":24},{"line":26},{"line":27},{"line":28}],"fileName":"lib.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","    }","}",""],"fileType":"swift","type":"file","identifier":"TokenAttributesSection1Step4.swift"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Transaction-Context-Data":{"kind":"section","title":"Accessing Transaction Context Data","type":"section","url":"\/tutorials\/spacekit\/getinfo#Accessing-Transaction-Context-Data","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}]},"TokenAttributesSection3Step1.swift":{"highlights":[],"type":"file","identifier":"TokenAttributesSection3Step1.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileName":"lib.swift","fileType":"swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","url":"\/tutorials\/spacekit\/operationsonfungibletokens","estimatedTime":"15min","role":"project","type":"topic","abstract":[{"text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with.","type":"text"}],"title":"Managing Fungible Tokens","kind":"project"},"TokenAttributesSection2Step4.swift":{"syntax":"swift","highlights":[{"line":63},{"line":64},{"line":65},{"line":66}],"fileName":"lib.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        ","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileType":"swift","type":"file","identifier":"TokenAttributesSection2Step4.swift"},"TokenAttributesSection2Step3.swift":{"highlights":[{"line":64},{"line":65},{"line":66},{"line":67},{"line":68}],"type":"file","identifier":"TokenAttributesSection2Step3.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileName":"lib.swift","fileType":"swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo":{"url":"\/tutorials\/spacekit\/getinfo","role":"project","title":"Retrieving Information from the Blockchain","estimatedTime":"10min","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"type":"topic","kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-BigUint-Type":{"abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","type":"section","title":"Working with the BigUint Type","url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-BigUint-Type","role":"pseudoSymbol","kind":"section"},"TokenAttributesSection2Step11.swift":{"syntax":"swift","highlights":[{"line":92},{"line":93}],"fileName":"lib.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileType":"swift","type":"file","identifier":"TokenAttributesSection2Step11.swift"},"TokenAttributesSection1Step6.swift":{"highlights":[{"line":35},{"line":36},{"line":37},{"line":38},{"line":39},{"line":40}],"type":"file","identifier":"TokenAttributesSection1Step6.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","    }","}",""],"fileName":"lib.swift","fileType":"swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract":{"kind":"section","title":"Initializing and Compiling Your First Smart Contract","type":"section","url":"\/tutorials\/spacekit\/installingtools#Initializing-and-Compiling-Your-First-Smart-Contract","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}]},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Testing-the-Contract":{"abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract","type":"section","title":"Testing the Contract","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Testing-the-Contract","role":"pseudoSymbol","kind":"section"},"TokenAttributesSection1Step2.swift":{"fileType":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","}",""],"fileName":"lib.swift","type":"file","highlights":[{"line":3},{"line":4},{"line":5},{"line":6},{"line":7},{"line":8},{"line":23}],"identifier":"TokenAttributesSection1Step2.swift","syntax":"swift"},"TokenAttributesSection2Step1.swift":{"type":"file","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","}",""],"identifier":"TokenAttributesSection2Step1.swift","highlights":[],"syntax":"swift","fileType":"swift","fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Building-Your-First-Smart-Contract":{"role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","type":"topic","abstract":[],"kind":"article","url":"\/tutorials\/spacekit\/getting-started\/building-your-first-smart-contract","title":"Building Your First Smart Contract"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens","role":"project","title":"Managing Non-Fungible Tokens","estimatedTime":"15min","type":"topic","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Initializing-the-Project":{"kind":"section","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Initializing-the-Project","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"role":"pseudoSymbol","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","title":"Initializing the Project"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","type":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"kind":"section","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Fungible-Token-from-Your-Contract","title":"Issuing a Fungible Token from Your Contract"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Assign-Create-AddQuantity-and-Burn-Roles","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"type":"section","title":"Assign Create, AddQuantity, and Burn Roles"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Creating-Your-Own-Types":{"kind":"section","title":"Creating Your Own Types","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Creating-Your-Own-Types","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}]},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls":{"kind":"project","role":"project","url":"\/tutorials\/spacekit\/asynccalls","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","title":"Interacting with Contracts Across Shards","estimatedTime":"15min","type":"topic"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Perform-a-Synchronous-Call":{"abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","type":"section","title":"Perform a Synchronous Call","url":"\/tutorials\/spacekit\/synccalls#Perform-a-Synchronous-Call","role":"pseudoSymbol","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Mint-New-Tokens":{"kind":"section","title":"Mint New Tokens","type":"section","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Mint-New-Tokens","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}]},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Non-Fungible-Tokens":{"kind":"article","title":"Managing Non-Fungible Tokens","type":"topic","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-non-fungible-tokens","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools":{"estimatedTime":"10min","abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"title":"Install the Necessary Tools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","role":"project","url":"\/tutorials\/spacekit\/installingtools","type":"topic","kind":"project"},"TokenAttributesSection2Step2.swift":{"fileType":"swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        ","    }","}",""],"fileName":"lib.swift","type":"file","highlights":[{"line":62},{"line":63},{"line":64},{"line":65}],"identifier":"TokenAttributesSection2Step2.swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Working-with-Storage-for-Single-Value-Persistence":{"url":"\/tutorials\/spacekit\/storevalues#Working-with-Storage-for-Single-Value-Persistence","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"type":"section","title":"Working with @Storage for Single Value Persistence"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Setting-Up-the-SpaceKit-CLI":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI","type":"section","kind":"section","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"title":"Setting Up the SpaceKit CLI","url":"\/tutorials\/spacekit\/installingtools#Setting-Up-the-SpaceKit-CLI"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Persisting-Data-Across-Executions":{"url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/persisting-data-across-executions","role":"article","kind":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","abstract":[],"type":"topic","title":"Persisting Data Across Executions"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Declare-the-Callee-Proxy":{"kind":"section","title":"Declare the Callee Proxy","type":"section","url":"\/tutorials\/spacekit\/synccalls#Declare-the-Callee-Proxy","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}]},"TokenAttributesSection2Step10.swift":{"identifier":"TokenAttributesSection2Step10.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileName":"lib.swift","type":"file","syntax":"swift","fileType":"swift","highlights":[{"line":89},{"line":90},{"line":91}]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Understanding-the-Buffer-Type":{"abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","type":"section","title":"Understanding the Buffer Type","kind":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Understanding-the-Buffer-Type","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Enhancing-Contracts-with-Token-Attributes":{"kind":"article","title":"Enhancing Contracts with Token Attributes","type":"topic","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/enhancing-contracts-with-token-attributes","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Assign-Mint-and-Burn-Roles","type":"section","kind":"section","title":"Assign Mint and Burn Roles"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Interacting-with-Other-Contracts":{"url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/interacting-with-other-contracts","role":"article","kind":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","abstract":[],"type":"topic","title":"Interacting with Other Contracts"},"TokenAttributesSection1Step1.swift":{"fileName":"lib.swift","fileType":"swift","identifier":"TokenAttributesSection1Step1.swift","syntax":"swift","content":["import SpaceKit","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","}"],"type":"file","highlights":[]},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Calling-Contracts-Across-Shards":{"kind":"article","title":"Calling Contracts Across Shards","type":"topic","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/calling-contracts-across-shards","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-lockFunds-Endpoint":{"kind":"section","title":"Implementing the lockFunds Endpoint","type":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-lockFunds-Endpoint","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}]},"TokenAttributesSection2Step5.swift":{"highlights":[{"line":64},{"line":66},{"line":67},{"line":68}],"type":"file","identifier":"TokenAttributesSection2Step5.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileName":"lib.swift","fileType":"swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Writing-the-Contract-Code":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","title":"Writing the Contract Code","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Writing-the-Contract-Code","kind":"section","type":"section","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}]},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Declare-the-Callee-Proxy":{"url":"\/tutorials\/spacekit\/asynccalls#Declare-the-Callee-Proxy","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"type":"section","title":"Declare the Callee Proxy"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract":{"title":"Issuing a Meta ESDT from Your Contract","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Meta-ESDT-from-Your-Contract","role":"pseudoSymbol","type":"section","kind":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"text":" ","type":"text"},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens":{"url":"\/tutorials\/spacekit\/understandtokens","type":"topic","kind":"project","estimatedTime":"15min","title":"Understand the ESDT Standard","role":"project","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"text":" ","type":"text"},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens"},"TokenAttributesSection3Step5.swift":{"content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftUpdateAttributes) else {","            smartContractError(message: \"Cannot change token attributes\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        var attributes = self.getTokenAttributes(nonce: payment.nonce)","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileName":"lib.swift","highlights":[{"line":110},{"line":111}],"type":"file","fileType":"swift","identifier":"TokenAttributesSection3Step5.swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Add-Quantity-to-an-Existing-Nonce","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce","type":"section","kind":"section","title":"Add Quantity to an Existing Nonce","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","title":"Issuing a Semi-Fungible Token from Your Contract","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","kind":"section","type":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/familiarizewithtypes#Handling-Heap-Allocation-Challenges","type":"section","kind":"section","title":"Handling Heap Allocation Challenges"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Creating-and-Understanding-Tokens":{"role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","type":"topic","abstract":[],"kind":"article","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/creating-and-understanding-tokens","title":"Creating and Understanding Tokens"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes":{"url":"\/tutorials\/spacekit\/familiarizewithtypes","role":"project","title":"Exploring SpaceKit's Types","estimatedTime":"20min","type":"topic","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint":{"role":"pseudoSymbol","title":"Implementing the changeTokenLockDuration Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint","kind":"section","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"type":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-changeTokenLockDuration-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Burn-Tokens":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Burn-Tokens","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"type":"section","title":"Burn Tokens"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-Vector-Type":{"kind":"section","title":"Working with the Vector Type","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-Vector-Type","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Burn-Tokens":{"kind":"section","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Burn-Tokens","title":"Burn Tokens","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"role":"pseudoSymbol","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","url":"\/tutorials\/spacekit\/tokenattributes","estimatedTime":"15min","role":"project","type":"topic","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"title":"Enhance Your Contracts with Token Attributes","kind":"project"},"TokenAttributesSection1Step8.swift":{"type":"file","highlights":[{"line":52},{"line":53},{"line":54},{"line":55},{"line":56},{"line":57},{"line":58}],"fileType":"swift","identifier":"TokenAttributesSection1Step8.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","    }","}",""],"syntax":"swift","fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Installing-SpaceKits-Dependencies":{"kind":"section","title":"Installing SpaceKit's Dependencies","type":"section","url":"\/tutorials\/spacekit\/installingtools#Installing-SpaceKits-Dependencies","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}]},"TokenAttributesSection3Step2.swift":{"highlights":[{"line":96},{"line":97},{"line":98},{"line":99}],"type":"file","identifier":"TokenAttributesSection3Step2.swift","content":["import SpaceKit","","@Codable public struct LockedTokenAttributes {","    let creationTimestamp: UInt64","    var lockDuration: UInt64","    let lockedEgldAmount: BigUint","}","","@Init public func initialize(","    tokenIdentifier: TokenIdentifier,","    lockDuration: UInt64",") {","    var controller = LockController()","    ","    controller.tokenIdentifier = tokenIdentifier","    controller.lockDuration = lockDuration","}","","@Controller public struct LockController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Storage(key: \"lockDuration\") var lockDuration: UInt64","    ","    public func lockFunds() -> UInt64 {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new NFT\")","        }","        ","        let paymentAmount = Message.egldValue","        ","        guard paymentAmount > 0 else {","            smartContractError(message: \"EGLD payment should be greater than zero\")","        }","        ","        let lockedAttributes = LockedTokenAttributes(","            creationTimestamp: Blockchain.getBlockTimestamp(),","            lockDuration: self.lockDuration,","            lockedEgldAmount: paymentAmount","        )","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.tokenIdentifier,","                amount: 1,","                name: \"LockedEGLD\",","                royalties: 0,","                hash: \"\",","                attributes: lockedAttributes,","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.tokenIdentifier,","                nonce: newNonce,","                amount: 1","            )","        ","        return newNonce","    }","    ","    public func unlockFunds() -> BigUint {","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.tokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn NFT\")","        }","        ","        let payment = Message.singleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment\")","        }","        ","        let attributes = self.getTokenAttributes(nonce: payment.nonce)","        ","        let unlockTime = attributes.creationTimestamp + attributes.lockDuration","        ","        guard Blockchain.getBlockTimestamp() >= unlockTime else {","            smartContractError(message: \"Funds cannot be unlocked yet\")","        }","        ","        Blockchain.burnTokens(","            tokenIdentifier: payment.tokenIdentifier,","            nonce: payment.nonce,","            amount: payment.amount","        )","        ","        Message.caller","            .send(egldValue: attributes.lockedEgldAmount)","        ","        return attributes.lockedEgldAmount","    }","    ","    public func changeTokenLockDuration(newLockDuration: UInt64) {","        assertOwner()","    }","    ","    func getTokenAttributes(nonce: UInt64) -> LockedTokenAttributes {","        Blockchain","            .getTokenAttributes(","                tokenIdentifier: self.tokenIdentifier,","                nonce: nonce","            )","    }","}",""],"fileType":"swift","syntax":"swift","fileName":"lib.swift"}}}
{"hierarchy":{"paths":[["doc:\/\/SpaceKit\/tutorials\/SpaceKit","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens"]],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","modules":[{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract"}]},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types"},{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo"}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens"}]},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens"},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Build-a-Coin-Flip-Smart-Contract","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro#Set-Up-the-Project","kind":"task"}]}]},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Flip-Structure"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Implement-Contract-Storage","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Contract-Init","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Define-the-Storage-for-the-Flip-Contract"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Add-Administrative-Endpoints-to-the-Flip-Contract","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-the-Minimum-Block-Bounty-Delay","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-Maximum-Bet-Limits","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Increase-Contract-Reserves","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Withdraw-Contract-Reserves","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Implement-the-Game-Logic-for-the-Flip-Contract","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-flip-Endpoint","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-makeFlip-Function"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Define-the-bounty-Endpoint"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame"}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Set-Up-the-Test-Project","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Declare-Constants-for-the-Test-Environment"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Configure-the-Initial-Blockchain-State","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Write-Tests-for-the-Setup-Helpers"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Set-Up-Testing-in-the-SwiftVM"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Admin-Endpoints","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-the-Maximum-Bet-Configuration-Endpoints","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-increaseReserve-Endpoint"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-withdrawReserve-Endpoint"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Game-Logic-for-the-Flip-Contract","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Create-Utility-Functions-for-flip-and-bounty","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Cases-for-the-flip-Endpoint","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Successful-Calls-to-the-flip-Endpoint","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Case-for-the-bounty-Endpoint"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-the-bounty-Endpoint"}]}]}]},"schemaVersion":{"major":0,"patch":0,"minor":3},"identifier":{"url":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","interfaceLanguage":"swift"},"variants":[{"paths":["\/tutorials\/spacekit\/operationsonfungibletokens"],"traits":[{"interfaceLanguage":"swift"}]}],"metadata":{"role":"project","categoryPathComponent":"SpaceKit","category":"SpaceKit","title":"Managing Fungible Tokens"},"sections":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}]},{"inlineContent":[{"type":"text","text":"After issuing a fungible token, you can increase its supply by minting new tokens or decrease it by burning existing tokens."}],"type":"paragraph"},{"inlineContent":[{"text":"Minting creates new tokens, expanding the total supply. Burning permanently removes tokens from circulation, reducing the total supply.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"To mint tokens, the token must be designated as mintable, and the smart contract must hold the mint role. Minting occurs synchronously, making the newly created tokens immediately available for transactions.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"To burn tokens, the token must be designated as burnable, and the smart contract must hold the burn role. A contract can only burn tokens that it owns. Like minting, burning is a synchronous process.","type":"text"}],"type":"paragraph"}],"kind":"hero","estimatedTimeInMinutes":15,"chapter":"Managing Fungible Tokens","title":"Managing Fungible Tokens"},{"tasks":[{"anchor":"Assign-Mint-and-Burn-Roles","title":"Assign Mint and Burn Roles","contentSection":[{"mediaPosition":"trailing","kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"text":"By default, a smart contract does not have permission to mint or burn tokens. These roles must be explicitly assigned before performing either operation. Assigning roles is an asynchronous process that does not require a callback. If the token supports role management, only the token’s manager—the original issuer—can grant these roles.","type":"text"}]}]}],"stepsSection":[{"runtimePreview":null,"code":"OperationsOnFungibleTokensSection1Step1.swift","media":null,"type":"step","caption":[{"inlineContent":[{"type":"text","text":"The token is configured to be both mintable and burnable."}],"type":"paragraph"}],"content":[{"type":"paragraph","inlineContent":[{"text":"Start with the code from the previous section, where the fungible token was issued.","type":"text"}]}]},{"media":null,"caption":[],"code":"OperationsOnFungibleTokensSection1Step2.swift","runtimePreview":null,"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define a restricted endpoint named "},{"code":"setMintAndBurnRoles","type":"codeVoice"},{"text":", allowing only the contract owner to invoke it.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Ensure that the token has already been issued before proceeding.","type":"text"}],"type":"paragraph"}],"media":null,"runtimePreview":null,"type":"step","code":"OperationsOnFungibleTokensSection1Step3.swift","caption":[]},{"runtimePreview":null,"caption":[],"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Implement the "},{"type":"codeVoice","code":"setTokenRoles"},{"type":"text","text":" function to assign the necessary roles."}]}],"media":null,"code":"OperationsOnFungibleTokensSection1Step4.swift"},{"caption":[],"code":"OperationsOnFungibleTokensSection1Step5.swift","content":[{"type":"paragraph","inlineContent":[{"text":"Register a promise to initiate the asynchronous role assignment.","type":"text"}]}],"type":"step","media":null,"runtimePreview":null}]},{"anchor":"Mint-New-Tokens","stepsSection":[{"caption":[{"inlineContent":[{"text":"The token remains both mintable and burnable.","type":"text"}],"type":"paragraph"}],"media":null,"type":"step","code":"OperationsOnFungibleTokensSection2Step1.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use the code from the previous section as your starting point."}]}],"runtimePreview":null},{"content":[{"type":"paragraph","inlineContent":[{"text":"Define a ","type":"text"},{"code":"mintTokens","type":"codeVoice"},{"type":"text","text":" endpoint, accessible only to the contract owner. This endpoint accepts a "},{"code":"mintAmount","type":"codeVoice"},{"text":" parameter, specifying the number of tokens to mint.","type":"text"}]}],"caption":[],"media":null,"code":"OperationsOnFungibleTokensSection2Step2.swift","runtimePreview":null,"type":"step"},{"code":"OperationsOnFungibleTokensSection2Step3.swift","caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Retrieve the roles assigned to the smart contract for the issued token."}]}],"type":"step","runtimePreview":null,"media":null},{"media":null,"code":"OperationsOnFungibleTokensSection2Step4.swift","runtimePreview":null,"caption":[{"inlineContent":[{"type":"text","text":"This ensures that "},{"type":"codeVoice","code":"setMintAndBurnRoles"},{"text":" executed successfully and that the role assignment completed.","type":"text"}],"type":"paragraph"}],"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Confirm that the contract possesses the mint role.","type":"text"}]}]},{"media":null,"runtimePreview":null,"caption":[{"inlineContent":[{"type":"text","text":"Minting occurs synchronously. If the operation fails, the transaction is reverted. Newly minted tokens are added to the contract’s balance immediately."}],"type":"paragraph"}],"type":"step","code":"OperationsOnFungibleTokensSection2Step5.swift","content":[{"inlineContent":[{"text":"Execute the minting operation.","type":"text"}],"type":"paragraph"}]},{"type":"step","content":[{"inlineContent":[{"text":"Transfer the minted tokens to the caller of the endpoint.","type":"text"}],"type":"paragraph"}],"code":"OperationsOnFungibleTokensSection2Step6.swift","runtimePreview":null,"caption":[],"media":null}],"title":"Mint New Tokens","contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"text":"Now that the contract has the mint role, you can proceed with minting tokens.","type":"text"}]}],"mediaPosition":"trailing"}]},{"anchor":"Burn-Tokens","title":"Burn Tokens","contentSection":[{"kind":"contentAndMedia","content":[{"inlineContent":[{"type":"text","text":"Burning tokens is the inverse of minting. Since the contract now has the burn role, you can proceed with the burn operation."}],"type":"paragraph"}],"mediaPosition":"trailing"}],"stepsSection":[{"runtimePreview":null,"caption":[{"type":"paragraph","inlineContent":[{"text":"The token remains both mintable and burnable.","type":"text"}]}],"content":[{"inlineContent":[{"type":"text","text":"Use the code from the previous section as your base."}],"type":"paragraph"}],"media":null,"type":"step","code":"OperationsOnFungibleTokensSection3Step1.swift"},{"media":null,"code":"OperationsOnFungibleTokensSection3Step2.swift","runtimePreview":null,"type":"step","caption":[],"content":[{"inlineContent":[{"type":"text","text":"Define a "},{"code":"burnTokens","type":"codeVoice"},{"type":"text","text":" endpoint, restricted to the contract owner. This endpoint requires a "},{"type":"codeVoice","code":"burnAmount"},{"text":" parameter, specifying the number of tokens to remove from circulation.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Validate that the contract holds the necessary burn role before proceeding."}],"type":"paragraph"}],"caption":[],"media":null,"runtimePreview":null,"code":"OperationsOnFungibleTokensSection3Step3.swift","type":"step"},{"runtimePreview":null,"type":"step","code":"OperationsOnFungibleTokensSection3Step4.swift","caption":[{"type":"paragraph","inlineContent":[{"text":"Note: The burn operation is synchronous. If the contract does not have enough tokens, the transaction is reverted.","type":"text"}]}],"media":null,"content":[{"inlineContent":[{"text":"Execute the burn operation, removing tokens from the contract’s balance.","type":"text"}],"type":"paragraph"}]}]}],"kind":"tasks"},{"abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"action":{"isActive":true,"overridingTitle":"Get started","type":"reference","overridingTitleInlineContent":[{"text":"Get started","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"},"featuredEyebrow":"Tutorial","title":"Managing Non-Fungible Tokens","kind":"callToAction"}],"kind":"project","references":{"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Creating-Your-Own-Types":{"title":"Creating Your Own Types","role":"pseudoSymbol","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"kind":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Creating-Your-Own-Types","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types"},"doc://SpaceKit/tutorials/SpaceKit":{"title":"Meet SpaceKit","abstract":[{"type":"text","text":"Discover how SpaceKit simplifies blockchain development using Swift. Dive into the world of Web3 with ease and efficiency."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","url":"\/tutorials\/spacekit","role":"overview","kind":"overview","type":"topic"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Create-Utility-Functions-for-flip-and-bounty":{"url":"\/tutorials\/spacekit\/flipcontracttestthegame#Create-Utility-Functions-for-flip-and-bounty","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Create-Utility-Functions-for-flip-and-bounty","kind":"section","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"text":".","type":"text"}],"role":"pseudoSymbol","title":"Create Utility Functions for flip and bounty"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-BigUint-Type":{"url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-BigUint-Type","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","kind":"section","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"role":"pseudoSymbol","title":"Working with the BigUint Type"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Burn-Tokens":{"url":"\/tutorials\/spacekit\/operationsonfungibletokens#Burn-Tokens","kind":"section","type":"section","role":"pseudoSymbol","title":"Burn Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","abstract":[{"text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens":{"url":"\/tutorials\/spacekit\/understandtokens","estimatedTime":"15min","role":"project","kind":"project","title":"Understand the ESDT Standard","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens","type":"topic","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-Failure-Case-for-the-bounty-Endpoint":{"url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-Failure-Case-for-the-bounty-Endpoint","role":"pseudoSymbol","kind":"section","title":"Test Failure Case for the bounty Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Case-for-the-bounty-Endpoint","type":"section","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"text":".","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin":{"title":"Test the Admin Endpoints","type":"topic","role":"project","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}],"kind":"project","estimatedTime":"20min","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin","url":"\/tutorials\/spacekit\/flipcontracttestadmin"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests":{"url":"\/tutorials\/spacekit\/flipcontractinittests","type":"topic","kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests","estimatedTime":"20min","abstract":[{"text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential.","type":"text"}],"title":"Set Up Testing in the SwiftVM","role":"project"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract":{"title":"Issuing a Meta ESDT from Your Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"kind":"section","role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Meta-ESDT-from-Your-Contract"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Persisting-Data-Across-Executions":{"title":"Persisting Data Across Executions","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","type":"topic","abstract":[],"kind":"article","role":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/persisting-data-across-executions"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools":{"title":"Install the Necessary Tools","estimatedTime":"10min","url":"\/tutorials\/spacekit\/installingtools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"role":"project","kind":"project","type":"topic"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls":{"title":"Interact with Other Contracts","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls","abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}],"kind":"project","role":"project","estimatedTime":"15min","type":"topic","url":"\/tutorials\/spacekit\/synccalls"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes":{"type":"topic","url":"\/tutorials\/spacekit\/familiarizewithtypes","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes","estimatedTime":"20min","role":"project","kind":"project","title":"Exploring SpaceKit's Types","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Installing-the-Tools":{"abstract":[],"role":"article","kind":"article","url":"\/tutorials\/spacekit\/getting-started\/installing-the-tools","type":"topic","title":"Installing the Tools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Initializing-the-Project":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Initializing-the-Project","role":"pseudoSymbol","kind":"section","title":"Initializing the Project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","type":"section","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-the-bounty-Endpoint":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-the-bounty-Endpoint","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"text":".","type":"text"}],"role":"pseudoSymbol","title":"Test the bounty Endpoint","kind":"section","url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-the-bounty-Endpoint","type":"section"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges":{"title":"Handling Heap Allocation Challenges","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"kind":"section","role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Handling-Heap-Allocation-Challenges"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Test-the-withdrawReserve-Endpoint":{"type":"section","kind":"section","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}],"title":"Test the withdrawReserve Endpoint","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/flipcontracttestadmin#Test-the-withdrawReserve-Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-withdrawReserve-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Creating-and-Understanding-Tokens":{"url":"\/tutorials\/spacekit\/create-and-manage-tokens\/creating-and-understanding-tokens","kind":"article","type":"topic","role":"article","title":"Creating and Understanding Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Declare-the-Callee-Proxy":{"url":"\/tutorials\/spacekit\/asynccalls#Declare-the-Callee-Proxy","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"title":"Declare the Callee Proxy","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Test-the-increaseReserve-Endpoint":{"kind":"section","abstract":[{"text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/flipcontracttestadmin#Test-the-increaseReserve-Endpoint","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-increaseReserve-Endpoint","title":"Test the increaseReserve Endpoint"},"OperationsOnFungibleTokensSection3Step4.swift":{"type":"file","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func mintTokens(mintAmount: BigUint) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .mint) else {","            smartContractError(message: \"Cannot mint tokens\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: mintAmount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: mintAmount","            )","    }","    ","    public func burnTokens(burnAmount: BigUint) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .burn) else {","            smartContractError(message: \"Cannot mint tokens\")","        }","        ","        Blockchain","            .burnTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: burnAmount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileName":"lib.swift","identifier":"OperationsOnFungibleTokensSection3Step4.swift","syntax":"swift","highlights":[{"line":95},{"line":96},{"line":97},{"line":98},{"line":99},{"line":100},{"line":101}],"fileType":"swift"},"OperationsOnFungibleTokensSection2Step2.swift":{"identifier":"OperationsOnFungibleTokensSection2Step2.swift","highlights":[{"line":63},{"line":64},{"line":65},{"line":66}],"syntax":"swift","fileName":"lib.swift","fileType":"swift","type":"file","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func mintTokens(mintAmount: BigUint) {","        assertOwner()","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"OperationsOnFungibleTokensSection1Step2.swift":{"syntax":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","fileType":"swift","fileName":"lib.swift","identifier":"OperationsOnFungibleTokensSection1Step2.swift","highlights":[{"line":42},{"line":43},{"line":44},{"line":45}]},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Interacting-with-Other-Contracts":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","title":"Interacting with Other Contracts","kind":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/interacting-with-other-contracts","abstract":[],"type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Test-the-Game-Logic-for-the-Flip-Contract":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/test-the-game-logic-for-the-flip-contract","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Game-Logic-for-the-Flip-Contract","kind":"article","abstract":[],"role":"article","title":"Test the Game Logic for the Flip Contract"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Understanding-the-Buffer-Type":{"title":"Understanding the Buffer Type","role":"pseudoSymbol","kind":"section","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Understanding-the-Buffer-Type","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Burn-Tokens":{"title":"Burn Tokens","role":"pseudoSymbol","kind":"section","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Burn-Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens"},"OperationsOnFungibleTokensSection3Step1.swift":{"fileType":"swift","highlights":[],"content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func mintTokens(mintAmount: BigUint) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .mint) else {","            smartContractError(message: \"Cannot mint tokens\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: mintAmount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: mintAmount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","fileName":"lib.swift","syntax":"swift","identifier":"OperationsOnFungibleTokensSection3Step1.swift"},"OperationsOnFungibleTokensSection1Step5.swift":{"fileType":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileName":"lib.swift","type":"file","highlights":[{"line":58},{"line":59},{"line":60}],"syntax":"swift","identifier":"OperationsOnFungibleTokensSection1Step5.swift"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Writing-the-Contract-Code":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Writing-the-Contract-Code","role":"pseudoSymbol","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","type":"section","title":"Writing the Contract Code","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame","title":"Test the Game Logic for the Flip Contract","kind":"project","estimatedTime":"20min","url":"\/tutorials\/spacekit\/flipcontracttestthegame","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"type":"text","text":"."}],"type":"topic","role":"project"},"OperationsOnFungibleTokensSection2Step3.swift":{"type":"file","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func mintTokens(mintAmount: BigUint) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"highlights":[{"line":65},{"line":66},{"line":67}],"fileType":"swift","syntax":"swift","fileName":"lib.swift","identifier":"OperationsOnFungibleTokensSection2Step3.swift"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Withdraw-Contract-Reserves":{"url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Withdraw-Contract-Reserves","role":"pseudoSymbol","kind":"section","title":"Withdraw Contract Reserves","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Withdraw-Contract-Reserves","type":"section","abstract":[{"type":"text","text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets."}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage":{"title":"Define the Storage for the Flip Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage","abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}],"kind":"project","role":"project","estimatedTime":"20min","type":"topic","url":"\/tutorials\/spacekit\/flipcontractwritethestorage"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues":{"abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"role":"project","estimatedTime":"15min","kind":"project","url":"\/tutorials\/spacekit\/storevalues","type":"topic","title":"Persist Values Between Executions","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-lockFunds-Endpoint":{"url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-lockFunds-Endpoint","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint","kind":"section","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"role":"pseudoSymbol","title":"Implementing the lockFunds Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Perform-an-Asynchronous-Call":{"url":"\/tutorials\/spacekit\/asynccalls#Perform-an-Asynchronous-Call","kind":"section","type":"section","role":"pseudoSymbol","title":"Perform an Asynchronous Call","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}]},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","url":"\/tutorials\/spacekit\/storevalues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","role":"pseudoSymbol","type":"section","kind":"section","abstract":[{"text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory.","type":"text"}],"title":"Leveraging @Mapping for Dynamic Key-Value Storage"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Installing-SpaceKits-Dependencies":{"url":"\/tutorials\/spacekit\/installingtools#Installing-SpaceKits-Dependencies","role":"pseudoSymbol","kind":"section","title":"Installing SpaceKit's Dependencies","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","type":"section","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}]},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Define-the-Storage-for-the-Flip-Contract":{"title":"Define the Storage for the Flip Contract","role":"article","kind":"article","abstract":[],"type":"topic","url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/define-the-storage-for-the-flip-contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Define-the-Storage-for-the-Flip-Contract"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract","kind":"project","estimatedTime":"20min","type":"topic","role":"project","title":"Building Your First Smart Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract","abstract":[{"text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Fungible-Tokens":{"url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-fungible-tokens","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens","kind":"article","abstract":[],"role":"article","title":"Managing Fungible Tokens"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract":{"title":"Issuing a Semi-Fungible Token from Your Contract","type":"section","role":"pseudoSymbol","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"text":" ","type":"text"},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Build-a-Coin-Flip-Smart-Contract":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/build-a-coin-flip-smart-contract","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Build-a-Coin-Flip-Smart-Contract","kind":"article","abstract":[],"role":"article","title":"Build a Coin Flip Smart Contract"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint":{"abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"role":"pseudoSymbol","kind":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-changeTokenLockDuration-Endpoint","type":"section","title":"Implementing the changeTokenLockDuration Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Configure-the-Initial-Blockchain-State":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Configure-the-Initial-Blockchain-State","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/flipcontractinittests#Configure-the-Initial-Blockchain-State","type":"section","title":"Configure the Initial Blockchain State","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}],"kind":"section"},"OperationsOnFungibleTokensSection1Step1.swift":{"fileType":"swift","highlights":[],"content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","fileName":"lib.swift","syntax":"swift","identifier":"OperationsOnFungibleTokensSection1Step1.swift"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Write-Tests-for-the-Setup-Helpers":{"type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Write-Tests-for-the-Setup-Helpers","role":"pseudoSymbol","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}],"url":"\/tutorials\/spacekit\/flipcontractinittests#Write-Tests-for-the-Setup-Helpers","kind":"section","title":"Write Tests for the Setup Helpers"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Working-with-Storage-for-Single-Value-Persistence":{"title":"Working with @Storage for Single Value Persistence","role":"pseudoSymbol","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"kind":"section","url":"\/tutorials\/spacekit\/storevalues#Working-with-Storage-for-Single-Value-Persistence","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints":{"url":"\/tutorials\/spacekit\/flipcontracttestadmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints","kind":"section","type":"section","role":"pseudoSymbol","title":"Verify That Only the Owner Can Access Admin Endpoints","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Set-the-Minimum-Block-Bounty-Delay":{"url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Set-the-Minimum-Block-Bounty-Delay","role":"pseudoSymbol","kind":"section","title":"Set the Minimum Block Bounty Delay","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-the-Minimum-Block-Bounty-Delay","type":"section","abstract":[{"text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Add-Administrative-Endpoints-to-the-Flip-Contract":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/add-administrative-endpoints-to-the-flip-contract","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Add-Administrative-Endpoints-to-the-Flip-Contract","kind":"article","abstract":[],"role":"article","title":"Add Administrative Endpoints to the Flip Contract"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","url":"\/tutorials\/spacekit\/tokenattributes","role":"project","type":"topic","kind":"project","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"estimatedTime":"15min","title":"Enhance Your Contracts with Token Attributes"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Mint-New-Tokens":{"url":"\/tutorials\/spacekit\/operationsonfungibletokens#Mint-New-Tokens","role":"pseudoSymbol","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","type":"section","title":"Mint New Tokens","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage#Implement-Contract-Storage":{"url":"\/tutorials\/spacekit\/flipcontractwritethestorage#Implement-Contract-Storage","kind":"section","type":"section","role":"pseudoSymbol","title":"Implement Contract Storage","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Implement-Contract-Storage","abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Create-a-New-Nonce":{"abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"role":"pseudoSymbol","kind":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Create-a-New-Nonce","type":"section","title":"Create a New Nonce","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls":{"title":"Interacting with Contracts Across Shards","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"kind":"project","role":"project","estimatedTime":"15min","type":"topic","url":"\/tutorials\/spacekit\/asynccalls"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract":{"url":"\/tutorials\/spacekit\/flipcontractinittests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract","role":"pseudoSymbol","kind":"section","title":"Create Helper Functions to Deploy and Configure the Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract","type":"section","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame","estimatedTime":"20min","abstract":[{"type":"text","text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics."}],"role":"project","title":"Implement the Game Logic for the Flip Contract","kind":"project","url":"\/tutorials\/spacekit\/flipcontractwritethegame","type":"topic"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame#Implement-the-flip-Endpoint":{"kind":"section","abstract":[{"type":"text","text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics."}],"type":"section","url":"\/tutorials\/spacekit\/flipcontractwritethegame#Implement-the-flip-Endpoint","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-flip-Endpoint","title":"Implement the flip Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Retrieving-Information-from-the-Blockchain":{"type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","role":"article","abstract":[],"url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/retrieving-information-from-the-blockchain","kind":"article","title":"Retrieving Information from the Blockchain"},"OperationsOnFungibleTokensSection2Step6.swift":{"syntax":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func mintTokens(mintAmount: BigUint) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .mint) else {","            smartContractError(message: \"Cannot mint tokens\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: mintAmount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: mintAmount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"identifier":"OperationsOnFungibleTokensSection2Step6.swift","type":"file","fileName":"lib.swift","fileType":"swift","highlights":[{"line":78},{"line":79},{"line":80},{"line":81},{"line":82},{"line":83},{"line":84}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Increase-Contract-Reserves":{"url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Increase-Contract-Reserves","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Increase-Contract-Reserves","kind":"section","abstract":[{"type":"text","text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets."}],"role":"pseudoSymbol","title":"Increase Contract Reserves"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin":{"estimatedTime":"20min","url":"\/tutorials\/spacekit\/flipcontractwriteadmin","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin","type":"topic","kind":"project","title":"Add Administrative Endpoints to the Flip Contract","role":"project","abstract":[{"text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Setting-Up-the-SpaceKit-CLI":{"url":"\/tutorials\/spacekit\/installingtools#Setting-Up-the-SpaceKit-CLI","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI","kind":"section","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"role":"pseudoSymbol","title":"Setting Up the SpaceKit CLI"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-Vector-Type":{"url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-Vector-Type","type":"section","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"title":"Working with the Vector Type","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Blockchain-Context-Data":{"abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"url":"\/tutorials\/spacekit\/getinfo#Accessing-Blockchain-Context-Data","role":"pseudoSymbol","title":"Accessing Blockchain Context Data","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data"},"OperationsOnFungibleTokensSection1Step3.swift":{"content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","identifier":"OperationsOnFungibleTokensSection1Step3.swift","highlights":[{"line":44},{"line":45},{"line":46},{"line":47}],"fileName":"lib.swift","syntax":"swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-Failure-Cases-for-the-flip-Endpoint":{"url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-Failure-Cases-for-the-flip-Endpoint","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Cases-for-the-flip-Endpoint","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"code":"GameController","type":"codeVoice"},{"text":".","type":"text"}],"kind":"section","title":"Test Failure Cases for the flip Endpoint","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Enhancing-Contracts-with-Token-Attributes":{"abstract":[],"role":"article","kind":"article","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/enhancing-contracts-with-token-attributes","type":"topic","title":"Enhancing Contracts with Token Attributes","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes"},"OperationsOnFungibleTokensSection2Step1.swift":{"syntax":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"identifier":"OperationsOnFungibleTokensSection2Step1.swift","type":"file","fileName":"lib.swift","fileType":"swift","highlights":[]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Set-Maximum-Bet-Limits":{"kind":"section","abstract":[{"type":"text","text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets."}],"type":"section","url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Set-Maximum-Bet-Limits","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-Maximum-Bet-Limits","title":"Set Maximum Bet Limits"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame#Implement-the-makeFlip-Function":{"url":"\/tutorials\/spacekit\/flipcontractwritethegame#Implement-the-makeFlip-Function","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-makeFlip-Function","kind":"section","abstract":[{"type":"text","text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics."}],"role":"pseudoSymbol","title":"Implement the makeFlip Function"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame#Define-the-bounty-Endpoint":{"abstract":[{"text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics.","type":"text"}],"kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Define-the-bounty-Endpoint","type":"section","title":"Define the bounty Endpoint","url":"\/tutorials\/spacekit\/flipcontractwritethegame#Define-the-bounty-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Testing-the-Contract":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Testing-the-Contract","role":"pseudoSymbol","kind":"section","title":"Testing the Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract","type":"section","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}]},"OperationsOnFungibleTokensSection2Step4.swift":{"identifier":"OperationsOnFungibleTokensSection2Step4.swift","fileType":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func mintTokens(mintAmount: BigUint) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .mint) else {","            smartContractError(message: \"Cannot mint tokens\")","        }","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","highlights":[{"line":68},{"line":69},{"line":70}],"syntax":"swift","fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Set-Up-the-Test-Project":{"title":"Set Up the Test Project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Set-Up-the-Test-Project","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}],"url":"\/tutorials\/spacekit\/flipcontractinittests#Set-Up-the-Test-Project","type":"section","kind":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Test-the-Admin-Endpoints":{"type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Admin-Endpoints","role":"article","abstract":[],"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/test-the-admin-endpoints","kind":"article","title":"Test the Admin Endpoints"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Exploring-SpaceKit's-Types":{"abstract":[],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","title":"Exploring SpaceKit's Types","type":"topic","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/exploring-spacekit's-types","kind":"article","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Declare-Constants-for-the-Test-Environment":{"title":"Declare Constants for the Test Environment","role":"pseudoSymbol","kind":"section","abstract":[{"text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/flipcontractinittests#Declare-Constants-for-the-Test-Environment","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Declare-Constants-for-the-Test-Environment"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract":{"type":"section","kind":"section","url":"\/tutorials\/spacekit\/installingtools#Initializing-and-Compiling-Your-First-Smart-Contract","abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"title":"Initializing and Compiling Your First Smart Contract","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Assign-Create-AddQuantity-and-Burn-Roles","kind":"section","type":"section","role":"pseudoSymbol","title":"Assign Create, AddQuantity, and Burn Roles","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens":{"type":"topic","estimatedTime":"15min","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","role":"project","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"url":"\/tutorials\/spacekit\/operationsonfungibletokens","kind":"project","title":"Managing Fungible Tokens"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Building-Your-First-Smart-Contract":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","title":"Building Your First Smart Contract","kind":"article","url":"\/tutorials\/spacekit\/getting-started\/building-your-first-smart-contract","abstract":[],"type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles":{"abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Assign-Mint-and-Burn-Roles","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","kind":"section","type":"section","title":"Assign Mint and Burn Roles"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-unlockFunds-Endpoint":{"type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-unlockFunds-Endpoint","title":"Implementing the unlockFunds Endpoint","kind":"section","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Implement-the-Game-Logic-for-the-Flip-Contract":{"title":"Implement the Game Logic for the Flip Contract","role":"article","kind":"article","abstract":[],"type":"topic","url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/implement-the-game-logic-for-the-flip-contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Implement-the-Game-Logic-for-the-Flip-Contract"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractIntro#Set-Up-the-Project":{"url":"\/tutorials\/spacekit\/flipcontractintro#Set-Up-the-Project","kind":"section","type":"section","role":"pseudoSymbol","title":"Set Up the Project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro#Set-Up-the-Project","abstract":[{"type":"text","text":"In this tutorial, you’ll write and test a complete smart contract that relies on random number generation to implement a coin flip mechanic. Players wager a chosen amount of any token and face a 50% chance of doubling their bet—or losing it. A small fee is deducted from each wager and sent to the developer’s wallet."}]},"OperationsOnFungibleTokensSection1Step4.swift":{"syntax":"swift","fileName":"lib.swift","type":"file","highlights":[{"line":48},{"line":49},{"line":50},{"line":51},{"line":52},{"line":53},{"line":54},{"line":55},{"line":56},{"line":57}],"fileType":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"identifier":"OperationsOnFungibleTokensSection1Step4.swift"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce":{"title":"Add Quantity to an Existing Nonce","role":"pseudoSymbol","kind":"section","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Add-Quantity-to-an-Existing-Nonce","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract":{"title":"Issuing a Non-Fungible Token from Your Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","type":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"kind":"section","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Non-Fungible-Token-from-Your-Contract"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens":{"estimatedTime":"15min","type":"topic","title":"Managing Non-Fungible Tokens","role":"project","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"},"OperationsOnFungibleTokensSection2Step5.swift":{"type":"file","fileName":"lib.swift","syntax":"swift","fileType":"swift","identifier":"OperationsOnFungibleTokensSection2Step5.swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func mintTokens(mintAmount: BigUint) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .mint) else {","            smartContractError(message: \"Cannot mint tokens\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: mintAmount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"highlights":[{"line":71},{"line":72},{"line":73},{"line":74},{"line":75},{"line":76},{"line":77}]},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Non-Fungible-Tokens":{"url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-non-fungible-tokens","kind":"article","type":"topic","role":"article","title":"Managing Non-Fungible Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractIntro":{"type":"topic","url":"\/tutorials\/spacekit\/flipcontractintro","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro","estimatedTime":"20min","role":"project","kind":"project","title":"Build a Coin Flip Smart Contract","abstract":[{"text":"In this tutorial, you’ll write and test a complete smart contract that relies on random number generation to implement a coin flip mechanic. Players wager a chosen amount of any token and face a 50% chance of doubling their bet—or losing it. A small fee is deducted from each wager and sent to the developer’s wallet.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage#Define-the-Contract-Init":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Contract-Init","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/flipcontractwritethestorage#Define-the-Contract-Init","abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}],"title":"Define the Contract Init","type":"section","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Calling-Contracts-Across-Shards":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","title":"Calling Contracts Across Shards","kind":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/calling-contracts-across-shards","abstract":[],"type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Perform-a-Synchronous-Call":{"kind":"section","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/synccalls#Perform-a-Synchronous-Call","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","title":"Perform a Synchronous Call"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-Successful-Calls-to-the-flip-Endpoint":{"title":"Test Successful Calls to the flip Endpoint","role":"pseudoSymbol","kind":"section","abstract":[{"text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the ","type":"text"},{"type":"codeVoice","code":"GameController"},{"type":"text","text":"."}],"type":"section","url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-Successful-Calls-to-the-flip-Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Successful-Calls-to-the-flip-Endpoint"},"OperationsOnFungibleTokensSection3Step3.swift":{"syntax":"swift","fileName":"lib.swift","type":"file","highlights":[{"line":89},{"line":90},{"line":91},{"line":92},{"line":93},{"line":94}],"fileType":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func mintTokens(mintAmount: BigUint) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .mint) else {","            smartContractError(message: \"Cannot mint tokens\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: mintAmount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: mintAmount","            )","    }","    ","    public func burnTokens(burnAmount: BigUint) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .burn) else {","            smartContractError(message: \"Cannot mint tokens\")","        }","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"identifier":"OperationsOnFungibleTokensSection3Step3.swift"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Verify-the-Maximum-Bet-Configuration-Endpoints":{"url":"\/tutorials\/spacekit\/flipcontracttestadmin#Verify-the-Maximum-Bet-Configuration-Endpoints","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-the-Maximum-Bet-Configuration-Endpoints","kind":"section","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}],"role":"pseudoSymbol","title":"Verify the Maximum Bet Configuration Endpoints"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Declare-the-Callee-Proxy":{"type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","url":"\/tutorials\/spacekit\/synccalls#Declare-the-Callee-Proxy","title":"Declare the Callee Proxy","kind":"section","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}],"role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","role":"project","url":"\/tutorials\/spacekit\/getinfo","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"title":"Retrieving Information from the Blockchain","type":"topic","estimatedTime":"10min","kind":"project"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Set-Up-Testing-in-the-SwiftVM":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/set-up-testing-in-the-swiftvm","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Set-Up-Testing-in-the-SwiftVM","kind":"article","abstract":[],"role":"article","title":"Set Up Testing in the SwiftVM"},"OperationsOnFungibleTokensSection3Step2.swift":{"type":"file","fileName":"lib.swift","syntax":"swift","fileType":"swift","identifier":"OperationsOnFungibleTokensSection3Step2.swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func mintTokens(mintAmount: BigUint) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .mint) else {","            smartContractError(message: \"Cannot mint tokens\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: mintAmount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: mintAmount","            )","    }","    ","    public func burnTokens(burnAmount: BigUint) {","        assertOwner()","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"highlights":[{"line":87},{"line":88},{"line":89},{"line":90}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage#Define-the-Flip-Structure":{"abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}],"url":"\/tutorials\/spacekit\/flipcontractwritethestorage#Define-the-Flip-Structure","role":"pseudoSymbol","title":"Define the Flip Structure","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Flip-Structure"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Transaction-Context-Data":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/getinfo#Accessing-Transaction-Context-Data","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"title":"Accessing Transaction Context Data","type":"section","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract":{"url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Fungible-Token-from-Your-Contract","role":"pseudoSymbol","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","type":"section","title":"Issuing a Fungible Token from Your Contract","kind":"section"}}}
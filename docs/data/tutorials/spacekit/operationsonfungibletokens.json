{"variants":[{"paths":["\/tutorials\/spacekit\/operationsonfungibletokens"],"traits":[{"interfaceLanguage":"swift"}]}],"sections":[{"kind":"hero","chapter":"Managing Fungible Tokens","content":[{"inlineContent":[{"text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"After issuing a fungible token, you can increase its supply by minting new tokens or decrease it by burning existing tokens."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Minting creates new tokens, expanding the total supply. Burning permanently removes tokens from circulation, reducing the total supply.","type":"text"}]},{"inlineContent":[{"text":"To mint tokens, the token must be designated as mintable, and the smart contract must hold the mint role. Minting occurs synchronously, making the newly created tokens immediately available for transactions.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"To burn tokens, the token must be designated as burnable, and the smart contract must hold the burn role. A contract can only burn tokens that it owns. Like minting, burning is a synchronous process."}],"type":"paragraph"}],"title":"Managing Fungible Tokens","estimatedTimeInMinutes":15},{"tasks":[{"title":"Assign Mint and Burn Roles","contentSection":[{"mediaPosition":"trailing","kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"By default, a smart contract does not have permission to mint or burn tokens. These roles must be explicitly assigned before performing either operation. Assigning roles is an asynchronous process that does not require a callback. If the token supports role management, only the token’s manager—the original issuer—can grant these roles."}]}]}],"anchor":"Assign-Mint-and-Burn-Roles","stepsSection":[{"caption":[{"inlineContent":[{"type":"text","text":"The token is configured to be both mintable and burnable."}],"type":"paragraph"}],"code":"OperationsOnFungibleTokensSection1Step1.swift","content":[{"inlineContent":[{"text":"Start with the code from the previous section, where the fungible token was issued.","type":"text"}],"type":"paragraph"}],"type":"step","media":null,"runtimePreview":null},{"caption":[],"code":"OperationsOnFungibleTokensSection1Step2.swift","media":null,"runtimePreview":null,"type":"step","content":[{"inlineContent":[{"text":"Define a restricted endpoint named ","type":"text"},{"code":"setMintAndBurnRoles","type":"codeVoice"},{"type":"text","text":", allowing only the contract owner to invoke it."}],"type":"paragraph"}]},{"code":"OperationsOnFungibleTokensSection1Step3.swift","content":[{"inlineContent":[{"type":"text","text":"Ensure that the token has already been issued before proceeding."}],"type":"paragraph"}],"runtimePreview":null,"type":"step","caption":[],"media":null},{"runtimePreview":null,"caption":[],"media":null,"type":"step","code":"OperationsOnFungibleTokensSection1Step4.swift","content":[{"inlineContent":[{"text":"Implement the ","type":"text"},{"code":"setTokenRoles","type":"codeVoice"},{"type":"text","text":" function to assign the necessary roles."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Register a promise to initiate the asynchronous role assignment."}]}],"runtimePreview":null,"code":"OperationsOnFungibleTokensSection1Step5.swift","type":"step","caption":[],"media":null}]},{"title":"Mint New Tokens","contentSection":[{"content":[{"inlineContent":[{"type":"text","text":"Now that the contract has the mint role, you can proceed with minting tokens."}],"type":"paragraph"}],"kind":"contentAndMedia","mediaPosition":"trailing"}],"anchor":"Mint-New-Tokens","stepsSection":[{"runtimePreview":null,"media":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use the code from the previous section as your starting point."}]}],"code":"OperationsOnFungibleTokensSection2Step1.swift","type":"step","caption":[{"type":"paragraph","inlineContent":[{"text":"The token remains both mintable and burnable.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define a "},{"type":"codeVoice","code":"mintTokens"},{"text":" endpoint, accessible only to the contract owner. This endpoint accepts a ","type":"text"},{"type":"codeVoice","code":"mintAmount"},{"text":" parameter, specifying the number of tokens to mint.","type":"text"}]}],"caption":[],"code":"OperationsOnFungibleTokensSection2Step2.swift","runtimePreview":null,"media":null,"type":"step"},{"type":"step","content":[{"inlineContent":[{"type":"text","text":"Retrieve the roles assigned to the smart contract for the issued token."}],"type":"paragraph"}],"caption":[],"media":null,"code":"OperationsOnFungibleTokensSection2Step3.swift","runtimePreview":null},{"media":null,"content":[{"inlineContent":[{"type":"text","text":"Confirm that the contract possesses the mint role."}],"type":"paragraph"}],"runtimePreview":null,"code":"OperationsOnFungibleTokensSection2Step4.swift","type":"step","caption":[{"inlineContent":[{"type":"text","text":"This ensures that "},{"type":"codeVoice","code":"setMintAndBurnRoles"},{"type":"text","text":" executed successfully and that the role assignment completed."}],"type":"paragraph"}]},{"runtimePreview":null,"media":null,"content":[{"inlineContent":[{"text":"Execute the minting operation.","type":"text"}],"type":"paragraph"}],"caption":[{"type":"paragraph","inlineContent":[{"text":"Minting occurs synchronously. If the operation fails, the transaction is reverted. Newly minted tokens are added to the contract’s balance immediately.","type":"text"}]}],"type":"step","code":"OperationsOnFungibleTokensSection2Step5.swift"},{"media":null,"content":[{"inlineContent":[{"text":"Transfer the minted tokens to the caller of the endpoint.","type":"text"}],"type":"paragraph"}],"caption":[],"type":"step","code":"OperationsOnFungibleTokensSection2Step6.swift","runtimePreview":null}]},{"title":"Burn Tokens","anchor":"Burn-Tokens","contentSection":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Burning tokens is the inverse of minting. Since the contract now has the burn role, you can proceed with the burn operation."}]}],"kind":"contentAndMedia","mediaPosition":"trailing"}],"stepsSection":[{"caption":[{"type":"paragraph","inlineContent":[{"text":"The token remains both mintable and burnable.","type":"text"}]}],"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use the code from the previous section as your base."}]}],"code":"OperationsOnFungibleTokensSection3Step1.swift","media":null,"runtimePreview":null},{"type":"step","media":null,"content":[{"inlineContent":[{"type":"text","text":"Define a "},{"code":"burnTokens","type":"codeVoice"},{"text":" endpoint, restricted to the contract owner. This endpoint requires a ","type":"text"},{"code":"burnAmount","type":"codeVoice"},{"type":"text","text":" parameter, specifying the number of tokens to remove from circulation."}],"type":"paragraph"}],"code":"OperationsOnFungibleTokensSection3Step2.swift","caption":[],"runtimePreview":null},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Validate that the contract holds the necessary burn role before proceeding."}]}],"code":"OperationsOnFungibleTokensSection3Step3.swift","runtimePreview":null,"media":null,"caption":[],"type":"step"},{"caption":[{"inlineContent":[{"text":"Note: The burn operation is synchronous. If the contract does not have enough tokens, the transaction is reverted.","type":"text"}],"type":"paragraph"}],"media":null,"type":"step","content":[{"inlineContent":[{"text":"Execute the burn operation, removing tokens from the contract’s balance.","type":"text"}],"type":"paragraph"}],"code":"OperationsOnFungibleTokensSection3Step4.swift","runtimePreview":null}]}],"kind":"tasks"},{"featuredEyebrow":"Tutorial","kind":"callToAction","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"action":{"overridingTitle":"Get started","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens","overridingTitleInlineContent":[{"text":"Get started","type":"text"}],"type":"reference","isActive":true},"title":"Managing Non-Fungible Tokens"}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens"},"metadata":{"category":"SpaceKit","categoryPathComponent":"SpaceKit","role":"project","title":"Managing Fungible Tokens"},"kind":"project","hierarchy":{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","modules":[{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract","kind":"task"}]}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls"}]},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards"},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens","kind":"task"}]}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes"}],"paths":[["doc:\/\/SpaceKit\/tutorials\/SpaceKit","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens"]]},"schemaVersion":{"patch":0,"major":0,"minor":3},"references":{"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","url":"\/tutorials\/spacekit\/tokenattributes","estimatedTime":"15min","role":"project","type":"topic","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"title":"Enhance Your Contracts with Token Attributes","kind":"project"},"OperationsOnFungibleTokensSection1Step2.swift":{"fileName":"lib.swift","type":"file","syntax":"swift","highlights":[{"line":42},{"line":43},{"line":44},{"line":45}],"identifier":"OperationsOnFungibleTokensSection1Step2.swift","fileType":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Setting-Up-the-SpaceKit-CLI":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI","type":"section","kind":"section","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"title":"Setting Up the SpaceKit CLI","url":"\/tutorials\/spacekit\/installingtools#Setting-Up-the-SpaceKit-CLI"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens":{"url":"\/tutorials\/spacekit\/understandtokens","type":"topic","kind":"project","estimatedTime":"15min","title":"Understand the ESDT Standard","role":"project","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"text":" ","type":"text"},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Retrieving-Information-from-the-Blockchain":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","title":"Retrieving Information from the Blockchain","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/retrieving-information-from-the-blockchain","abstract":[],"role":"article","kind":"article","type":"topic"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","type":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"kind":"section","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Fungible-Token-from-Your-Contract","title":"Issuing a Fungible Token from Your Contract"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract":{"title":"Issuing a Meta ESDT from Your Contract","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Meta-ESDT-from-Your-Contract","role":"pseudoSymbol","type":"section","kind":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"text":" ","type":"text"},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage":{"kind":"section","title":"Leveraging @Mapping for Dynamic Key-Value Storage","type":"section","url":"\/tutorials\/spacekit\/storevalues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Create-a-New-Nonce":{"kind":"section","title":"Create a New Nonce","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Create-a-New-Nonce","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"role":"pseudoSymbol","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Interacting-with-Other-Contracts":{"url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/interacting-with-other-contracts","role":"article","kind":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","abstract":[],"type":"topic","title":"Interacting with Other Contracts"},"doc://SpaceKit/tutorials/SpaceKit":{"abstract":[{"text":"Discover how SpaceKit simplifies blockchain development using Swift. Dive into the world of Web3 with ease and efficiency.","type":"text"}],"role":"overview","type":"topic","kind":"overview","title":"Meet SpaceKit","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","url":"\/tutorials\/spacekit"},"OperationsOnFungibleTokensSection2Step4.swift":{"content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func mintTokens(mintAmount: BigUint) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .mint) else {","            smartContractError(message: \"Cannot mint tokens\")","        }","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","syntax":"swift","highlights":[{"line":68},{"line":69},{"line":70}],"fileType":"swift","fileName":"lib.swift","identifier":"OperationsOnFungibleTokensSection2Step4.swift"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues":{"abstract":[{"text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory.","type":"text"}],"role":"project","kind":"project","url":"\/tutorials\/spacekit\/storevalues","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues","title":"Persist Values Between Executions","type":"topic","estimatedTime":"15min"},"OperationsOnFungibleTokensSection3Step2.swift":{"fileName":"lib.swift","type":"file","syntax":"swift","highlights":[{"line":87},{"line":88},{"line":89},{"line":90}],"identifier":"OperationsOnFungibleTokensSection3Step2.swift","fileType":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func mintTokens(mintAmount: BigUint) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .mint) else {","            smartContractError(message: \"Cannot mint tokens\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: mintAmount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: mintAmount","            )","    }","    ","    public func burnTokens(burnAmount: BigUint) {","        assertOwner()","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Burn-Tokens":{"kind":"section","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Burn-Tokens","title":"Burn Tokens","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"role":"pseudoSymbol","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Installing-SpaceKits-Dependencies":{"kind":"section","title":"Installing SpaceKit's Dependencies","type":"section","url":"\/tutorials\/spacekit\/installingtools#Installing-SpaceKits-Dependencies","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}]},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Building-Your-First-Smart-Contract":{"role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","type":"topic","abstract":[],"kind":"article","url":"\/tutorials\/spacekit\/getting-started\/building-your-first-smart-contract","title":"Building Your First Smart Contract"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Non-Fungible-Tokens":{"kind":"article","title":"Managing Non-Fungible Tokens","type":"topic","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-non-fungible-tokens","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Burn-Tokens":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Burn-Tokens","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"type":"section","title":"Burn Tokens"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Assign-Create-AddQuantity-and-Burn-Roles","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"type":"section","title":"Assign Create, AddQuantity, and Burn Roles"},"OperationsOnFungibleTokensSection2Step1.swift":{"content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","syntax":"swift","highlights":[],"fileType":"swift","fileName":"lib.swift","identifier":"OperationsOnFungibleTokensSection2Step1.swift"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls":{"kind":"project","role":"project","url":"\/tutorials\/spacekit\/asynccalls","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","title":"Interacting with Contracts Across Shards","estimatedTime":"15min","type":"topic"},"OperationsOnFungibleTokensSection3Step4.swift":{"fileName":"lib.swift","type":"file","syntax":"swift","highlights":[{"line":95},{"line":96},{"line":97},{"line":98},{"line":99},{"line":100},{"line":101}],"identifier":"OperationsOnFungibleTokensSection3Step4.swift","fileType":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func mintTokens(mintAmount: BigUint) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .mint) else {","            smartContractError(message: \"Cannot mint tokens\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: mintAmount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: mintAmount","            )","    }","    ","    public func burnTokens(burnAmount: BigUint) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .burn) else {","            smartContractError(message: \"Cannot mint tokens\")","        }","        ","        Blockchain","            .burnTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: burnAmount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/familiarizewithtypes#Handling-Heap-Allocation-Challenges","type":"section","kind":"section","title":"Handling Heap Allocation Challenges"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Enhancing-Contracts-with-Token-Attributes":{"kind":"article","title":"Enhancing Contracts with Token Attributes","type":"topic","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/enhancing-contracts-with-token-attributes","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Installing-the-Tools":{"kind":"article","title":"Installing the Tools","type":"topic","url":"\/tutorials\/spacekit\/getting-started\/installing-the-tools","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Declare-the-Callee-Proxy":{"kind":"section","title":"Declare the Callee Proxy","type":"section","url":"\/tutorials\/spacekit\/synccalls#Declare-the-Callee-Proxy","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}]},"OperationsOnFungibleTokensSection3Step1.swift":{"content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func mintTokens(mintAmount: BigUint) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .mint) else {","            smartContractError(message: \"Cannot mint tokens\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: mintAmount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: mintAmount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","syntax":"swift","highlights":[],"fileType":"swift","fileName":"lib.swift","identifier":"OperationsOnFungibleTokensSection3Step1.swift"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Understanding-the-Buffer-Type":{"abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","type":"section","title":"Understanding the Buffer Type","kind":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Understanding-the-Buffer-Type","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Working-with-Storage-for-Single-Value-Persistence":{"url":"\/tutorials\/spacekit\/storevalues#Working-with-Storage-for-Single-Value-Persistence","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"type":"section","title":"Working with @Storage for Single Value Persistence"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Declare-the-Callee-Proxy":{"url":"\/tutorials\/spacekit\/asynccalls#Declare-the-Callee-Proxy","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"type":"section","title":"Declare the Callee Proxy"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Blockchain-Context-Data":{"kind":"section","title":"Accessing Blockchain Context Data","type":"section","url":"\/tutorials\/spacekit\/getinfo#Accessing-Blockchain-Context-Data","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}]},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Transaction-Context-Data":{"kind":"section","title":"Accessing Transaction Context Data","type":"section","url":"\/tutorials\/spacekit\/getinfo#Accessing-Transaction-Context-Data","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}]},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint":{"role":"pseudoSymbol","title":"Implementing the changeTokenLockDuration Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint","kind":"section","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"type":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-changeTokenLockDuration-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","title":"Issuing a Semi-Fungible Token from Your Contract","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","kind":"section","type":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","url":"\/tutorials\/spacekit\/operationsonfungibletokens","estimatedTime":"15min","role":"project","type":"topic","abstract":[{"text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with.","type":"text"}],"title":"Managing Fungible Tokens","kind":"project"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens","role":"project","title":"Managing Non-Fungible Tokens","estimatedTime":"15min","type":"topic","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"},"OperationsOnFungibleTokensSection2Step2.swift":{"fileName":"lib.swift","type":"file","syntax":"swift","highlights":[{"line":63},{"line":64},{"line":65},{"line":66}],"identifier":"OperationsOnFungibleTokensSection2Step2.swift","fileType":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func mintTokens(mintAmount: BigUint) {","        assertOwner()","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Persisting-Data-Across-Executions":{"url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/persisting-data-across-executions","role":"article","kind":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","abstract":[],"type":"topic","title":"Persisting Data Across Executions"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Assign-Mint-and-Burn-Roles","type":"section","kind":"section","title":"Assign Mint and Burn Roles"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Perform-a-Synchronous-Call":{"abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","type":"section","title":"Perform a Synchronous Call","url":"\/tutorials\/spacekit\/synccalls#Perform-a-Synchronous-Call","role":"pseudoSymbol","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Creating-Your-Own-Types":{"kind":"section","title":"Creating Your Own Types","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Creating-Your-Own-Types","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}]},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Calling-Contracts-Across-Shards":{"kind":"article","title":"Calling Contracts Across Shards","type":"topic","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/calling-contracts-across-shards","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-unlockFunds-Endpoint":{"title":"Implementing the unlockFunds Endpoint","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-unlockFunds-Endpoint","role":"pseudoSymbol","type":"section","kind":"section","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint"},"OperationsOnFungibleTokensSection1Step5.swift":{"content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","syntax":"swift","highlights":[{"line":58},{"line":59},{"line":60}],"fileType":"swift","fileName":"lib.swift","identifier":"OperationsOnFungibleTokensSection1Step5.swift"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls":{"url":"\/tutorials\/spacekit\/synccalls","role":"project","title":"Interact with Other Contracts","estimatedTime":"15min","type":"topic","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}],"kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Add-Quantity-to-an-Existing-Nonce","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce","type":"section","kind":"section","title":"Add Quantity to an Existing Nonce","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract":{"abstract":[{"text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions.","type":"text"}],"role":"project","kind":"project","url":"\/tutorials\/spacekit\/codingyourfirstcontract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract","title":"Building Your First Smart Contract","type":"topic","estimatedTime":"20min"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Perform-an-Asynchronous-Call":{"url":"\/tutorials\/spacekit\/asynccalls#Perform-an-Asynchronous-Call","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"type":"section","title":"Perform an Asynchronous Call"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Mint-New-Tokens":{"kind":"section","title":"Mint New Tokens","type":"section","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Mint-New-Tokens","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}]},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools":{"estimatedTime":"10min","abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"title":"Install the Necessary Tools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","role":"project","url":"\/tutorials\/spacekit\/installingtools","type":"topic","kind":"project"},"OperationsOnFungibleTokensSection1Step3.swift":{"fileName":"lib.swift","type":"file","syntax":"swift","highlights":[{"line":44},{"line":45},{"line":46},{"line":47}],"identifier":"OperationsOnFungibleTokensSection1Step3.swift","fileType":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-lockFunds-Endpoint":{"kind":"section","title":"Implementing the lockFunds Endpoint","type":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-lockFunds-Endpoint","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}]},"OperationsOnFungibleTokensSection2Step5.swift":{"content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func mintTokens(mintAmount: BigUint) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .mint) else {","            smartContractError(message: \"Cannot mint tokens\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: mintAmount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","syntax":"swift","highlights":[{"line":71},{"line":72},{"line":73},{"line":74},{"line":75},{"line":76},{"line":77}],"fileType":"swift","fileName":"lib.swift","identifier":"OperationsOnFungibleTokensSection2Step5.swift"},"OperationsOnFungibleTokensSection2Step3.swift":{"fileName":"lib.swift","type":"file","syntax":"swift","highlights":[{"line":65},{"line":66},{"line":67}],"identifier":"OperationsOnFungibleTokensSection2Step3.swift","fileType":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func mintTokens(mintAmount: BigUint) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes":{"url":"\/tutorials\/spacekit\/familiarizewithtypes","role":"project","title":"Exploring SpaceKit's Types","estimatedTime":"20min","type":"topic","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes"},"OperationsOnFungibleTokensSection3Step3.swift":{"content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func mintTokens(mintAmount: BigUint) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .mint) else {","            smartContractError(message: \"Cannot mint tokens\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: mintAmount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: mintAmount","            )","    }","    ","    public func burnTokens(burnAmount: BigUint) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .burn) else {","            smartContractError(message: \"Cannot mint tokens\")","        }","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","syntax":"swift","highlights":[{"line":89},{"line":90},{"line":91},{"line":92},{"line":93},{"line":94}],"fileType":"swift","fileName":"lib.swift","identifier":"OperationsOnFungibleTokensSection3Step3.swift"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-Vector-Type":{"kind":"section","title":"Working with the Vector Type","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-Vector-Type","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}]},"doc://SpaceKit/tutorials/SpaceKit/GetInfo":{"url":"\/tutorials\/spacekit\/getinfo","role":"project","title":"Retrieving Information from the Blockchain","estimatedTime":"10min","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"type":"topic","kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Fungible-Tokens":{"kind":"article","title":"Managing Fungible Tokens","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-fungible-tokens","abstract":[],"role":"article","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Creating-and-Understanding-Tokens":{"role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","type":"topic","abstract":[],"kind":"article","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/creating-and-understanding-tokens","title":"Creating and Understanding Tokens"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract":{"kind":"section","title":"Initializing and Compiling Your First Smart Contract","type":"section","url":"\/tutorials\/spacekit\/installingtools#Initializing-and-Compiling-Your-First-Smart-Contract","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}]},"OperationsOnFungibleTokensSection2Step6.swift":{"fileName":"lib.swift","type":"file","syntax":"swift","highlights":[{"line":78},{"line":79},{"line":80},{"line":81},{"line":82},{"line":83},{"line":84}],"identifier":"OperationsOnFungibleTokensSection2Step6.swift","fileType":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func mintTokens(mintAmount: BigUint) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .mint) else {","            smartContractError(message: \"Cannot mint tokens\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: mintAmount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: 0,","                amount: mintAmount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Writing-the-Contract-Code":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","title":"Writing the Contract Code","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Writing-the-Contract-Code","kind":"section","type":"section","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}]},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Testing-the-Contract":{"abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract","type":"section","title":"Testing the Contract","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Testing-the-Contract","role":"pseudoSymbol","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Initializing-the-Project":{"kind":"section","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Initializing-the-Project","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"role":"pseudoSymbol","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","title":"Initializing the Project"},"OperationsOnFungibleTokensSection1Step4.swift":{"content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setMintAndBurnRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canMint: true,","                    canBurn: true","                )","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","syntax":"swift","highlights":[{"line":48},{"line":49},{"line":50},{"line":51},{"line":52},{"line":53},{"line":54},{"line":55},{"line":56},{"line":57}],"fileType":"swift","fileName":"lib.swift","identifier":"OperationsOnFungibleTokensSection1Step4.swift"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-BigUint-Type":{"abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","type":"section","title":"Working with the BigUint Type","url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-BigUint-Type","role":"pseudoSymbol","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract":{"abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","type":"section","title":"Issuing a Non-Fungible Token from Your Contract","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","role":"pseudoSymbol","kind":"section"},"OperationsOnFungibleTokensSection1Step1.swift":{"fileName":"lib.swift","type":"file","syntax":"swift","highlights":[],"identifier":"OperationsOnFungibleTokensSection1Step1.swift","fileType":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Exploring-SpaceKit's-Types":{"kind":"article","title":"Exploring SpaceKit's Types","type":"topic","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/exploring-spacekit's-types","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","abstract":[]}}}
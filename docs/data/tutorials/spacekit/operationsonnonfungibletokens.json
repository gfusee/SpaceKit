{"sections":[{"kind":"hero","chapter":"Managing Non-Fungible Tokens","title":"Managing Non-Fungible Tokens","estimatedTimeInMinutes":15,"content":[{"inlineContent":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"type":"paragraph"},{"inlineContent":[{"text":"Once an NFT has been issued, new nonces can be created if the appropriate role is granted. This operation executes synchronously.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"For tokens that are semi-fungible or classified as meta-ESDTs, the supply for an existing nonce can be increased, provided the necessary role is assigned. This process, referred to as “adding quantity,” functions similarly to minting for fungible tokens and is also synchronous.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Burning tokens requires that they be designated as burnable and that the smart contract holds the burn role. A contract can only burn tokens that it owns. Like creating new nonces or increasing supply, burning is a synchronous operation.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"In this tutorial, we will focus on semi-fungible tokens.","type":"text"}]}]},{"tasks":[{"contentSection":[{"mediaPosition":"trailing","content":[{"inlineContent":[{"type":"text","text":"By default, a smart contract does not have permission to create new nonces, increase supply, or burn tokens. These roles must be explicitly granted before executing any of these actions. Assigning roles is an asynchronous operation that does not require a callback. If the token supports role management, only the token’s manager—the original issuer—can assign these roles."}],"type":"paragraph"}],"kind":"contentAndMedia"}],"stepsSection":[{"type":"step","caption":[{"inlineContent":[{"text":"The token is configured to support nonce creation, supply increases, and burning.","type":"text"}],"type":"paragraph"}],"content":[{"inlineContent":[{"type":"text","text":"Begin with the code from a previous section where we issued a semi-fungible token."}],"type":"paragraph"}],"code":"OperationsOnNonFungibleTokensSection1Step1.swift","media":null,"runtimePreview":null},{"media":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define a restricted endpoint named "},{"type":"codeVoice","code":"setRoles"},{"type":"text","text":", allowing only the contract owner to invoke it."}]}],"code":"OperationsOnNonFungibleTokensSection1Step2.swift","runtimePreview":null,"type":"step","caption":[]},{"code":"OperationsOnNonFungibleTokensSection1Step3.swift","type":"step","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Ensure that the token has already been issued before proceeding.","type":"text"}]}],"media":null,"caption":[]},{"code":"OperationsOnNonFungibleTokensSection1Step4.swift","caption":[],"runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Implement the ","type":"text"},{"code":"setTokenRoles","type":"codeVoice"},{"text":" function to assign the necessary roles.","type":"text"}]}],"media":null,"type":"step"},{"type":"step","caption":[],"content":[{"inlineContent":[{"type":"text","text":"Register a promise to initiate the asynchronous role assignment."}],"type":"paragraph"}],"runtimePreview":null,"media":null,"code":"OperationsOnNonFungibleTokensSection1Step5.swift"}],"anchor":"Assign-Create-AddQuantity-and-Burn-Roles","title":"Assign Create, AddQuantity, and Burn Roles"},{"contentSection":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"With the create role assigned, you can now generate new nonces for the token."}]}],"mediaPosition":"trailing","kind":"contentAndMedia"}],"stepsSection":[{"type":"step","content":[{"inlineContent":[{"type":"text","text":"Start from the code in the previous section."}],"type":"paragraph"}],"media":null,"code":"OperationsOnNonFungibleTokensSection2Step1.swift","caption":[],"runtimePreview":null},{"type":"step","media":null,"caption":[],"runtimePreview":null,"code":"OperationsOnNonFungibleTokensSection2Step2.swift","content":[{"inlineContent":[{"text":"Define a ","type":"text"},{"code":"createNewNonce","type":"codeVoice"},{"text":" endpoint, accessible only to the contract owner. This endpoint accepts an ","type":"text"},{"type":"codeVoice","code":"initialSupply"},{"type":"text","text":" parameter, specifying the number of tokens to create for the nonce. It returns a "},{"code":"UInt64","type":"codeVoice"},{"text":" representing the newly created nonce.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Verify that the contract holds the create role.","type":"text"}],"type":"paragraph"}],"media":null,"runtimePreview":null,"code":"OperationsOnNonFungibleTokensSection2Step3.swift","caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This ensures that "},{"code":"setTokenRoles","type":"codeVoice"},{"type":"text","text":" executed successfully and that the role assignment completed."}]}],"type":"step"},{"runtimePreview":null,"content":[{"inlineContent":[{"text":"Execute the nonce creation.","type":"text"}],"type":"paragraph"}],"type":"step","media":null,"code":"OperationsOnNonFungibleTokensSection2Step4.swift","caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This operation is synchronous. If it fails, the transaction is reverted, and the newly created tokens are immediately added to the contract’s balance."}]}]},{"type":"step","media":null,"code":"OperationsOnNonFungibleTokensSection2Step5.swift","runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"Transfer the created tokens to the endpoint caller."}],"type":"paragraph"}],"caption":[]},{"media":null,"caption":[],"code":"OperationsOnNonFungibleTokensSection2Step6.swift","runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"Return the newly created nonce."}],"type":"paragraph"}],"type":"step"}],"title":"Create a New Nonce","anchor":"Create-a-New-Nonce"},{"anchor":"Add-Quantity-to-an-Existing-Nonce","stepsSection":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use the code from the previous section as a starting point."}]}],"type":"step","caption":[],"media":null,"code":"OperationsOnNonFungibleTokensSection3Step1.swift","runtimePreview":null},{"caption":[],"runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define an "},{"code":"addQuantity","type":"codeVoice"},{"type":"text","text":" endpoint, accessible only to the contract owner. This endpoint accepts "},{"code":"nonce","type":"codeVoice"},{"type":"text","text":" and "},{"code":"amount","type":"codeVoice"},{"text":" parameters, specifying which nonce to increase and by how much.","type":"text"}]}],"type":"step","media":null,"code":"OperationsOnNonFungibleTokensSection3Step2.swift"},{"code":"OperationsOnNonFungibleTokensSection3Step3.swift","content":[{"type":"paragraph","inlineContent":[{"text":"Verify that the contract holds the necessary role.","type":"text"}]}],"media":null,"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This ensures that "},{"code":"setTokenRoles","type":"codeVoice"},{"text":" executed successfully and that the role assignment completed.","type":"text"}]}],"runtimePreview":null,"type":"step"},{"content":[{"type":"paragraph","inlineContent":[{"text":"Execute the quantity addition.","type":"text"}]}],"type":"step","code":"OperationsOnNonFungibleTokensSection3Step4.swift","runtimePreview":null,"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"SpaceKit automatically determines the appropriate function for minting fungible or increasing semi-fungible token supply."}]}],"media":null},{"media":null,"code":"OperationsOnNonFungibleTokensSection3Step5.swift","content":[{"inlineContent":[{"text":"Transfer the newly minted tokens to the caller.","type":"text"}],"type":"paragraph"}],"type":"step","runtimePreview":null,"caption":[]}],"contentSection":[{"content":[{"inlineContent":[{"type":"text","text":"After creating new tokens, you may need to increase their supply. This applies only to semi-fungible and meta-ESDT tokens, as non-fungible tokens have a fixed supply of one per nonce."}],"type":"paragraph"}],"kind":"contentAndMedia","mediaPosition":"trailing"}],"title":"Add Quantity to an Existing Nonce"},{"title":"Burn Tokens","anchor":"Burn-Tokens","contentSection":[{"content":[{"inlineContent":[{"text":"Burning tokens is the inverse of adding quantity. Now that the contract has the burn role, you can proceed with this operation.","type":"text"}],"type":"paragraph"}],"kind":"contentAndMedia","mediaPosition":"trailing"}],"stepsSection":[{"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use the code from the previous section as a foundation."}]}],"media":null,"runtimePreview":null,"caption":[],"code":"OperationsOnNonFungibleTokensSection4Step1.swift"},{"media":null,"code":"OperationsOnNonFungibleTokensSection4Step2.swift","runtimePreview":null,"caption":[],"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define a "},{"type":"codeVoice","code":"burnTokens"},{"type":"text","text":" endpoint, restricted to the contract owner. This endpoint accepts "},{"type":"codeVoice","code":"nonce"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"burnAmount"},{"type":"text","text":" parameters, specifying which nonce and how many tokens to burn."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Ensure that the contract possesses the required burn role."}],"type":"paragraph"}],"media":null,"caption":[],"type":"step","code":"OperationsOnNonFungibleTokensSection4Step3.swift","runtimePreview":null},{"code":"OperationsOnNonFungibleTokensSection4Step4.swift","caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Note: The burn operation is synchronous. If the contract does not have enough tokens, the transaction is reverted."}]}],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Execute the burn operation, removing the specified amount from the contract’s balance."}]}],"media":null,"type":"step","runtimePreview":null}]}],"kind":"tasks"},{"title":"Enhance Your Contracts with Token Attributes","featuredEyebrow":"Tutorial","kind":"callToAction","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"action":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","isActive":true,"overridingTitleInlineContent":[{"text":"Get started","type":"text"}],"type":"reference","overridingTitle":"Get started"}}],"schemaVersion":{"major":0,"patch":0,"minor":3},"kind":"project","variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/tutorials\/spacekit\/operationsonnonfungibletokens"]}],"metadata":{"category":"SpaceKit","title":"Managing Non-Fungible Tokens","categoryPathComponent":"SpaceKit","role":"project"},"identifier":{"url":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens","interfaceLanguage":"swift"},"hierarchy":{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","modules":[{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools"},{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract"},{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types"},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions"},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain"},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens"}]},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint","kind":"task"}]}]}],"paths":[["doc:\/\/SpaceKit\/tutorials\/SpaceKit","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens"]]},"references":{"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Transaction-Context-Data":{"kind":"section","title":"Accessing Transaction Context Data","type":"section","url":"\/tutorials\/spacekit\/getinfo#Accessing-Transaction-Context-Data","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}]},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract":{"kind":"section","title":"Initializing and Compiling Your First Smart Contract","type":"section","url":"\/tutorials\/spacekit\/installingtools#Initializing-and-Compiling-Your-First-Smart-Contract","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}]},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Declare-the-Callee-Proxy":{"url":"\/tutorials\/spacekit\/asynccalls#Declare-the-Callee-Proxy","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"type":"section","title":"Declare the Callee Proxy"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract":{"abstract":[{"text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions.","type":"text"}],"role":"project","kind":"project","url":"\/tutorials\/spacekit\/codingyourfirstcontract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract","title":"Building Your First Smart Contract","type":"topic","estimatedTime":"20min"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Declare-the-Callee-Proxy":{"kind":"section","title":"Declare the Callee Proxy","type":"section","url":"\/tutorials\/spacekit\/synccalls#Declare-the-Callee-Proxy","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}]},"OperationsOnNonFungibleTokensSection1Step1.swift":{"fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection1Step1.swift","syntax":"swift","type":"file","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"highlights":[],"fileType":"swift"},"OperationsOnNonFungibleTokensSection2Step6.swift":{"identifier":"OperationsOnNonFungibleTokensSection2Step6.swift","highlights":[{"line":87},{"line":88}],"fileName":"lib.swift","syntax":"swift","type":"file","fileType":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract":{"abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","type":"section","title":"Issuing a Non-Fungible Token from Your Contract","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","role":"pseudoSymbol","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Installing-the-Tools":{"kind":"article","title":"Installing the Tools","type":"topic","url":"\/tutorials\/spacekit\/getting-started\/installing-the-tools","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Understanding-the-Buffer-Type":{"abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","type":"section","title":"Understanding the Buffer Type","kind":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Understanding-the-Buffer-Type","role":"pseudoSymbol"},"OperationsOnNonFungibleTokensSection4Step2.swift":{"fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection4Step2.swift","syntax":"swift","type":"file","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    public func burnTokens(","        nonce: UInt64,","        burnAmount: BigUint","    ) {","        assertOwner()","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"highlights":[{"line":118},{"line":119},{"line":120},{"line":121},{"line":122},{"line":123},{"line":124}],"fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Burn-Tokens":{"kind":"section","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Burn-Tokens","title":"Burn Tokens","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"role":"pseudoSymbol","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Exploring-SpaceKit's-Types":{"kind":"article","title":"Exploring SpaceKit's Types","type":"topic","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/exploring-spacekit's-types","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint":{"role":"pseudoSymbol","title":"Implementing the changeTokenLockDuration Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint","kind":"section","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"type":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-changeTokenLockDuration-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Writing-the-Contract-Code":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","title":"Writing the Contract Code","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Writing-the-Contract-Code","kind":"section","type":"section","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}]},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools":{"estimatedTime":"10min","abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"title":"Install the Necessary Tools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","role":"project","url":"\/tutorials\/spacekit\/installingtools","type":"topic","kind":"project"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Enhancing-Contracts-with-Token-Attributes":{"kind":"article","title":"Enhancing Contracts with Token Attributes","type":"topic","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/enhancing-contracts-with-token-attributes","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Fungible-Tokens":{"kind":"article","title":"Managing Fungible Tokens","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-fungible-tokens","abstract":[],"role":"article","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Add-Quantity-to-an-Existing-Nonce","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce","type":"section","kind":"section","title":"Add Quantity to an Existing Nonce","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-BigUint-Type":{"abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","type":"section","title":"Working with the BigUint Type","url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-BigUint-Type","role":"pseudoSymbol","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls":{"kind":"project","role":"project","url":"\/tutorials\/spacekit\/asynccalls","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","title":"Interacting with Contracts Across Shards","estimatedTime":"15min","type":"topic"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-unlockFunds-Endpoint":{"title":"Implementing the unlockFunds Endpoint","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-unlockFunds-Endpoint","role":"pseudoSymbol","type":"section","kind":"section","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues":{"abstract":[{"text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory.","type":"text"}],"role":"project","kind":"project","url":"\/tutorials\/spacekit\/storevalues","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues","title":"Persist Values Between Executions","type":"topic","estimatedTime":"15min"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Mint-New-Tokens":{"kind":"section","title":"Mint New Tokens","type":"section","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Mint-New-Tokens","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}]},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Creating-and-Understanding-Tokens":{"role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","type":"topic","abstract":[],"kind":"article","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/creating-and-understanding-tokens","title":"Creating and Understanding Tokens"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo":{"url":"\/tutorials\/spacekit\/getinfo","role":"project","title":"Retrieving Information from the Blockchain","estimatedTime":"10min","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"type":"topic","kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Interacting-with-Other-Contracts":{"url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/interacting-with-other-contracts","role":"article","kind":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","abstract":[],"type":"topic","title":"Interacting with Other Contracts"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage":{"kind":"section","title":"Leveraging @Mapping for Dynamic Key-Value Storage","type":"section","url":"\/tutorials\/spacekit\/storevalues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}]},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Persisting-Data-Across-Executions":{"url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/persisting-data-across-executions","role":"article","kind":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","abstract":[],"type":"topic","title":"Persisting Data Across Executions"},"OperationsOnNonFungibleTokensSection3Step2.swift":{"identifier":"OperationsOnNonFungibleTokensSection3Step2.swift","highlights":[{"line":91},{"line":92},{"line":93},{"line":94},{"line":95},{"line":96},{"line":97}],"fileName":"lib.swift","syntax":"swift","type":"file","fileType":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Blockchain-Context-Data":{"kind":"section","title":"Accessing Blockchain Context Data","type":"section","url":"\/tutorials\/spacekit\/getinfo#Accessing-Blockchain-Context-Data","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}]},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-lockFunds-Endpoint":{"kind":"section","title":"Implementing the lockFunds Endpoint","type":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-lockFunds-Endpoint","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}]},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Perform-a-Synchronous-Call":{"abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","type":"section","title":"Perform a Synchronous Call","url":"\/tutorials\/spacekit\/synccalls#Perform-a-Synchronous-Call","role":"pseudoSymbol","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Installing-SpaceKits-Dependencies":{"kind":"section","title":"Installing SpaceKit's Dependencies","type":"section","url":"\/tutorials\/spacekit\/installingtools#Installing-SpaceKits-Dependencies","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}]},"OperationsOnNonFungibleTokensSection4Step3.swift":{"fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection4Step3.swift","syntax":"swift","type":"file","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    public func burnTokens(","        nonce: UInt64,","        burnAmount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn tokens\")","        }","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"highlights":[{"line":123},{"line":124},{"line":125},{"line":126},{"line":127},{"line":128}],"fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Burn-Tokens":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Burn-Tokens","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"type":"section","title":"Burn Tokens"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes":{"url":"\/tutorials\/spacekit\/familiarizewithtypes","role":"project","title":"Exploring SpaceKit's Types","estimatedTime":"20min","type":"topic","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Create-a-New-Nonce":{"kind":"section","title":"Create a New Nonce","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Create-a-New-Nonce","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"role":"pseudoSymbol","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Non-Fungible-Tokens":{"kind":"article","title":"Managing Non-Fungible Tokens","type":"topic","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-non-fungible-tokens","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","abstract":[]},"OperationsOnNonFungibleTokensSection3Step5.swift":{"fileName":"lib.swift","fileType":"swift","identifier":"OperationsOnNonFungibleTokensSection3Step5.swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","syntax":"swift","highlights":[{"line":109},{"line":110},{"line":111},{"line":112},{"line":113},{"line":114},{"line":115}]},"OperationsOnNonFungibleTokensSection1Step5.swift":{"highlights":[{"line":56},{"line":57},{"line":58}],"fileName":"lib.swift","type":"file","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"identifier":"OperationsOnNonFungibleTokensSection1Step5.swift","fileType":"swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","url":"\/tutorials\/spacekit\/tokenattributes","estimatedTime":"15min","role":"project","type":"topic","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"title":"Enhance Your Contracts with Token Attributes","kind":"project"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Perform-an-Asynchronous-Call":{"url":"\/tutorials\/spacekit\/asynccalls#Perform-an-Asynchronous-Call","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"type":"section","title":"Perform an Asynchronous Call"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens":{"url":"\/tutorials\/spacekit\/understandtokens","type":"topic","kind":"project","estimatedTime":"15min","title":"Understand the ESDT Standard","role":"project","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"text":" ","type":"text"},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","type":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"kind":"section","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Fungible-Token-from-Your-Contract","title":"Issuing a Fungible Token from Your Contract"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Setting-Up-the-SpaceKit-CLI":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI","type":"section","kind":"section","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"title":"Setting Up the SpaceKit CLI","url":"\/tutorials\/spacekit\/installingtools#Setting-Up-the-SpaceKit-CLI"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens","role":"project","title":"Managing Non-Fungible Tokens","estimatedTime":"15min","type":"topic","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Calling-Contracts-Across-Shards":{"kind":"article","title":"Calling Contracts Across Shards","type":"topic","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/calling-contracts-across-shards","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract":{"title":"Issuing a Meta ESDT from Your Contract","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Meta-ESDT-from-Your-Contract","role":"pseudoSymbol","type":"section","kind":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"text":" ","type":"text"},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract"},"OperationsOnNonFungibleTokensSection1Step3.swift":{"fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection1Step3.swift","fileType":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","syntax":"swift","highlights":[{"line":41},{"line":42},{"line":43},{"line":44}]},"OperationsOnNonFungibleTokensSection1Step4.swift":{"highlights":[{"line":45},{"line":46},{"line":47},{"line":48},{"line":49},{"line":50},{"line":51},{"line":52},{"line":53},{"line":54},{"line":55}],"type":"file","identifier":"OperationsOnNonFungibleTokensSection1Step4.swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileName":"lib.swift","fileType":"swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Assign-Mint-and-Burn-Roles","type":"section","kind":"section","title":"Assign Mint and Burn Roles"},"OperationsOnNonFungibleTokensSection3Step4.swift":{"fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection3Step4.swift","fileType":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","syntax":"swift","highlights":[{"line":102},{"line":103},{"line":104},{"line":105},{"line":106},{"line":107},{"line":108}]},"doc://SpaceKit/tutorials/SpaceKit":{"abstract":[{"text":"Discover how SpaceKit simplifies blockchain development using Swift. Dive into the world of Web3 with ease and efficiency.","type":"text"}],"role":"overview","type":"topic","kind":"overview","title":"Meet SpaceKit","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","url":"\/tutorials\/spacekit"},"OperationsOnNonFungibleTokensSection2Step4.swift":{"highlights":[{"line":69},{"line":70},{"line":71},{"line":72},{"line":73},{"line":74},{"line":75},{"line":76},{"line":77},{"line":78},{"line":79}],"type":"file","identifier":"OperationsOnNonFungibleTokensSection2Step4.swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileName":"lib.swift","fileType":"swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Assign-Create-AddQuantity-and-Burn-Roles","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"type":"section","title":"Assign Create, AddQuantity, and Burn Roles"},"OperationsOnNonFungibleTokensSection4Step1.swift":{"type":"file","highlights":[],"content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileType":"swift","syntax":"swift","fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection4Step1.swift"},"OperationsOnNonFungibleTokensSection3Step3.swift":{"highlights":[{"line":96},{"line":97},{"line":98},{"line":99},{"line":100},{"line":101}],"type":"file","identifier":"OperationsOnNonFungibleTokensSection3Step3.swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileName":"lib.swift","fileType":"swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-Vector-Type":{"kind":"section","title":"Working with the Vector Type","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-Vector-Type","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}]},"OperationsOnNonFungibleTokensSection2Step2.swift":{"type":"file","highlights":[{"line":61},{"line":62},{"line":63},{"line":64}],"content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileType":"swift","syntax":"swift","fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection2Step2.swift"},"OperationsOnNonFungibleTokensSection2Step1.swift":{"highlights":[],"type":"file","identifier":"OperationsOnNonFungibleTokensSection2Step1.swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileName":"lib.swift","fileType":"swift","syntax":"swift"},"OperationsOnNonFungibleTokensSection2Step3.swift":{"type":"file","highlights":[{"line":63},{"line":64},{"line":65},{"line":66},{"line":67},{"line":68}],"content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileType":"swift","syntax":"swift","fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection2Step3.swift"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Retrieving-Information-from-the-Blockchain":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","title":"Retrieving Information from the Blockchain","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/retrieving-information-from-the-blockchain","abstract":[],"role":"article","kind":"article","type":"topic"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Creating-Your-Own-Types":{"kind":"section","title":"Creating Your Own Types","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Creating-Your-Own-Types","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}]},"OperationsOnNonFungibleTokensSection3Step1.swift":{"highlights":[],"type":"file","identifier":"OperationsOnNonFungibleTokensSection3Step1.swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileName":"lib.swift","fileType":"swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Working-with-Storage-for-Single-Value-Persistence":{"url":"\/tutorials\/spacekit\/storevalues#Working-with-Storage-for-Single-Value-Persistence","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"type":"section","title":"Working with @Storage for Single Value Persistence"},"OperationsOnNonFungibleTokensSection4Step4.swift":{"type":"file","highlights":[{"line":129},{"line":130},{"line":131},{"line":132},{"line":133},{"line":134},{"line":135}],"content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    public func burnTokens(","        nonce: UInt64,","        burnAmount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn tokens\")","        }","        ","        Blockchain","            .burnTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: burnAmount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileType":"swift","syntax":"swift","fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection4Step4.swift"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Building-Your-First-Smart-Contract":{"role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","type":"topic","abstract":[],"kind":"article","url":"\/tutorials\/spacekit\/getting-started\/building-your-first-smart-contract","title":"Building Your First Smart Contract"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","title":"Issuing a Semi-Fungible Token from Your Contract","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","kind":"section","type":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/familiarizewithtypes#Handling-Heap-Allocation-Challenges","type":"section","kind":"section","title":"Handling Heap Allocation Challenges"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","url":"\/tutorials\/spacekit\/operationsonfungibletokens","estimatedTime":"15min","role":"project","type":"topic","abstract":[{"text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with.","type":"text"}],"title":"Managing Fungible Tokens","kind":"project"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Testing-the-Contract":{"abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract","type":"section","title":"Testing the Contract","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Testing-the-Contract","role":"pseudoSymbol","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls":{"url":"\/tutorials\/spacekit\/synccalls","role":"project","title":"Interact with Other Contracts","estimatedTime":"15min","type":"topic","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}],"kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls"},"OperationsOnNonFungibleTokensSection2Step5.swift":{"highlights":[{"line":80},{"line":81},{"line":82},{"line":83},{"line":84},{"line":85},{"line":86}],"type":"file","identifier":"OperationsOnNonFungibleTokensSection2Step5.swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileName":"lib.swift","fileType":"swift","syntax":"swift"},"OperationsOnNonFungibleTokensSection1Step2.swift":{"type":"file","highlights":[{"line":39},{"line":40},{"line":41},{"line":42}],"content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileType":"swift","syntax":"swift","fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection1Step2.swift"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Initializing-the-Project":{"kind":"section","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Initializing-the-Project","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"role":"pseudoSymbol","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","title":"Initializing the Project"}}}
{"kind":"project","schemaVersion":{"major":0,"patch":0,"minor":3},"hierarchy":{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","paths":[["doc:\/\/SpaceKit\/tutorials\/SpaceKit","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens"]],"modules":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract","kind":"task"}]}]},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types"}]}]},{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions"},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain"},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","kind":"task"}]}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens"},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes"}]},"metadata":{"role":"project","categoryPathComponent":"SpaceKit","title":"Managing Non-Fungible Tokens","category":"SpaceKit"},"sections":[{"kind":"hero","title":"Managing Non-Fungible Tokens","chapter":"Managing Non-Fungible Tokens","estimatedTimeInMinutes":15,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}]},{"inlineContent":[{"type":"text","text":"Once an NFT has been issued, new nonces can be created if the appropriate role is granted. This operation executes synchronously."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For tokens that are semi-fungible or classified as meta-ESDTs, the supply for an existing nonce can be increased, provided the necessary role is assigned. This process, referred to as “adding quantity,” functions similarly to minting for fungible tokens and is also synchronous."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Burning tokens requires that they be designated as burnable and that the smart contract holds the burn role. A contract can only burn tokens that it owns. Like creating new nonces or increasing supply, burning is a synchronous operation."}]},{"type":"paragraph","inlineContent":[{"text":"In this tutorial, we will focus on semi-fungible tokens.","type":"text"}]}]},{"tasks":[{"title":"Assign Create, AddQuantity, and Burn Roles","anchor":"Assign-Create-AddQuantity-and-Burn-Roles","contentSection":[{"kind":"contentAndMedia","mediaPosition":"trailing","content":[{"type":"paragraph","inlineContent":[{"text":"By default, a smart contract does not have permission to create new nonces, increase supply, or burn tokens. These roles must be explicitly granted before executing any of these actions. Assigning roles is an asynchronous operation that does not require a callback. If the token supports role management, only the token’s manager—the original issuer—can assign these roles.","type":"text"}]}]}],"stepsSection":[{"type":"step","media":null,"code":"OperationsOnNonFungibleTokensSection1Step1.swift","runtimePreview":null,"caption":[{"inlineContent":[{"text":"The token is configured to support nonce creation, supply increases, and burning.","type":"text"}],"type":"paragraph"}],"content":[{"type":"paragraph","inlineContent":[{"text":"Begin with the code from a previous section where we issued a semi-fungible token.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Define a restricted endpoint named ","type":"text"},{"type":"codeVoice","code":"setRoles"},{"text":", allowing only the contract owner to invoke it.","type":"text"}],"type":"paragraph"}],"caption":[],"type":"step","media":null,"code":"OperationsOnNonFungibleTokensSection1Step2.swift","runtimePreview":null},{"media":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Ensure that the token has already been issued before proceeding.","type":"text"}]}],"type":"step","caption":[],"code":"OperationsOnNonFungibleTokensSection1Step3.swift","runtimePreview":null},{"content":[{"inlineContent":[{"type":"text","text":"Implement the "},{"type":"codeVoice","code":"setTokenRoles"},{"type":"text","text":" function to assign the necessary roles."}],"type":"paragraph"}],"runtimePreview":null,"caption":[],"type":"step","media":null,"code":"OperationsOnNonFungibleTokensSection1Step4.swift"},{"type":"step","code":"OperationsOnNonFungibleTokensSection1Step5.swift","media":null,"caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Register a promise to initiate the asynchronous role assignment."}]}],"runtimePreview":null}]},{"anchor":"Create-a-New-Nonce","contentSection":[{"mediaPosition":"trailing","kind":"contentAndMedia","content":[{"inlineContent":[{"type":"text","text":"With the create role assigned, you can now generate new nonces for the token."}],"type":"paragraph"}]}],"stepsSection":[{"code":"OperationsOnNonFungibleTokensSection2Step1.swift","type":"step","media":null,"caption":[],"runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"Start from the code in the previous section."}],"type":"paragraph"}]},{"code":"OperationsOnNonFungibleTokensSection2Step2.swift","caption":[],"content":[{"inlineContent":[{"type":"text","text":"Define a "},{"type":"codeVoice","code":"createNewNonce"},{"type":"text","text":" endpoint, accessible only to the contract owner. This endpoint accepts an "},{"type":"codeVoice","code":"initialSupply"},{"text":" parameter, specifying the number of tokens to create for the nonce. It returns a ","type":"text"},{"type":"codeVoice","code":"UInt64"},{"type":"text","text":" representing the newly created nonce."}],"type":"paragraph"}],"media":null,"runtimePreview":null,"type":"step"},{"type":"step","code":"OperationsOnNonFungibleTokensSection2Step3.swift","caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This ensures that "},{"code":"setTokenRoles","type":"codeVoice"},{"text":" executed successfully and that the role assignment completed.","type":"text"}]}],"runtimePreview":null,"media":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Verify that the contract holds the create role.","type":"text"}]}]},{"media":null,"content":[{"inlineContent":[{"type":"text","text":"Execute the nonce creation."}],"type":"paragraph"}],"runtimePreview":null,"caption":[{"type":"paragraph","inlineContent":[{"text":"This operation is synchronous. If it fails, the transaction is reverted, and the newly created tokens are immediately added to the contract’s balance.","type":"text"}]}],"type":"step","code":"OperationsOnNonFungibleTokensSection2Step4.swift"},{"media":null,"code":"OperationsOnNonFungibleTokensSection2Step5.swift","runtimePreview":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"Transfer the created tokens to the endpoint caller."}],"type":"paragraph"}],"caption":[]},{"type":"step","media":null,"code":"OperationsOnNonFungibleTokensSection2Step6.swift","content":[{"type":"paragraph","inlineContent":[{"text":"Return the newly created nonce.","type":"text"}]}],"caption":[],"runtimePreview":null}],"title":"Create a New Nonce"},{"title":"Add Quantity to an Existing Nonce","contentSection":[{"content":[{"type":"paragraph","inlineContent":[{"text":"After creating new tokens, you may need to increase their supply. This applies only to semi-fungible and meta-ESDT tokens, as non-fungible tokens have a fixed supply of one per nonce.","type":"text"}]}],"mediaPosition":"trailing","kind":"contentAndMedia"}],"anchor":"Add-Quantity-to-an-Existing-Nonce","stepsSection":[{"type":"step","media":null,"code":"OperationsOnNonFungibleTokensSection3Step1.swift","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use the code from the previous section as a starting point."}]}],"caption":[]},{"runtimePreview":null,"caption":[],"type":"step","code":"OperationsOnNonFungibleTokensSection3Step2.swift","media":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Define an ","type":"text"},{"type":"codeVoice","code":"addQuantity"},{"type":"text","text":" endpoint, accessible only to the contract owner. This endpoint accepts "},{"type":"codeVoice","code":"nonce"},{"text":" and ","type":"text"},{"code":"amount","type":"codeVoice"},{"type":"text","text":" parameters, specifying which nonce to increase and by how much."}]}]},{"runtimePreview":null,"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This ensures that "},{"type":"codeVoice","code":"setTokenRoles"},{"type":"text","text":" executed successfully and that the role assignment completed."}]}],"code":"OperationsOnNonFungibleTokensSection3Step3.swift","type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Verify that the contract holds the necessary role."}]}],"media":null},{"content":[{"inlineContent":[{"text":"Execute the quantity addition.","type":"text"}],"type":"paragraph"}],"type":"step","media":null,"caption":[{"type":"paragraph","inlineContent":[{"text":"SpaceKit automatically determines the appropriate function for minting fungible or increasing semi-fungible token supply.","type":"text"}]}],"code":"OperationsOnNonFungibleTokensSection3Step4.swift","runtimePreview":null},{"code":"OperationsOnNonFungibleTokensSection3Step5.swift","type":"step","caption":[],"runtimePreview":null,"media":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Transfer the newly minted tokens to the caller."}]}]}]},{"stepsSection":[{"code":"OperationsOnNonFungibleTokensSection4Step1.swift","runtimePreview":null,"caption":[],"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Use the code from the previous section as a foundation.","type":"text"}]}],"media":null},{"code":"OperationsOnNonFungibleTokensSection4Step2.swift","type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define a "},{"type":"codeVoice","code":"burnTokens"},{"type":"text","text":" endpoint, restricted to the contract owner. This endpoint accepts "},{"type":"codeVoice","code":"nonce"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"burnAmount"},{"type":"text","text":" parameters, specifying which nonce and how many tokens to burn."}]}],"runtimePreview":null,"caption":[],"media":null},{"code":"OperationsOnNonFungibleTokensSection4Step3.swift","media":null,"caption":[],"content":[{"type":"paragraph","inlineContent":[{"text":"Ensure that the contract possesses the required burn role.","type":"text"}]}],"type":"step","runtimePreview":null},{"runtimePreview":null,"caption":[{"inlineContent":[{"text":"Note: The burn operation is synchronous. If the contract does not have enough tokens, the transaction is reverted.","type":"text"}],"type":"paragraph"}],"type":"step","media":null,"code":"OperationsOnNonFungibleTokensSection4Step4.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Execute the burn operation, removing the specified amount from the contract’s balance."}]}]}],"title":"Burn Tokens","contentSection":[{"kind":"contentAndMedia","content":[{"inlineContent":[{"type":"text","text":"Burning tokens is the inverse of adding quantity. Now that the contract has the burn role, you can proceed with this operation."}],"type":"paragraph"}],"mediaPosition":"trailing"}],"anchor":"Burn-Tokens"}],"kind":"tasks"},{"action":{"overridingTitle":"Get started","overridingTitleInlineContent":[{"text":"Get started","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","type":"reference","isActive":true},"abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"kind":"callToAction","title":"Enhance Your Contracts with Token Attributes","featuredEyebrow":"Tutorial"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/tutorials\/spacekit\/operationsonnonfungibletokens"]}],"identifier":{"url":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens","interfaceLanguage":"swift"},"references":{"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Burn-Tokens":{"url":"\/tutorials\/spacekit\/operationsonfungibletokens#Burn-Tokens","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","role":"pseudoSymbol","abstract":[{"text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with.","type":"text"}],"title":"Burn Tokens"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","title":"Interacting with Contracts Across Shards","abstract":[{"text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources.","type":"text"}],"type":"topic","estimatedTime":"15min","role":"project","url":"\/tutorials\/spacekit\/asynccalls","kind":"project"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Declare-the-Callee-Proxy":{"type":"section","url":"\/tutorials\/spacekit\/asynccalls#Declare-the-Callee-Proxy","abstract":[{"text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources.","type":"text"}],"title":"Declare the Callee Proxy","kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Installing-SpaceKits-Dependencies":{"role":"pseudoSymbol","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","kind":"section","url":"\/tutorials\/spacekit\/installingtools#Installing-SpaceKits-Dependencies","title":"Installing SpaceKit's Dependencies","abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit":{"role":"overview","type":"topic","url":"\/tutorials\/spacekit","kind":"overview","title":"Meet SpaceKit","abstract":[{"text":"Discover how SpaceKit simplifies blockchain development using Swift. Dive into the world of Web3 with ease and efficiency.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Creating-Your-Own-Types":{"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/familiarizewithtypes#Creating-Your-Own-Types","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types","type":"section","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"title":"Creating Your Own Types"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Perform-an-Asynchronous-Call":{"url":"\/tutorials\/spacekit\/asynccalls#Perform-an-Asynchronous-Call","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","role":"pseudoSymbol","abstract":[{"text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources.","type":"text"}],"title":"Perform an Asynchronous Call"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens":{"title":"Managing Fungible Tokens","role":"project","kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","estimatedTime":"15min","type":"topic","url":"\/tutorials\/spacekit\/operationsonfungibletokens","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}]},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls":{"role":"project","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls","kind":"project","url":"\/tutorials\/spacekit\/synccalls","estimatedTime":"15min","title":"Interact with Other Contracts","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Exploring-SpaceKit's-Types":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","role":"article","abstract":[],"title":"Exploring SpaceKit's Types","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/exploring-spacekit's-types","type":"topic","kind":"article"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens","kind":"project","type":"topic","estimatedTime":"15min","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens","role":"project","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"title":"Managing Non-Fungible Tokens"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Burn-Tokens":{"type":"section","title":"Burn Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Burn-Tokens","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"kind":"section"},"OperationsOnNonFungibleTokensSection1Step1.swift":{"syntax":"swift","identifier":"OperationsOnNonFungibleTokensSection1Step1.swift","fileType":"swift","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<Buffer> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileName":"lib.swift","type":"file","highlights":[]},"doc://SpaceKit/tutorials/SpaceKit/StoreValues":{"type":"topic","url":"\/tutorials\/spacekit\/storevalues","abstract":[{"text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory.","type":"text"}],"title":"Persist Values Between Executions","estimatedTime":"15min","kind":"project","role":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues"},"OperationsOnNonFungibleTokensSection3Step5.swift":{"content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<Buffer> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"highlights":[{"line":109},{"line":110},{"line":111},{"line":112},{"line":113},{"line":114},{"line":115}],"syntax":"swift","identifier":"OperationsOnNonFungibleTokensSection3Step5.swift","fileType":"swift","fileName":"lib.swift","type":"file"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Fungible-Tokens":{"type":"topic","title":"Managing Fungible Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens","role":"article","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-fungible-tokens","abstract":[],"kind":"article"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Installing-the-Tools":{"type":"topic","title":"Installing the Tools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools","role":"article","url":"\/tutorials\/spacekit\/getting-started\/installing-the-tools","abstract":[],"kind":"article"},"OperationsOnNonFungibleTokensSection4Step1.swift":{"fileName":"lib.swift","type":"file","syntax":"swift","fileType":"swift","identifier":"OperationsOnNonFungibleTokensSection4Step1.swift","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<Buffer> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"highlights":[]},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Transaction-Context-Data":{"role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/getinfo#Accessing-Transaction-Context-Data","kind":"section","title":"Accessing Transaction Context Data","abstract":[{"text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles":{"url":"\/tutorials\/spacekit\/operationsonfungibletokens#Assign-Mint-and-Burn-Roles","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","role":"pseudoSymbol","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"title":"Assign Mint and Burn Roles"},"OperationsOnNonFungibleTokensSection1Step2.swift":{"content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<Buffer> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","syntax":"swift","identifier":"OperationsOnNonFungibleTokensSection1Step2.swift","highlights":[{"line":39},{"line":40},{"line":41},{"line":42}],"fileType":"swift","fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Retrieving-Information-from-the-Blockchain":{"url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/retrieving-information-from-the-blockchain","kind":"article","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","role":"article","abstract":[],"title":"Retrieving Information from the Blockchain"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Blockchain-Context-Data":{"kind":"section","role":"pseudoSymbol","title":"Accessing Blockchain Context Data","url":"\/tutorials\/spacekit\/getinfo#Accessing-Blockchain-Context-Data","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data","abstract":[{"text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner.","type":"text"}],"type":"section"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Interacting-with-Other-Contracts":{"type":"topic","title":"Interacting with Other Contracts","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","role":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/interacting-with-other-contracts","abstract":[],"kind":"article"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Setting-Up-the-SpaceKit-CLI":{"role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/installingtools#Setting-Up-the-SpaceKit-CLI","kind":"section","title":"Setting Up the SpaceKit CLI","abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI"},"OperationsOnNonFungibleTokensSection2Step2.swift":{"highlights":[{"line":61},{"line":62},{"line":63},{"line":64}],"identifier":"OperationsOnNonFungibleTokensSection2Step2.swift","fileType":"swift","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<Buffer> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileName":"lib.swift","type":"file","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Add-Quantity-to-an-Existing-Nonce","title":"Add Quantity to an Existing Nonce","kind":"section","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce","role":"pseudoSymbol","type":"section"},"OperationsOnNonFungibleTokensSection2Step5.swift":{"fileName":"lib.swift","syntax":"swift","fileType":"swift","type":"file","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<Buffer> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"highlights":[{"line":80},{"line":81},{"line":82},{"line":83},{"line":84},{"line":85},{"line":86}],"identifier":"OperationsOnNonFungibleTokensSection2Step5.swift"},"OperationsOnNonFungibleTokensSection2Step6.swift":{"syntax":"swift","identifier":"OperationsOnNonFungibleTokensSection2Step6.swift","type":"file","highlights":[{"line":87},{"line":88}],"content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<Buffer> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileType":"swift","fileName":"lib.swift"},"OperationsOnNonFungibleTokensSection3Step3.swift":{"fileType":"swift","syntax":"swift","fileName":"lib.swift","type":"file","identifier":"OperationsOnNonFungibleTokensSection3Step3.swift","highlights":[{"line":96},{"line":97},{"line":98},{"line":99},{"line":100},{"line":101}],"content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<Buffer> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges":{"kind":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Handling-Heap-Allocation-Challenges","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","role":"pseudoSymbol","type":"section","title":"Handling Heap Allocation Challenges"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract","role":"pseudoSymbol","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"title":"Initializing and Compiling Your First Smart Contract","url":"\/tutorials\/spacekit\/installingtools#Initializing-and-Compiling-Your-First-Smart-Contract","type":"section","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes":{"type":"topic","title":"Exploring SpaceKit's Types","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes","role":"project","url":"\/tutorials\/spacekit\/familiarizewithtypes","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"kind":"project","estimatedTime":"20min"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-BigUint-Type":{"url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-BigUint-Type","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","role":"pseudoSymbol","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"title":"Working with the BigUint Type"},"OperationsOnNonFungibleTokensSection3Step2.swift":{"syntax":"swift","fileType":"swift","fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection3Step2.swift","type":"file","highlights":[{"line":91},{"line":92},{"line":93},{"line":94},{"line":95},{"line":96},{"line":97}],"content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<Buffer> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Working-with-Storage-for-Single-Value-Persistence":{"role":"pseudoSymbol","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence","kind":"section","url":"\/tutorials\/spacekit\/storevalues#Working-with-Storage-for-Single-Value-Persistence","title":"Working with @Storage for Single Value Persistence","abstract":[{"text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory.","type":"text"}]},"OperationsOnNonFungibleTokensSection1Step4.swift":{"highlights":[{"line":45},{"line":46},{"line":47},{"line":48},{"line":49},{"line":50},{"line":51},{"line":52},{"line":53},{"line":54},{"line":55}],"type":"file","identifier":"OperationsOnNonFungibleTokensSection1Step4.swift","syntax":"swift","fileName":"lib.swift","fileType":"swift","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<Buffer> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"OperationsOnNonFungibleTokensSection3Step4.swift":{"syntax":"swift","fileType":"swift","fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection3Step4.swift","type":"file","highlights":[{"line":102},{"line":103},{"line":104},{"line":105},{"line":106},{"line":107},{"line":108}],"content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<Buffer> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract":{"type":"topic","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract","estimatedTime":"20min","title":"Building Your First Smart Contract","kind":"project","url":"\/tutorials\/spacekit\/codingyourfirstcontract","role":"project"},"OperationsOnNonFungibleTokensSection2Step3.swift":{"highlights":[{"line":63},{"line":64},{"line":65},{"line":66},{"line":67},{"line":68}],"type":"file","identifier":"OperationsOnNonFungibleTokensSection2Step3.swift","syntax":"swift","fileName":"lib.swift","fileType":"swift","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<Buffer> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Persisting-Data-Across-Executions":{"url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/persisting-data-across-executions","kind":"article","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","role":"article","abstract":[],"title":"Persisting Data Across Executions"},"OperationsOnNonFungibleTokensSection2Step4.swift":{"syntax":"swift","fileType":"swift","fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection2Step4.swift","type":"file","highlights":[{"line":69},{"line":70},{"line":71},{"line":72},{"line":73},{"line":74},{"line":75},{"line":76},{"line":77},{"line":78},{"line":79}],"content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<Buffer> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Non-Fungible-Tokens":{"type":"topic","title":"Managing Non-Fungible Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","role":"article","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-non-fungible-tokens","abstract":[],"kind":"article"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Writing-the-Contract-Code":{"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Writing-the-Contract-Code","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","type":"section","abstract":[{"text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions.","type":"text"}],"title":"Writing the Contract Code"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-unlockFunds-Endpoint":{"role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-unlockFunds-Endpoint","kind":"section","title":"Implementing the unlockFunds Endpoint","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Initializing-the-Project":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Initializing-the-Project","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","role":"pseudoSymbol","abstract":[{"text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions.","type":"text"}],"title":"Initializing the Project"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract":{"url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Meta-ESDT-from-Your-Contract","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract","role":"pseudoSymbol","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"title":"Issuing a Meta ESDT from Your Contract"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","title":"Issuing a Semi-Fungible Token from Your Contract","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"type":"text","text":" "},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"type":"section","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","title":"Issuing a Fungible Token from Your Contract","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"type":"text","text":" "},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"type":"section","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Fungible-Token-from-Your-Contract","kind":"section"},"OperationsOnNonFungibleTokensSection3Step1.swift":{"highlights":[],"type":"file","identifier":"OperationsOnNonFungibleTokensSection3Step1.swift","syntax":"swift","fileName":"lib.swift","fileType":"swift","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<Buffer> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes":{"title":"Enhance Your Contracts with Token Attributes","role":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","kind":"project","estimatedTime":"15min","type":"topic","url":"\/tutorials\/spacekit\/tokenattributes","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}]},"OperationsOnNonFungibleTokensSection4Step2.swift":{"syntax":"swift","fileType":"swift","fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection4Step2.swift","type":"file","highlights":[{"line":118},{"line":119},{"line":120},{"line":121},{"line":122},{"line":123},{"line":124}],"content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    public func burnTokens(","        nonce: UInt64,","        burnAmount: BigUint","    ) {","        assertOwner()","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<Buffer> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"text":" ","type":"text"},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"type":"topic","estimatedTime":"15min","title":"Understand the ESDT Standard","kind":"project","url":"\/tutorials\/spacekit\/understandtokens","role":"project"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage":{"role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/storevalues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","kind":"section","title":"Leveraging @Mapping for Dynamic Key-Value Storage","abstract":[{"text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage"},"OperationsOnNonFungibleTokensSection4Step4.swift":{"highlights":[{"line":129},{"line":130},{"line":131},{"line":132},{"line":133},{"line":134},{"line":135}],"type":"file","identifier":"OperationsOnNonFungibleTokensSection4Step4.swift","syntax":"swift","fileName":"lib.swift","fileType":"swift","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    public func burnTokens(","        nonce: UInt64,","        burnAmount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn tokens\")","        }","        ","        Blockchain","            .burnTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: burnAmount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<Buffer> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Building-Your-First-Smart-Contract":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","url":"\/tutorials\/spacekit\/getting-started\/building-your-first-smart-contract","abstract":[],"role":"article","type":"topic","kind":"article","title":"Building Your First Smart Contract"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","title":"Retrieving Information from the Blockchain","abstract":[{"text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner.","type":"text"}],"type":"topic","estimatedTime":"10min","role":"project","url":"\/tutorials\/spacekit\/getinfo","kind":"project"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"type":"section","title":"Assign Create, AddQuantity, and Burn Roles","kind":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Assign-Create-AddQuantity-and-Burn-Roles","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract":{"role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","kind":"section","title":"Issuing a Non-Fungible Token from Your Contract","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"type":"text","text":" "},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Enhancing-Contracts-with-Token-Attributes":{"kind":"article","role":"article","title":"Enhancing Contracts with Token Attributes","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/enhancing-contracts-with-token-attributes","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes","abstract":[],"type":"topic"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Mint-New-Tokens":{"url":"\/tutorials\/spacekit\/operationsonfungibletokens#Mint-New-Tokens","type":"section","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"kind":"section","title":"Mint New Tokens","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Testing-the-Contract":{"type":"section","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Testing-the-Contract","abstract":[{"text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions.","type":"text"}],"title":"Testing the Contract","kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools":{"type":"topic","title":"Install the Necessary Tools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","role":"project","url":"\/tutorials\/spacekit\/installingtools","abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"kind":"project","estimatedTime":"10min"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Create-a-New-Nonce":{"kind":"section","role":"pseudoSymbol","title":"Create a New Nonce","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Create-a-New-Nonce","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"type":"section"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Understanding-the-Buffer-Type":{"kind":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Understanding-the-Buffer-Type","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"role":"pseudoSymbol","type":"section","title":"Understanding the Buffer Type"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint":{"title":"Implementing the changeTokenLockDuration Endpoint","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint","type":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-changeTokenLockDuration-Endpoint","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-Vector-Type":{"role":"pseudoSymbol","title":"Working with the Vector Type","kind":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-Vector-Type","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"type":"section"},"OperationsOnNonFungibleTokensSection1Step5.swift":{"syntax":"swift","fileType":"swift","fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection1Step5.swift","type":"file","highlights":[{"line":56},{"line":57},{"line":58}],"content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<Buffer> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Perform-a-Synchronous-Call":{"role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/synccalls#Perform-a-Synchronous-Call","kind":"section","title":"Perform a Synchronous Call","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call"},"OperationsOnNonFungibleTokensSection1Step3.swift":{"highlights":[{"line":41},{"line":42},{"line":43},{"line":44}],"type":"file","identifier":"OperationsOnNonFungibleTokensSection1Step3.swift","syntax":"swift","fileName":"lib.swift","fileType":"swift","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<Buffer> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Creating-and-Understanding-Tokens":{"role":"article","type":"topic","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/creating-and-understanding-tokens","kind":"article","title":"Creating and Understanding Tokens","abstract":[],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-lockFunds-Endpoint":{"type":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-lockFunds-Endpoint","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"title":"Implementing the lockFunds Endpoint","kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Calling-Contracts-Across-Shards":{"role":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/calling-contracts-across-shards","kind":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","type":"topic","abstract":[],"title":"Calling Contracts Across Shards"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Declare-the-Callee-Proxy":{"title":"Declare the Callee Proxy","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","kind":"section","type":"section","url":"\/tutorials\/spacekit\/synccalls#Declare-the-Callee-Proxy","abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}]},"OperationsOnNonFungibleTokensSection4Step3.swift":{"syntax":"swift","fileType":"swift","fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection4Step3.swift","type":"file","highlights":[{"line":123},{"line":124},{"line":125},{"line":126},{"line":127},{"line":128}],"content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    public func burnTokens(","        nonce: UInt64,","        burnAmount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn tokens\")","        }","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<Buffer> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"OperationsOnNonFungibleTokensSection2Step1.swift":{"content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<Buffer> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"syntax":"swift","fileType":"swift","identifier":"OperationsOnNonFungibleTokensSection2Step1.swift","type":"file","fileName":"lib.swift","highlights":[]}}}
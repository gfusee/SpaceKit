{"variants":[{"paths":["\/tutorials\/spacekit\/operationsonnonfungibletokens"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens","interfaceLanguage":"swift"},"sections":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}]},{"inlineContent":[{"type":"text","text":"Once an NFT has been issued, new nonces can be created if the appropriate role is granted. This operation executes synchronously."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"For tokens that are semi-fungible or classified as meta-ESDTs, the supply for an existing nonce can be increased, provided the necessary role is assigned. This process, referred to as “adding quantity,” functions similarly to minting for fungible tokens and is also synchronous.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Burning tokens requires that they be designated as burnable and that the smart contract holds the burn role. A contract can only burn tokens that it owns. Like creating new nonces or increasing supply, burning is a synchronous operation.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"In this tutorial, we will focus on semi-fungible tokens.","type":"text"}]}],"chapter":"Managing Non-Fungible Tokens","kind":"hero","title":"Managing Non-Fungible Tokens","estimatedTimeInMinutes":15},{"tasks":[{"contentSection":[{"mediaPosition":"trailing","kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"text":"By default, a smart contract does not have permission to create new nonces, increase supply, or burn tokens. These roles must be explicitly granted before executing any of these actions. Assigning roles is an asynchronous operation that does not require a callback. If the token supports role management, only the token’s manager—the original issuer—can assign these roles.","type":"text"}]}]}],"anchor":"Assign-Create-AddQuantity-and-Burn-Roles","stepsSection":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Begin with the code from a previous section where we issued a semi-fungible token."}]}],"type":"step","code":"OperationsOnNonFungibleTokensSection1Step1.swift","caption":[{"type":"paragraph","inlineContent":[{"text":"The token is configured to support nonce creation, supply increases, and burning.","type":"text"}]}],"runtimePreview":null,"media":null},{"runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Define a restricted endpoint named ","type":"text"},{"code":"setRoles","type":"codeVoice"},{"text":", allowing only the contract owner to invoke it.","type":"text"}]}],"type":"step","media":null,"caption":[],"code":"OperationsOnNonFungibleTokensSection1Step2.swift"},{"content":[{"inlineContent":[{"type":"text","text":"Ensure that the token has already been issued before proceeding."}],"type":"paragraph"}],"caption":[],"type":"step","media":null,"code":"OperationsOnNonFungibleTokensSection1Step3.swift","runtimePreview":null},{"runtimePreview":null,"code":"OperationsOnNonFungibleTokensSection1Step4.swift","type":"step","media":null,"content":[{"inlineContent":[{"text":"Implement the ","type":"text"},{"code":"setTokenRoles","type":"codeVoice"},{"type":"text","text":" function to assign the necessary roles."}],"type":"paragraph"}],"caption":[]},{"code":"OperationsOnNonFungibleTokensSection1Step5.swift","media":null,"runtimePreview":null,"caption":[],"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Register a promise to initiate the asynchronous role assignment."}]}]}],"title":"Assign Create, AddQuantity, and Burn Roles"},{"stepsSection":[{"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Start from the code in the previous section."}]}],"caption":[],"runtimePreview":null,"media":null,"code":"OperationsOnNonFungibleTokensSection2Step1.swift"},{"runtimePreview":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"Define a "},{"code":"createNewNonce","type":"codeVoice"},{"type":"text","text":" endpoint, accessible only to the contract owner. This endpoint accepts an "},{"type":"codeVoice","code":"initialSupply"},{"type":"text","text":" parameter, specifying the number of tokens to create for the nonce. It returns a "},{"type":"codeVoice","code":"UInt64"},{"text":" representing the newly created nonce.","type":"text"}],"type":"paragraph"}],"code":"OperationsOnNonFungibleTokensSection2Step2.swift","caption":[],"media":null},{"runtimePreview":null,"code":"OperationsOnNonFungibleTokensSection2Step3.swift","content":[{"inlineContent":[{"text":"Verify that the contract holds the create role.","type":"text"}],"type":"paragraph"}],"caption":[{"inlineContent":[{"type":"text","text":"This ensures that "},{"code":"setTokenRoles","type":"codeVoice"},{"type":"text","text":" executed successfully and that the role assignment completed."}],"type":"paragraph"}],"media":null,"type":"step"},{"content":[{"inlineContent":[{"type":"text","text":"Execute the nonce creation."}],"type":"paragraph"}],"type":"step","caption":[{"inlineContent":[{"type":"text","text":"This operation is synchronous. If it fails, the transaction is reverted, and the newly created tokens are immediately added to the contract’s balance."}],"type":"paragraph"}],"runtimePreview":null,"code":"OperationsOnNonFungibleTokensSection2Step4.swift","media":null},{"media":null,"caption":[],"content":[{"inlineContent":[{"text":"Transfer the created tokens to the endpoint caller.","type":"text"}],"type":"paragraph"}],"type":"step","runtimePreview":null,"code":"OperationsOnNonFungibleTokensSection2Step5.swift"},{"content":[{"inlineContent":[{"text":"Return the newly created nonce.","type":"text"}],"type":"paragraph"}],"media":null,"runtimePreview":null,"code":"OperationsOnNonFungibleTokensSection2Step6.swift","caption":[],"type":"step"}],"title":"Create a New Nonce","anchor":"Create-a-New-Nonce","contentSection":[{"kind":"contentAndMedia","mediaPosition":"trailing","content":[{"inlineContent":[{"type":"text","text":"With the create role assigned, you can now generate new nonces for the token."}],"type":"paragraph"}]}]},{"stepsSection":[{"code":"OperationsOnNonFungibleTokensSection3Step1.swift","caption":[],"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Use the code from the previous section as a starting point.","type":"text"}]}],"runtimePreview":null,"media":null},{"runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Define an ","type":"text"},{"type":"codeVoice","code":"addQuantity"},{"type":"text","text":" endpoint, accessible only to the contract owner. This endpoint accepts "},{"type":"codeVoice","code":"nonce"},{"type":"text","text":" and "},{"type":"codeVoice","code":"amount"},{"text":" parameters, specifying which nonce to increase and by how much.","type":"text"}]}],"caption":[],"code":"OperationsOnNonFungibleTokensSection3Step2.swift","type":"step","media":null},{"runtimePreview":null,"media":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Verify that the contract holds the necessary role.","type":"text"}]}],"type":"step","caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This ensures that "},{"type":"codeVoice","code":"setTokenRoles"},{"type":"text","text":" executed successfully and that the role assignment completed."}]}],"code":"OperationsOnNonFungibleTokensSection3Step3.swift"},{"type":"step","media":null,"code":"OperationsOnNonFungibleTokensSection3Step4.swift","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Execute the quantity addition.","type":"text"}]}],"caption":[{"inlineContent":[{"type":"text","text":"SpaceKit automatically determines the appropriate function for minting fungible or increasing semi-fungible token supply."}],"type":"paragraph"}]},{"caption":[],"code":"OperationsOnNonFungibleTokensSection3Step5.swift","content":[{"inlineContent":[{"text":"Transfer the newly minted tokens to the caller.","type":"text"}],"type":"paragraph"}],"type":"step","media":null,"runtimePreview":null}],"anchor":"Add-Quantity-to-an-Existing-Nonce","contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"After creating new tokens, you may need to increase their supply. This applies only to semi-fungible and meta-ESDT tokens, as non-fungible tokens have a fixed supply of one per nonce."}]}],"mediaPosition":"trailing"}],"title":"Add Quantity to an Existing Nonce"},{"anchor":"Burn-Tokens","stepsSection":[{"runtimePreview":null,"code":"OperationsOnNonFungibleTokensSection4Step1.swift","media":null,"caption":[],"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Use the code from the previous section as a foundation.","type":"text"}]}]},{"code":"OperationsOnNonFungibleTokensSection4Step2.swift","type":"step","content":[{"inlineContent":[{"type":"text","text":"Define a "},{"code":"burnTokens","type":"codeVoice"},{"text":" endpoint, restricted to the contract owner. This endpoint accepts ","type":"text"},{"type":"codeVoice","code":"nonce"},{"type":"text","text":" and "},{"type":"codeVoice","code":"burnAmount"},{"text":" parameters, specifying which nonce and how many tokens to burn.","type":"text"}],"type":"paragraph"}],"caption":[],"media":null,"runtimePreview":null},{"media":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Ensure that the contract possesses the required burn role.","type":"text"}]}],"code":"OperationsOnNonFungibleTokensSection4Step3.swift","caption":[],"type":"step","runtimePreview":null},{"caption":[{"inlineContent":[{"type":"text","text":"Note: The burn operation is synchronous. If the contract does not have enough tokens, the transaction is reverted."}],"type":"paragraph"}],"code":"OperationsOnNonFungibleTokensSection4Step4.swift","runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"Execute the burn operation, removing the specified amount from the contract’s balance."}],"type":"paragraph"}],"type":"step","media":null}],"title":"Burn Tokens","contentSection":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Burning tokens is the inverse of adding quantity. Now that the contract has the burn role, you can proceed with this operation."}]}],"mediaPosition":"trailing","kind":"contentAndMedia"}]}],"kind":"tasks"},{"abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"action":{"type":"reference","overridingTitle":"Get started","isActive":true,"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","overridingTitleInlineContent":[{"text":"Get started","type":"text"}]},"featuredEyebrow":"Tutorial","kind":"callToAction","title":"Enhance Your Contracts with Token Attributes"}],"schemaVersion":{"major":0,"patch":0,"minor":3},"hierarchy":{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","modules":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract","kind":"task"}]}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues"}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain"},{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts"},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards"},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens"},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens","kind":"task"}]}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Build-a-Coin-Flip-Smart-Contract","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro#Set-Up-the-Project","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro"}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Flip-Structure","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Implement-Contract-Storage"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Contract-Init"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Define-the-Storage-for-the-Flip-Contract"},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-the-Minimum-Block-Bounty-Delay"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-Maximum-Bet-Limits","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Increase-Contract-Reserves","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Withdraw-Contract-Reserves"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Add-Administrative-Endpoints-to-the-Flip-Contract"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Implement-the-Game-Logic-for-the-Flip-Contract","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-flip-Endpoint"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-makeFlip-Function","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Define-the-bounty-Endpoint","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Set-Up-Testing-in-the-SwiftVM","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Set-Up-the-Test-Project","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Declare-Constants-for-the-Test-Environment"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Configure-the-Initial-Blockchain-State","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Write-Tests-for-the-Setup-Helpers","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Admin-Endpoints","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-the-Maximum-Bet-Configuration-Endpoints","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-increaseReserve-Endpoint","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-withdrawReserve-Endpoint"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Game-Logic-for-the-Flip-Contract","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Create-Utility-Functions-for-flip-and-bounty"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Cases-for-the-flip-Endpoint"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Successful-Calls-to-the-flip-Endpoint","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Case-for-the-bounty-Endpoint"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-the-bounty-Endpoint"}]}]}],"paths":[["doc:\/\/SpaceKit\/tutorials\/SpaceKit","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens"]]},"kind":"project","metadata":{"role":"project","categoryPathComponent":"SpaceKit","title":"Managing Non-Fungible Tokens","category":"SpaceKit"},"references":{"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Testing-the-Contract":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Testing-the-Contract","role":"pseudoSymbol","kind":"section","title":"Testing the Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract","type":"section","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}]},"OperationsOnNonFungibleTokensSection4Step3.swift":{"syntax":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    public func burnTokens(","        nonce: UInt64,","        burnAmount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn tokens\")","        }","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection4Step3.swift","fileType":"swift","highlights":[{"line":123},{"line":124},{"line":125},{"line":126},{"line":127},{"line":128}]},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint":{"abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"role":"pseudoSymbol","kind":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-changeTokenLockDuration-Endpoint","type":"section","title":"Implementing the changeTokenLockDuration Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Write-Tests-for-the-Setup-Helpers":{"type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Write-Tests-for-the-Setup-Helpers","role":"pseudoSymbol","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}],"url":"\/tutorials\/spacekit\/flipcontractinittests#Write-Tests-for-the-Setup-Helpers","kind":"section","title":"Write Tests for the Setup Helpers"},"OperationsOnNonFungibleTokensSection3Step2.swift":{"syntax":"swift","identifier":"OperationsOnNonFungibleTokensSection3Step2.swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileType":"swift","highlights":[{"line":91},{"line":92},{"line":93},{"line":94},{"line":95},{"line":96},{"line":97}],"fileName":"lib.swift","type":"file"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens":{"url":"\/tutorials\/spacekit\/understandtokens","estimatedTime":"15min","role":"project","kind":"project","title":"Understand the ESDT Standard","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens","type":"topic","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Assign-Create-AddQuantity-and-Burn-Roles","kind":"section","type":"section","role":"pseudoSymbol","title":"Assign Create, AddQuantity, and Burn Roles","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Working-with-Storage-for-Single-Value-Persistence":{"title":"Working with @Storage for Single Value Persistence","role":"pseudoSymbol","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"kind":"section","url":"\/tutorials\/spacekit\/storevalues#Working-with-Storage-for-Single-Value-Persistence","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles":{"abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Assign-Mint-and-Burn-Roles","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","kind":"section","type":"section","title":"Assign Mint and Burn Roles"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Test-the-Admin-Endpoints":{"type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Admin-Endpoints","role":"article","abstract":[],"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/test-the-admin-endpoints","kind":"article","title":"Test the Admin Endpoints"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Persisting-Data-Across-Executions":{"title":"Persisting Data Across Executions","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","type":"topic","abstract":[],"kind":"article","role":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/persisting-data-across-executions"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Test-the-increaseReserve-Endpoint":{"kind":"section","abstract":[{"text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/flipcontracttestadmin#Test-the-increaseReserve-Endpoint","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-increaseReserve-Endpoint","title":"Test the increaseReserve Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractIntro#Set-Up-the-Project":{"url":"\/tutorials\/spacekit\/flipcontractintro#Set-Up-the-Project","kind":"section","type":"section","role":"pseudoSymbol","title":"Set Up the Project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro#Set-Up-the-Project","abstract":[{"type":"text","text":"In this tutorial, you’ll write and test a complete smart contract that relies on random number generation to implement a coin flip mechanic. Players wager a chosen amount of any token and face a 50% chance of doubling their bet—or losing it. A small fee is deducted from each wager and sent to the developer’s wallet."}]},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Non-Fungible-Tokens":{"url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-non-fungible-tokens","kind":"article","type":"topic","role":"article","title":"Managing Non-Fungible Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-the-bounty-Endpoint":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-the-bounty-Endpoint","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"text":".","type":"text"}],"role":"pseudoSymbol","title":"Test the bounty Endpoint","kind":"section","url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-the-bounty-Endpoint","type":"section"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract":{"type":"section","kind":"section","url":"\/tutorials\/spacekit\/installingtools#Initializing-and-Compiling-Your-First-Smart-Contract","abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"title":"Initializing and Compiling Your First Smart Contract","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract"},"OperationsOnNonFungibleTokensSection2Step4.swift":{"content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"syntax":"swift","type":"file","identifier":"OperationsOnNonFungibleTokensSection2Step4.swift","fileType":"swift","fileName":"lib.swift","highlights":[{"line":69},{"line":70},{"line":71},{"line":72},{"line":73},{"line":74},{"line":75},{"line":76},{"line":77},{"line":78},{"line":79}]},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Fungible-Tokens":{"url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-fungible-tokens","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens","kind":"article","abstract":[],"role":"article","title":"Managing Fungible Tokens"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Build-a-Coin-Flip-Smart-Contract":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/build-a-coin-flip-smart-contract","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Build-a-Coin-Flip-Smart-Contract","kind":"article","abstract":[],"role":"article","title":"Build a Coin Flip Smart Contract"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract","kind":"project","estimatedTime":"20min","type":"topic","role":"project","title":"Building Your First Smart Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract","abstract":[{"text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Exploring-SpaceKit's-Types":{"abstract":[],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","title":"Exploring SpaceKit's Types","type":"topic","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/exploring-spacekit's-types","kind":"article","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage#Implement-Contract-Storage":{"url":"\/tutorials\/spacekit\/flipcontractwritethestorage#Implement-Contract-Storage","kind":"section","type":"section","role":"pseudoSymbol","title":"Implement Contract Storage","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Implement-Contract-Storage","abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Withdraw-Contract-Reserves":{"url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Withdraw-Contract-Reserves","role":"pseudoSymbol","kind":"section","title":"Withdraw Contract Reserves","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Withdraw-Contract-Reserves","type":"section","abstract":[{"type":"text","text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets."}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractIntro":{"type":"topic","url":"\/tutorials\/spacekit\/flipcontractintro","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro","estimatedTime":"20min","role":"project","kind":"project","title":"Build a Coin Flip Smart Contract","abstract":[{"text":"In this tutorial, you’ll write and test a complete smart contract that relies on random number generation to implement a coin flip mechanic. Players wager a chosen amount of any token and face a 50% chance of doubling their bet—or losing it. A small fee is deducted from each wager and sent to the developer’s wallet.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Mint-New-Tokens":{"url":"\/tutorials\/spacekit\/operationsonfungibletokens#Mint-New-Tokens","role":"pseudoSymbol","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","type":"section","title":"Mint New Tokens","kind":"section"},"OperationsOnNonFungibleTokensSection2Step3.swift":{"syntax":"swift","identifier":"OperationsOnNonFungibleTokensSection2Step3.swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileType":"swift","highlights":[{"line":63},{"line":64},{"line":65},{"line":66},{"line":67},{"line":68}],"fileName":"lib.swift","type":"file"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Verify-the-Maximum-Bet-Configuration-Endpoints":{"url":"\/tutorials\/spacekit\/flipcontracttestadmin#Verify-the-Maximum-Bet-Configuration-Endpoints","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-the-Maximum-Bet-Configuration-Endpoints","kind":"section","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}],"role":"pseudoSymbol","title":"Verify the Maximum Bet Configuration Endpoints"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame#Implement-the-flip-Endpoint":{"kind":"section","abstract":[{"type":"text","text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics."}],"type":"section","url":"\/tutorials\/spacekit\/flipcontractwritethegame#Implement-the-flip-Endpoint","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-flip-Endpoint","title":"Implement the flip Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens":{"estimatedTime":"15min","type":"topic","title":"Managing Non-Fungible Tokens","role":"project","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Configure-the-Initial-Blockchain-State":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Configure-the-Initial-Blockchain-State","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/flipcontractinittests#Configure-the-Initial-Blockchain-State","type":"section","title":"Configure the Initial Blockchain State","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}],"kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Increase-Contract-Reserves":{"url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Increase-Contract-Reserves","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Increase-Contract-Reserves","kind":"section","abstract":[{"type":"text","text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets."}],"role":"pseudoSymbol","title":"Increase Contract Reserves"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Initializing-the-Project":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Initializing-the-Project","role":"pseudoSymbol","kind":"section","title":"Initializing the Project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","type":"section","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}]},"OperationsOnNonFungibleTokensSection1Step1.swift":{"syntax":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection1Step1.swift","fileType":"swift","highlights":[]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame#Define-the-bounty-Endpoint":{"abstract":[{"text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics.","type":"text"}],"kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Define-the-bounty-Endpoint","type":"section","title":"Define the bounty Endpoint","url":"\/tutorials\/spacekit\/flipcontractwritethegame#Define-the-bounty-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","role":"project","url":"\/tutorials\/spacekit\/getinfo","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"title":"Retrieving Information from the Blockchain","type":"topic","estimatedTime":"10min","kind":"project"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens":{"type":"topic","estimatedTime":"15min","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","role":"project","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"url":"\/tutorials\/spacekit\/operationsonfungibletokens","kind":"project","title":"Managing Fungible Tokens"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Perform-an-Asynchronous-Call":{"url":"\/tutorials\/spacekit\/asynccalls#Perform-an-Asynchronous-Call","kind":"section","type":"section","role":"pseudoSymbol","title":"Perform an Asynchronous Call","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}]},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract":{"url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Fungible-Token-from-Your-Contract","role":"pseudoSymbol","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","type":"section","title":"Issuing a Fungible Token from Your Contract","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-Vector-Type":{"url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-Vector-Type","type":"section","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"title":"Working with the Vector Type","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame#Implement-the-makeFlip-Function":{"url":"\/tutorials\/spacekit\/flipcontractwritethegame#Implement-the-makeFlip-Function","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-makeFlip-Function","kind":"section","abstract":[{"type":"text","text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics."}],"role":"pseudoSymbol","title":"Implement the makeFlip Function"},"OperationsOnNonFungibleTokensSection1Step3.swift":{"syntax":"swift","identifier":"OperationsOnNonFungibleTokensSection1Step3.swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileType":"swift","highlights":[{"line":41},{"line":42},{"line":43},{"line":44}],"fileName":"lib.swift","type":"file"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Set-Up-Testing-in-the-SwiftVM":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/set-up-testing-in-the-swiftvm","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Set-Up-Testing-in-the-SwiftVM","kind":"article","abstract":[],"role":"article","title":"Set Up Testing in the SwiftVM"},"OperationsOnNonFungibleTokensSection2Step6.swift":{"syntax":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection2Step6.swift","fileType":"swift","highlights":[{"line":87},{"line":88}]},"OperationsOnNonFungibleTokensSection4Step1.swift":{"syntax":"swift","identifier":"OperationsOnNonFungibleTokensSection4Step1.swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileType":"swift","highlights":[],"fileName":"lib.swift","type":"file"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Declare-the-Callee-Proxy":{"type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","url":"\/tutorials\/spacekit\/synccalls#Declare-the-Callee-Proxy","title":"Declare the Callee Proxy","kind":"section","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}],"role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Define-the-Storage-for-the-Flip-Contract":{"title":"Define the Storage for the Flip Contract","role":"article","kind":"article","abstract":[],"type":"topic","url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/define-the-storage-for-the-flip-contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Define-the-Storage-for-the-Flip-Contract"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Understanding-the-Buffer-Type":{"title":"Understanding the Buffer Type","role":"pseudoSymbol","kind":"section","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Understanding-the-Buffer-Type","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes":{"type":"topic","url":"\/tutorials\/spacekit\/familiarizewithtypes","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes","estimatedTime":"20min","role":"project","kind":"project","title":"Exploring SpaceKit's Types","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Interacting-with-Other-Contracts":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","title":"Interacting with Other Contracts","kind":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/interacting-with-other-contracts","abstract":[],"type":"topic","role":"article"},"OperationsOnNonFungibleTokensSection4Step2.swift":{"identifier":"OperationsOnNonFungibleTokensSection4Step2.swift","syntax":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    public func burnTokens(","        nonce: UInt64,","        burnAmount: BigUint","    ) {","        assertOwner()","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","fileName":"lib.swift","fileType":"swift","highlights":[{"line":118},{"line":119},{"line":120},{"line":121},{"line":122},{"line":123},{"line":124}]},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Building-Your-First-Smart-Contract":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","title":"Building Your First Smart Contract","kind":"article","url":"\/tutorials\/spacekit\/getting-started\/building-your-first-smart-contract","abstract":[],"type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools":{"title":"Install the Necessary Tools","estimatedTime":"10min","url":"\/tutorials\/spacekit\/installingtools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"role":"project","kind":"project","type":"topic"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Creating-and-Understanding-Tokens":{"url":"\/tutorials\/spacekit\/create-and-manage-tokens\/creating-and-understanding-tokens","kind":"article","type":"topic","role":"article","title":"Creating and Understanding Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce":{"title":"Add Quantity to an Existing Nonce","role":"pseudoSymbol","kind":"section","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Add-Quantity-to-an-Existing-Nonce","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Test-the-withdrawReserve-Endpoint":{"type":"section","kind":"section","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}],"title":"Test the withdrawReserve Endpoint","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/flipcontracttestadmin#Test-the-withdrawReserve-Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-withdrawReserve-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Implement-the-Game-Logic-for-the-Flip-Contract":{"title":"Implement the Game Logic for the Flip Contract","role":"article","kind":"article","abstract":[],"type":"topic","url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/implement-the-game-logic-for-the-flip-contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Implement-the-Game-Logic-for-the-Flip-Contract"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls":{"title":"Interacting with Contracts Across Shards","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"kind":"project","role":"project","estimatedTime":"15min","type":"topic","url":"\/tutorials\/spacekit\/asynccalls"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage#Define-the-Flip-Structure":{"abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}],"url":"\/tutorials\/spacekit\/flipcontractwritethestorage#Define-the-Flip-Structure","role":"pseudoSymbol","title":"Define the Flip Structure","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Flip-Structure"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Set-Up-the-Test-Project":{"title":"Set Up the Test Project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Set-Up-the-Test-Project","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}],"url":"\/tutorials\/spacekit\/flipcontractinittests#Set-Up-the-Test-Project","type":"section","kind":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract":{"title":"Issuing a Non-Fungible Token from Your Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","type":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"kind":"section","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Non-Fungible-Token-from-Your-Contract"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Set-the-Minimum-Block-Bounty-Delay":{"url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Set-the-Minimum-Block-Bounty-Delay","role":"pseudoSymbol","kind":"section","title":"Set the Minimum Block Bounty Delay","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-the-Minimum-Block-Bounty-Delay","type":"section","abstract":[{"text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Installing-SpaceKits-Dependencies":{"url":"\/tutorials\/spacekit\/installingtools#Installing-SpaceKits-Dependencies","role":"pseudoSymbol","kind":"section","title":"Installing SpaceKit's Dependencies","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","type":"section","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}]},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Perform-a-Synchronous-Call":{"kind":"section","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/synccalls#Perform-a-Synchronous-Call","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","title":"Perform a Synchronous Call"},"OperationsOnNonFungibleTokensSection3Step3.swift":{"syntax":"swift","identifier":"OperationsOnNonFungibleTokensSection3Step3.swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileType":"swift","highlights":[{"line":96},{"line":97},{"line":98},{"line":99},{"line":100},{"line":101}],"fileName":"lib.swift","type":"file"},"OperationsOnNonFungibleTokensSection3Step4.swift":{"identifier":"OperationsOnNonFungibleTokensSection3Step4.swift","syntax":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","fileName":"lib.swift","fileType":"swift","highlights":[{"line":102},{"line":103},{"line":104},{"line":105},{"line":106},{"line":107},{"line":108}]},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Blockchain-Context-Data":{"abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"url":"\/tutorials\/spacekit\/getinfo#Accessing-Blockchain-Context-Data","role":"pseudoSymbol","title":"Accessing Blockchain Context Data","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data"},"OperationsOnNonFungibleTokensSection2Step2.swift":{"syntax":"swift","identifier":"OperationsOnNonFungibleTokensSection2Step2.swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileType":"swift","highlights":[{"line":61},{"line":62},{"line":63},{"line":64}],"fileName":"lib.swift","type":"file"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract":{"url":"\/tutorials\/spacekit\/flipcontractinittests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract","role":"pseudoSymbol","kind":"section","title":"Create Helper Functions to Deploy and Configure the Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract","type":"section","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage#Define-the-Contract-Init":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Contract-Init","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/flipcontractwritethestorage#Define-the-Contract-Init","abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}],"title":"Define the Contract Init","type":"section","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Retrieving-Information-from-the-Blockchain":{"type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","role":"article","abstract":[],"url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/retrieving-information-from-the-blockchain","kind":"article","title":"Retrieving Information from the Blockchain"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Writing-the-Contract-Code":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Writing-the-Contract-Code","role":"pseudoSymbol","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","type":"section","title":"Writing the Contract Code","kind":"section"},"OperationsOnNonFungibleTokensSection3Step5.swift":{"identifier":"OperationsOnNonFungibleTokensSection3Step5.swift","syntax":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","fileName":"lib.swift","fileType":"swift","highlights":[{"line":109},{"line":110},{"line":111},{"line":112},{"line":113},{"line":114},{"line":115}]},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Installing-the-Tools":{"abstract":[],"role":"article","kind":"article","url":"\/tutorials\/spacekit\/getting-started\/installing-the-tools","type":"topic","title":"Installing the Tools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Transaction-Context-Data":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/getinfo#Accessing-Transaction-Context-Data","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"title":"Accessing Transaction Context Data","type":"section","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Create-a-New-Nonce":{"abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"role":"pseudoSymbol","kind":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Create-a-New-Nonce","type":"section","title":"Create a New Nonce","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-Failure-Cases-for-the-flip-Endpoint":{"url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-Failure-Cases-for-the-flip-Endpoint","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Cases-for-the-flip-Endpoint","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"code":"GameController","type":"codeVoice"},{"text":".","type":"text"}],"kind":"section","title":"Test Failure Cases for the flip Endpoint","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Calling-Contracts-Across-Shards":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","title":"Calling Contracts Across Shards","kind":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/calling-contracts-across-shards","abstract":[],"type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Burn-Tokens":{"title":"Burn Tokens","role":"pseudoSymbol","kind":"section","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Burn-Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Create-Utility-Functions-for-flip-and-bounty":{"url":"\/tutorials\/spacekit\/flipcontracttestthegame#Create-Utility-Functions-for-flip-and-bounty","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Create-Utility-Functions-for-flip-and-bounty","kind":"section","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"text":".","type":"text"}],"role":"pseudoSymbol","title":"Create Utility Functions for flip and bounty"},"OperationsOnNonFungibleTokensSection2Step1.swift":{"syntax":"swift","identifier":"OperationsOnNonFungibleTokensSection2Step1.swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileType":"swift","highlights":[],"fileName":"lib.swift","type":"file"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-Failure-Case-for-the-bounty-Endpoint":{"url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-Failure-Case-for-the-bounty-Endpoint","role":"pseudoSymbol","kind":"section","title":"Test Failure Case for the bounty Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Case-for-the-bounty-Endpoint","type":"section","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"text":".","type":"text"}]},"OperationsOnNonFungibleTokensSection2Step5.swift":{"fileName":"lib.swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"syntax":"swift","type":"file","fileType":"swift","identifier":"OperationsOnNonFungibleTokensSection2Step5.swift","highlights":[{"line":80},{"line":81},{"line":82},{"line":83},{"line":84},{"line":85},{"line":86}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame","estimatedTime":"20min","abstract":[{"type":"text","text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics."}],"role":"project","title":"Implement the Game Logic for the Flip Contract","kind":"project","url":"\/tutorials\/spacekit\/flipcontractwritethegame","type":"topic"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-Successful-Calls-to-the-flip-Endpoint":{"title":"Test Successful Calls to the flip Endpoint","role":"pseudoSymbol","kind":"section","abstract":[{"text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the ","type":"text"},{"type":"codeVoice","code":"GameController"},{"type":"text","text":"."}],"type":"section","url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-Successful-Calls-to-the-flip-Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Successful-Calls-to-the-flip-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame","title":"Test the Game Logic for the Flip Contract","kind":"project","estimatedTime":"20min","url":"\/tutorials\/spacekit\/flipcontracttestthegame","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"type":"text","text":"."}],"type":"topic","role":"project"},"OperationsOnNonFungibleTokensSection1Step4.swift":{"identifier":"OperationsOnNonFungibleTokensSection1Step4.swift","fileType":"swift","highlights":[{"line":45},{"line":46},{"line":47},{"line":48},{"line":49},{"line":50},{"line":51},{"line":52},{"line":53},{"line":54},{"line":55}],"fileName":"lib.swift","syntax":"swift","type":"file","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Burn-Tokens":{"url":"\/tutorials\/spacekit\/operationsonfungibletokens#Burn-Tokens","kind":"section","type":"section","role":"pseudoSymbol","title":"Burn Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","abstract":[{"text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls":{"title":"Interact with Other Contracts","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls","abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}],"kind":"project","role":"project","estimatedTime":"15min","type":"topic","url":"\/tutorials\/spacekit\/synccalls"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues":{"abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"role":"project","estimatedTime":"15min","kind":"project","url":"\/tutorials\/spacekit\/storevalues","type":"topic","title":"Persist Values Between Executions","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests":{"url":"\/tutorials\/spacekit\/flipcontractinittests","type":"topic","kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests","estimatedTime":"20min","abstract":[{"text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential.","type":"text"}],"title":"Set Up Testing in the SwiftVM","role":"project"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage":{"title":"Define the Storage for the Flip Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage","abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}],"kind":"project","role":"project","estimatedTime":"20min","type":"topic","url":"\/tutorials\/spacekit\/flipcontractwritethestorage"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","url":"\/tutorials\/spacekit\/tokenattributes","role":"project","type":"topic","kind":"project","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"estimatedTime":"15min","title":"Enhance Your Contracts with Token Attributes"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Add-Administrative-Endpoints-to-the-Flip-Contract":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/add-administrative-endpoints-to-the-flip-contract","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Add-Administrative-Endpoints-to-the-Flip-Contract","kind":"article","abstract":[],"role":"article","title":"Add Administrative Endpoints to the Flip Contract"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-lockFunds-Endpoint":{"url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-lockFunds-Endpoint","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint","kind":"section","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"role":"pseudoSymbol","title":"Implementing the lockFunds Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","url":"\/tutorials\/spacekit\/storevalues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","role":"pseudoSymbol","type":"section","kind":"section","abstract":[{"text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory.","type":"text"}],"title":"Leveraging @Mapping for Dynamic Key-Value Storage"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges":{"title":"Handling Heap Allocation Challenges","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"kind":"section","role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Handling-Heap-Allocation-Challenges"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin":{"estimatedTime":"20min","url":"\/tutorials\/spacekit\/flipcontractwriteadmin","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin","type":"topic","kind":"project","title":"Add Administrative Endpoints to the Flip Contract","role":"project","abstract":[{"text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets.","type":"text"}]},"OperationsOnNonFungibleTokensSection4Step4.swift":{"fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection4Step4.swift","syntax":"swift","fileType":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    public func burnTokens(","        nonce: UInt64,","        burnAmount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn tokens\")","        }","        ","        Blockchain","            .burnTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: burnAmount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","highlights":[{"line":129},{"line":130},{"line":131},{"line":132},{"line":133},{"line":134},{"line":135}]},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Test-the-Game-Logic-for-the-Flip-Contract":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/test-the-game-logic-for-the-flip-contract","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Game-Logic-for-the-Flip-Contract","kind":"article","abstract":[],"role":"article","title":"Test the Game Logic for the Flip Contract"},"OperationsOnNonFungibleTokensSection3Step1.swift":{"fileName":"lib.swift","type":"file","fileType":"swift","identifier":"OperationsOnNonFungibleTokensSection3Step1.swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"syntax":"swift","highlights":[]},"doc://SpaceKit/tutorials/SpaceKit":{"title":"Meet SpaceKit","abstract":[{"type":"text","text":"Discover how SpaceKit simplifies blockchain development using Swift. Dive into the world of Web3 with ease and efficiency."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","url":"\/tutorials\/spacekit","role":"overview","kind":"overview","type":"topic"},"OperationsOnNonFungibleTokensSection1Step2.swift":{"fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection1Step2.swift","syntax":"swift","fileType":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","highlights":[{"line":39},{"line":40},{"line":41},{"line":42}]},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Setting-Up-the-SpaceKit-CLI":{"url":"\/tutorials\/spacekit\/installingtools#Setting-Up-the-SpaceKit-CLI","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI","kind":"section","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"role":"pseudoSymbol","title":"Setting Up the SpaceKit CLI"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-BigUint-Type":{"url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-BigUint-Type","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","kind":"section","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"role":"pseudoSymbol","title":"Working with the BigUint Type"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Set-Maximum-Bet-Limits":{"kind":"section","abstract":[{"type":"text","text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets."}],"type":"section","url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Set-Maximum-Bet-Limits","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-Maximum-Bet-Limits","title":"Set Maximum Bet Limits"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract":{"title":"Issuing a Meta ESDT from Your Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"kind":"section","role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Meta-ESDT-from-Your-Contract"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-unlockFunds-Endpoint":{"type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-unlockFunds-Endpoint","title":"Implementing the unlockFunds Endpoint","kind":"section","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Enhancing-Contracts-with-Token-Attributes":{"abstract":[],"role":"article","kind":"article","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/enhancing-contracts-with-token-attributes","type":"topic","title":"Enhancing Contracts with Token Attributes","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Declare-Constants-for-the-Test-Environment":{"title":"Declare Constants for the Test Environment","role":"pseudoSymbol","kind":"section","abstract":[{"text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/flipcontractinittests#Declare-Constants-for-the-Test-Environment","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Declare-Constants-for-the-Test-Environment"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Creating-Your-Own-Types":{"title":"Creating Your Own Types","role":"pseudoSymbol","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"kind":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Creating-Your-Own-Types","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types"},"OperationsOnNonFungibleTokensSection1Step5.swift":{"fileName":"lib.swift","type":"file","fileType":"swift","identifier":"OperationsOnNonFungibleTokensSection1Step5.swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"syntax":"swift","highlights":[{"line":56},{"line":57},{"line":58}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints":{"url":"\/tutorials\/spacekit\/flipcontracttestadmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints","kind":"section","type":"section","role":"pseudoSymbol","title":"Verify That Only the Owner Can Access Admin Endpoints","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}]},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract":{"title":"Issuing a Semi-Fungible Token from Your Contract","type":"section","role":"pseudoSymbol","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"text":" ","type":"text"},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Declare-the-Callee-Proxy":{"url":"\/tutorials\/spacekit\/asynccalls#Declare-the-Callee-Proxy","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"title":"Declare the Callee Proxy","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin":{"title":"Test the Admin Endpoints","type":"topic","role":"project","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}],"kind":"project","estimatedTime":"20min","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin","url":"\/tutorials\/spacekit\/flipcontracttestadmin"}}}
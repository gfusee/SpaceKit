{"schemaVersion":{"minor":3,"major":0,"patch":0},"sections":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once an NFT has been issued, new nonces can be created if the appropriate role is granted. This operation executes synchronously."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For tokens that are semi-fungible or classified as meta-ESDTs, the supply for an existing nonce can be increased, provided the necessary role is assigned. This process, referred to as “adding quantity,” functions similarly to minting for fungible tokens and is also synchronous."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Burning tokens requires that they be designated as burnable and that the smart contract holds the burn role. A contract can only burn tokens that it owns. Like creating new nonces or increasing supply, burning is a synchronous operation."}]},{"type":"paragraph","inlineContent":[{"text":"In this tutorial, we will focus on semi-fungible tokens.","type":"text"}]}],"kind":"hero","estimatedTimeInMinutes":15,"chapter":"Managing Non-Fungible Tokens","title":"Managing Non-Fungible Tokens"},{"tasks":[{"stepsSection":[{"code":"OperationsOnNonFungibleTokensSection1Step1.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Begin with the code from a previous section where we issued a semi-fungible token."}]}],"runtimePreview":null,"type":"step","caption":[{"inlineContent":[{"type":"text","text":"The token is configured to support nonce creation, supply increases, and burning."}],"type":"paragraph"}],"media":null},{"type":"step","runtimePreview":null,"code":"OperationsOnNonFungibleTokensSection1Step2.swift","caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define a restricted endpoint named "},{"type":"codeVoice","code":"setRoles"},{"type":"text","text":", allowing only the contract owner to invoke it."}]}],"media":null},{"type":"step","runtimePreview":null,"media":null,"caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Ensure that the token has already been issued before proceeding."}]}],"code":"OperationsOnNonFungibleTokensSection1Step3.swift"},{"code":"OperationsOnNonFungibleTokensSection1Step4.swift","content":[{"type":"paragraph","inlineContent":[{"text":"Implement the ","type":"text"},{"type":"codeVoice","code":"setTokenRoles"},{"type":"text","text":" function to assign the necessary roles."}]}],"caption":[],"runtimePreview":null,"type":"step","media":null},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Register a promise to initiate the asynchronous role assignment."}]}],"caption":[],"media":null,"type":"step","runtimePreview":null,"code":"OperationsOnNonFungibleTokensSection1Step5.swift"}],"title":"Assign Create, AddQuantity, and Burn Roles","contentSection":[{"kind":"contentAndMedia","mediaPosition":"trailing","content":[{"inlineContent":[{"text":"By default, a smart contract does not have permission to create new nonces, increase supply, or burn tokens. These roles must be explicitly granted before executing any of these actions. Assigning roles is an asynchronous operation that does not require a callback. If the token supports role management, only the token’s manager—the original issuer—can assign these roles.","type":"text"}],"type":"paragraph"}]}],"anchor":"Assign-Create-AddQuantity-and-Burn-Roles"},{"anchor":"Create-a-New-Nonce","title":"Create a New Nonce","contentSection":[{"mediaPosition":"trailing","kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"With the create role assigned, you can now generate new nonces for the token."}]}]}],"stepsSection":[{"caption":[],"content":[{"inlineContent":[{"type":"text","text":"Start from the code in the previous section."}],"type":"paragraph"}],"media":null,"code":"OperationsOnNonFungibleTokensSection2Step1.swift","runtimePreview":null,"type":"step"},{"type":"step","caption":[],"media":null,"runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"Define a "},{"code":"createNewNonce","type":"codeVoice"},{"text":" endpoint, accessible only to the contract owner. This endpoint accepts an ","type":"text"},{"type":"codeVoice","code":"initialSupply"},{"type":"text","text":" parameter, specifying the number of tokens to create for the nonce. It returns a "},{"type":"codeVoice","code":"UInt64"},{"text":" representing the newly created nonce.","type":"text"}],"type":"paragraph"}],"code":"OperationsOnNonFungibleTokensSection2Step2.swift"},{"media":null,"runtimePreview":null,"type":"step","code":"OperationsOnNonFungibleTokensSection2Step3.swift","content":[{"type":"paragraph","inlineContent":[{"text":"Verify that the contract holds the create role.","type":"text"}]}],"caption":[{"inlineContent":[{"text":"This ensures that ","type":"text"},{"type":"codeVoice","code":"setTokenRoles"},{"text":" executed successfully and that the role assignment completed.","type":"text"}],"type":"paragraph"}]},{"code":"OperationsOnNonFungibleTokensSection2Step4.swift","type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Execute the nonce creation."}]}],"media":null,"caption":[{"inlineContent":[{"text":"This operation is synchronous. If it fails, the transaction is reverted, and the newly created tokens are immediately added to the contract’s balance.","type":"text"}],"type":"paragraph"}],"runtimePreview":null},{"media":null,"code":"OperationsOnNonFungibleTokensSection2Step5.swift","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Transfer the created tokens to the endpoint caller."}]}],"caption":[],"type":"step"},{"type":"step","code":"OperationsOnNonFungibleTokensSection2Step6.swift","runtimePreview":null,"media":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Return the newly created nonce.","type":"text"}]}],"caption":[]}]},{"contentSection":[{"kind":"contentAndMedia","content":[{"inlineContent":[{"type":"text","text":"After creating new tokens, you may need to increase their supply. This applies only to semi-fungible and meta-ESDT tokens, as non-fungible tokens have a fixed supply of one per nonce."}],"type":"paragraph"}],"mediaPosition":"trailing"}],"title":"Add Quantity to an Existing Nonce","stepsSection":[{"runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use the code from the previous section as a starting point."}]}],"caption":[],"media":null,"type":"step","code":"OperationsOnNonFungibleTokensSection3Step1.swift"},{"media":null,"code":"OperationsOnNonFungibleTokensSection3Step2.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define an "},{"code":"addQuantity","type":"codeVoice"},{"text":" endpoint, accessible only to the contract owner. This endpoint accepts ","type":"text"},{"code":"nonce","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"amount"},{"text":" parameters, specifying which nonce to increase and by how much.","type":"text"}]}],"type":"step","caption":[],"runtimePreview":null},{"content":[{"inlineContent":[{"type":"text","text":"Verify that the contract holds the necessary role."}],"type":"paragraph"}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This ensures that "},{"type":"codeVoice","code":"setTokenRoles"},{"type":"text","text":" executed successfully and that the role assignment completed."}]}],"type":"step","code":"OperationsOnNonFungibleTokensSection3Step3.swift","runtimePreview":null,"media":null},{"media":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Execute the quantity addition.","type":"text"}]}],"code":"OperationsOnNonFungibleTokensSection3Step4.swift","runtimePreview":null,"type":"step","caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"SpaceKit automatically determines the appropriate function for minting fungible or increasing semi-fungible token supply."}]}]},{"runtimePreview":null,"type":"step","media":null,"caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Transfer the newly minted tokens to the caller."}]}],"code":"OperationsOnNonFungibleTokensSection3Step5.swift"}],"anchor":"Add-Quantity-to-an-Existing-Nonce"},{"stepsSection":[{"caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use the code from the previous section as a foundation."}]}],"runtimePreview":null,"media":null,"code":"OperationsOnNonFungibleTokensSection4Step1.swift","type":"step"},{"runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define a "},{"code":"burnTokens","type":"codeVoice"},{"type":"text","text":" endpoint, restricted to the contract owner. This endpoint accepts "},{"code":"nonce","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"burnAmount"},{"type":"text","text":" parameters, specifying which nonce and how many tokens to burn."}]}],"code":"OperationsOnNonFungibleTokensSection4Step2.swift","caption":[],"type":"step","media":null},{"code":"OperationsOnNonFungibleTokensSection4Step3.swift","content":[{"type":"paragraph","inlineContent":[{"text":"Ensure that the contract possesses the required burn role.","type":"text"}]}],"type":"step","caption":[],"runtimePreview":null,"media":null},{"content":[{"inlineContent":[{"text":"Execute the burn operation, removing the specified amount from the contract’s balance.","type":"text"}],"type":"paragraph"}],"media":null,"code":"OperationsOnNonFungibleTokensSection4Step4.swift","runtimePreview":null,"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Note: The burn operation is synchronous. If the contract does not have enough tokens, the transaction is reverted."}]}],"type":"step"}],"anchor":"Burn-Tokens","contentSection":[{"mediaPosition":"trailing","kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Burning tokens is the inverse of adding quantity. Now that the contract has the burn role, you can proceed with this operation."}]}]}],"title":"Burn Tokens"}],"kind":"tasks"},{"kind":"callToAction","action":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","overridingTitle":"Get started","isActive":true,"type":"reference","overridingTitleInlineContent":[{"text":"Get started","type":"text"}]},"title":"Enhance Your Contracts with Token Attributes","featuredEyebrow":"Tutorial","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"},"metadata":{"role":"project","category":"SpaceKit","categoryPathComponent":"SpaceKit","title":"Managing Non-Fungible Tokens"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/tutorials\/spacekit\/operationsonnonfungibletokens"]}],"kind":"project","hierarchy":{"modules":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract"}]}]},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens","projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens"}]},{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint"}]}]}],"paths":[["doc:\/\/SpaceKit\/tutorials\/SpaceKit","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens"]],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit"},"references":{"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens":{"abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens","title":"Managing Non-Fungible Tokens","type":"topic","kind":"project","estimatedTime":"15min","role":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"kind":"section","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","type":"section","title":"Issuing a Semi-Fungible Token from Your Contract"},"OperationsOnNonFungibleTokensSection1Step1.swift":{"content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileName":"lib.swift","highlights":[],"identifier":"OperationsOnNonFungibleTokensSection1Step1.swift","type":"file","fileType":"swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls","kind":"project","type":"topic","abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}],"role":"project","url":"\/tutorials\/spacekit\/synccalls","estimatedTime":"15min","title":"Interact with Other Contracts"},"OperationsOnNonFungibleTokensSection1Step2.swift":{"content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","fileType":"swift","fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection1Step2.swift","syntax":"swift","highlights":[{"line":39},{"line":40},{"line":41},{"line":42}]},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Setting-Up-the-SpaceKit-CLI":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"kind":"section","url":"\/tutorials\/spacekit\/installingtools#Setting-Up-the-SpaceKit-CLI","type":"section","title":"Setting Up the SpaceKit CLI"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Calling-Contracts-Across-Shards":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/calling-contracts-across-shards","abstract":[],"kind":"article","title":"Calling Contracts Across Shards","type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Fungible-Tokens":{"abstract":[],"kind":"article","title":"Managing Fungible Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-fungible-tokens","type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract","kind":"section","type":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Meta-ESDT-from-Your-Contract","title":"Issuing a Meta ESDT from Your Contract"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","estimatedTime":"10min","kind":"project","abstract":[{"text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner.","type":"text"}],"url":"\/tutorials\/spacekit\/getinfo","title":"Retrieving Information from the Blockchain","type":"topic","role":"project"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Installing-SpaceKits-Dependencies":{"kind":"section","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","url":"\/tutorials\/spacekit\/installingtools#Installing-SpaceKits-Dependencies","title":"Installing SpaceKit's Dependencies","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit":{"title":"Meet SpaceKit","url":"\/tutorials\/spacekit","role":"overview","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","type":"topic","kind":"overview","abstract":[{"text":"Discover how SpaceKit simplifies blockchain development using Swift. Dive into the world of Web3 with ease and efficiency.","type":"text"}]},"OperationsOnNonFungibleTokensSection2Step6.swift":{"content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileName":"lib.swift","highlights":[{"line":87},{"line":88}],"identifier":"OperationsOnNonFungibleTokensSection2Step6.swift","type":"file","fileType":"swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","kind":"section","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"text":" ","type":"text"},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","title":"Issuing a Non-Fungible Token from Your Contract","type":"section","role":"pseudoSymbol"},"OperationsOnNonFungibleTokensSection2Step1.swift":{"content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","fileType":"swift","fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection2Step1.swift","syntax":"swift","highlights":[]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","kind":"section","abstract":[{"text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with.","type":"text"}],"url":"\/tutorials\/spacekit\/operationsonfungibletokens#Assign-Mint-and-Burn-Roles","title":"Assign Mint and Burn Roles","type":"section","role":"pseudoSymbol"},"OperationsOnNonFungibleTokensSection3Step2.swift":{"fileType":"swift","highlights":[{"line":91},{"line":92},{"line":93},{"line":94},{"line":95},{"line":96},{"line":97}],"identifier":"OperationsOnNonFungibleTokensSection3Step2.swift","fileName":"lib.swift","syntax":"swift","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-Vector-Type":{"abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-Vector-Type","title":"Working with the Vector Type","type":"section","kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Transaction-Context-Data":{"title":"Accessing Transaction Context Data","url":"\/tutorials\/spacekit\/getinfo#Accessing-Transaction-Context-Data","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","type":"section","kind":"section","abstract":[{"text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Blockchain-Context-Data":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data","kind":"section","type":"section","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/getinfo#Accessing-Blockchain-Context-Data","title":"Accessing Blockchain Context Data"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Perform-a-Synchronous-Call":{"title":"Perform a Synchronous Call","url":"\/tutorials\/spacekit\/synccalls#Perform-a-Synchronous-Call","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","type":"section","kind":"section","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract":{"role":"project","estimatedTime":"20min","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"kind":"project","url":"\/tutorials\/spacekit\/codingyourfirstcontract","type":"topic","title":"Building Your First Smart Contract"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Installing-the-Tools":{"abstract":[],"kind":"article","title":"Installing the Tools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools","url":"\/tutorials\/spacekit\/getting-started\/installing-the-tools","type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Create-a-New-Nonce":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce","kind":"section","type":"section","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Create-a-New-Nonce","title":"Create a New Nonce"},"OperationsOnNonFungibleTokensSection3Step4.swift":{"highlights":[{"line":102},{"line":103},{"line":104},{"line":105},{"line":106},{"line":107},{"line":108}],"fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection3Step4.swift","syntax":"swift","type":"file","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"fileType":"swift"},"OperationsOnNonFungibleTokensSection1Step4.swift":{"syntax":"swift","fileType":"swift","highlights":[{"line":45},{"line":46},{"line":47},{"line":48},{"line":49},{"line":50},{"line":51},{"line":52},{"line":53},{"line":54},{"line":55}],"fileName":"lib.swift","identifier":"OperationsOnNonFungibleTokensSection1Step4.swift","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file"},"OperationsOnNonFungibleTokensSection4Step3.swift":{"type":"file","syntax":"swift","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    public func burnTokens(","        nonce: UInt64,","        burnAmount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn tokens\")","        }","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"identifier":"OperationsOnNonFungibleTokensSection4Step3.swift","fileName":"lib.swift","fileType":"swift","highlights":[{"line":123},{"line":124},{"line":125},{"line":126},{"line":127},{"line":128}]},"OperationsOnNonFungibleTokensSection1Step5.swift":{"syntax":"swift","fileName":"lib.swift","type":"file","highlights":[{"line":56},{"line":57},{"line":58}],"fileType":"swift","identifier":"OperationsOnNonFungibleTokensSection1Step5.swift","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Enhancing-Contracts-with-Token-Attributes":{"abstract":[],"title":"Enhancing Contracts with Token Attributes","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/enhancing-contracts-with-token-attributes","kind":"article","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Declare-the-Callee-Proxy":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","kind":"section","type":"section","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/asynccalls#Declare-the-Callee-Proxy","title":"Declare the Callee Proxy"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens","kind":"project","type":"topic","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"role":"project","url":"\/tutorials\/spacekit\/understandtokens","estimatedTime":"15min","title":"Understand the ESDT Standard"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes","kind":"project","type":"topic","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"role":"project","url":"\/tutorials\/spacekit\/familiarizewithtypes","estimatedTime":"20min","title":"Exploring SpaceKit's Types"},"OperationsOnNonFungibleTokensSection4Step1.swift":{"identifier":"OperationsOnNonFungibleTokensSection4Step1.swift","highlights":[],"content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","fileName":"lib.swift","syntax":"swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-unlockFunds-Endpoint":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"kind":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-unlockFunds-Endpoint","type":"section","title":"Implementing the unlockFunds Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-BigUint-Type":{"title":"Working with the BigUint Type","url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-BigUint-Type","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","type":"section","kind":"section","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges":{"title":"Handling Heap Allocation Challenges","role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Handling-Heap-Allocation-Challenges","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Working-with-Storage-for-Single-Value-Persistence":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence","url":"\/tutorials\/spacekit\/storevalues#Working-with-Storage-for-Single-Value-Persistence","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"kind":"section","title":"Working with @Storage for Single Value Persistence","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Exploring-SpaceKit's-Types":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","kind":"article","type":"topic","abstract":[],"role":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/exploring-spacekit's-types","title":"Exploring SpaceKit's Types"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Persisting-Data-Across-Executions":{"title":"Persisting Data Across Executions","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/persisting-data-across-executions","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","type":"topic","kind":"article","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint":{"title":"Implementing the changeTokenLockDuration Endpoint","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint","kind":"section","type":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-changeTokenLockDuration-Endpoint","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}]},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes":{"abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"url":"\/tutorials\/spacekit\/tokenattributes","title":"Enhance Your Contracts with Token Attributes","type":"topic","kind":"project","estimatedTime":"15min","role":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce":{"title":"Add Quantity to an Existing Nonce","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce","kind":"section","type":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Add-Quantity-to-an-Existing-Nonce","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}]},"OperationsOnNonFungibleTokensSection4Step4.swift":{"syntax":"swift","identifier":"OperationsOnNonFungibleTokensSection4Step4.swift","highlights":[{"line":129},{"line":130},{"line":131},{"line":132},{"line":133},{"line":134},{"line":135}],"fileType":"swift","fileName":"lib.swift","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    public func burnTokens(","        nonce: UInt64,","        burnAmount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftBurn) else {","            smartContractError(message: \"Cannot burn tokens\")","        }","        ","        Blockchain","            .burnTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: burnAmount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Burn-Tokens":{"abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"kind":"section","title":"Burn Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Burn-Tokens","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Testing-the-Contract":{"abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Testing-the-Contract","title":"Testing the Contract","kind":"section","type":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Understanding-the-Buffer-Type":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","url":"\/tutorials\/spacekit\/familiarizewithtypes#Understanding-the-Buffer-Type","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"kind":"section","title":"Understanding the Buffer Type","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Creating-and-Understanding-Tokens":{"role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","abstract":[],"kind":"article","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/creating-and-understanding-tokens","type":"topic","title":"Creating and Understanding Tokens"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls":{"title":"Interacting with Contracts Across Shards","role":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","kind":"project","type":"topic","estimatedTime":"15min","url":"\/tutorials\/spacekit\/asynccalls","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Mint-New-Tokens":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","kind":"section","type":"section","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Mint-New-Tokens","title":"Mint New Tokens"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract":{"abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"url":"\/tutorials\/spacekit\/installingtools#Initializing-and-Compiling-Your-First-Smart-Contract","title":"Initializing and Compiling Your First Smart Contract","type":"section","kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues":{"role":"project","estimatedTime":"15min","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"kind":"project","url":"\/tutorials\/spacekit\/storevalues","type":"topic","title":"Persist Values Between Executions"},"OperationsOnNonFungibleTokensSection2Step4.swift":{"fileType":"swift","identifier":"OperationsOnNonFungibleTokensSection2Step4.swift","highlights":[{"line":69},{"line":70},{"line":71},{"line":72},{"line":73},{"line":74},{"line":75},{"line":76},{"line":77},{"line":78},{"line":79}],"syntax":"swift","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-lockFunds-Endpoint":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint","kind":"section","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-lockFunds-Endpoint","title":"Implementing the lockFunds Endpoint","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Creating-Your-Own-Types":{"title":"Creating Your Own Types","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types","kind":"section","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Creating-Your-Own-Types","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens":{"title":"Managing Fungible Tokens","role":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","kind":"project","type":"topic","estimatedTime":"15min","url":"\/tutorials\/spacekit\/operationsonfungibletokens","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}]},"OperationsOnNonFungibleTokensSection3Step5.swift":{"syntax":"swift","identifier":"OperationsOnNonFungibleTokensSection3Step5.swift","highlights":[{"line":109},{"line":110},{"line":111},{"line":112},{"line":113},{"line":114},{"line":115}],"fileType":"swift","fileName":"lib.swift","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file"},"OperationsOnNonFungibleTokensSection2Step5.swift":{"highlights":[{"line":80},{"line":81},{"line":82},{"line":83},{"line":84},{"line":85},{"line":86}],"identifier":"OperationsOnNonFungibleTokensSection2Step5.swift","syntax":"swift","fileType":"swift","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"kind":"section","url":"\/tutorials\/spacekit\/storevalues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","type":"section","title":"Leveraging @Mapping for Dynamic Key-Value Storage"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract":{"title":"Issuing a Fungible Token from Your Contract","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","kind":"section","type":"section","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Fungible-Token-from-Your-Contract","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}]},"OperationsOnNonFungibleTokensSection2Step3.swift":{"highlights":[{"line":63},{"line":64},{"line":65},{"line":66},{"line":67},{"line":68}],"fileType":"swift","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","syntax":"swift","identifier":"OperationsOnNonFungibleTokensSection2Step3.swift","fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Initializing-the-Project":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"kind":"section","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Initializing-the-Project","type":"section","title":"Initializing the Project"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Declare-the-Callee-Proxy":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","url":"\/tutorials\/spacekit\/synccalls#Declare-the-Callee-Proxy","abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}],"kind":"section","title":"Declare the Callee Proxy","type":"section","role":"pseudoSymbol"},"OperationsOnNonFungibleTokensSection3Step3.swift":{"highlights":[{"line":96},{"line":97},{"line":98},{"line":99},{"line":100},{"line":101}],"identifier":"OperationsOnNonFungibleTokensSection3Step3.swift","syntax":"swift","fileType":"swift","type":"file","fileName":"lib.swift","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Perform-an-Asynchronous-Call":{"abstract":[{"text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources.","type":"text"}],"url":"\/tutorials\/spacekit\/asynccalls#Perform-an-Asynchronous-Call","title":"Perform an Asynchronous Call","type":"section","kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call"},"OperationsOnNonFungibleTokensSection2Step2.swift":{"highlights":[{"line":61},{"line":62},{"line":63},{"line":64}],"fileType":"swift","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","syntax":"swift","identifier":"OperationsOnNonFungibleTokensSection2Step2.swift","fileName":"lib.swift"},"OperationsOnNonFungibleTokensSection3Step1.swift":{"highlights":[],"identifier":"OperationsOnNonFungibleTokensSection3Step1.swift","syntax":"swift","fileType":"swift","type":"file","fileName":"lib.swift","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Burn-Tokens":{"role":"pseudoSymbol","abstract":[{"text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","kind":"section","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Burn-Tokens","type":"section","title":"Burn Tokens"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Writing-the-Contract-Code":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"kind":"section","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Writing-the-Contract-Code","type":"section","title":"Writing the Contract Code"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles":{"title":"Assign Create, AddQuantity, and Burn Roles","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","kind":"section","type":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Assign-Create-AddQuantity-and-Burn-Roles","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}]},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Non-Fungible-Tokens":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-non-fungible-tokens","abstract":[],"kind":"article","title":"Managing Non-Fungible Tokens","type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Retrieving-Information-from-the-Blockchain":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","kind":"article","type":"topic","abstract":[],"role":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/retrieving-information-from-the-blockchain","title":"Retrieving Information from the Blockchain"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Building-Your-First-Smart-Contract":{"role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","abstract":[],"kind":"article","url":"\/tutorials\/spacekit\/getting-started\/building-your-first-smart-contract","type":"topic","title":"Building Your First Smart Contract"},"OperationsOnNonFungibleTokensSection1Step3.swift":{"highlights":[{"line":41},{"line":42},{"line":43},{"line":44}],"fileType":"swift","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"type":"file","syntax":"swift","identifier":"OperationsOnNonFungibleTokensSection1Step3.swift","fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","kind":"project","type":"topic","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"role":"project","url":"\/tutorials\/spacekit\/installingtools","estimatedTime":"10min","title":"Install the Necessary Tools"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Interacting-with-Other-Contracts":{"title":"Interacting with Other Contracts","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/interacting-with-other-contracts","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","type":"topic","kind":"article","abstract":[]},"OperationsOnNonFungibleTokensSection4Step2.swift":{"highlights":[{"line":118},{"line":119},{"line":120},{"line":121},{"line":122},{"line":123},{"line":124}],"identifier":"OperationsOnNonFungibleTokensSection4Step2.swift","syntax":"swift","fileType":"swift","type":"file","fileName":"lib.swift","content":["import SpaceKit","","@Controller struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: Buffer","    ","    public func issueSemiFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    public func setAllRoles() {","        assertOwner()","        ","        guard !self.$issuedTokenIdentifier.isEmpty() else {","            smartContractError(message: \"Token not issued\")","        }","        ","        Blockchain","            .setTokenRoles(","                for: Blockchain.getSCAddress(),","                tokenIdentifier: self.issuedTokenIdentifier,","                roles: EsdtLocalRoles(","                    canCreateNft: true,","                    canAddNftQuantity: true,","                    canBurnNft: true","                )","            )","            .registerPromise(","                gas: 60_000_000,","            )","    }","    ","    public func createNewNonce(initialQuantity: BigUint) -> UInt64 {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftCreate) else {","            smartContractError(message: \"Cannot create new nonces\")","        }","        ","        let newNonce = Blockchain","            .createNft(","                tokenIdentifier: self.issuedTokenIdentifier,","                amount: initialQuantity,","                name: \"MySemiFungibleToken\",","                royalties: 0,","                hash: \"\",","                attributes: Buffer(),","                uris: Vector()","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: newNonce,","                amount: initialQuantity","            )","        ","        return newNonce","    }","    ","    public func addQuantity(","        nonce: UInt64,","        amount: BigUint","    ) {","        assertOwner()","        ","        let tokenRoles = Blockchain.getESDTLocalRoles(tokenIdentifier: self.issuedTokenIdentifier)","        ","        guard tokenRoles.contains(flag: .nftAddQuantity) else {","            smartContractError(message: \"Cannot add quantity\")","        }","        ","        Blockchain","            .mintTokens(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","        ","        Message.caller","            .send(","                tokenIdentifier: self.issuedTokenIdentifier,","                nonce: nonce,","                amount: amount","            )","    }","    ","    public func burnTokens(","        nonce: UInt64,","        burnAmount: BigUint","    ) {","        assertOwner()","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""]}}}

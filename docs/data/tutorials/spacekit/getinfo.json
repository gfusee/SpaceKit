{"identifier":{"url":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","interfaceLanguage":"swift"},"variants":[{"paths":["\/tutorials\/spacekit\/getinfo"],"traits":[{"interfaceLanguage":"swift"}]}],"sections":[{"kind":"hero","chapter":"Retrieving Information from the Blockchain","title":"Retrieving Information from the Blockchain","estimatedTimeInMinutes":10,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}]},{"inlineContent":[{"type":"text","text":"The SpaceKit framework provides an intuitive way to retrieve all of this information using the "},{"type":"codeVoice","code":"Message"},{"type":"text","text":" and "},{"code":"Blockchain","type":"codeVoice"},{"type":"text","text":" objects."}],"type":"paragraph"}]},{"tasks":[{"anchor":"Accessing-Transaction-Context-Data","contentSection":[{"kind":"contentAndMedia","mediaPosition":"trailing","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In this section, you will create a simple smart contract that allows users to deposit a specified fungible token. The contract will track the total amount of tokens deposited by each user."}]}]}],"title":"Accessing Transaction Context Data","stepsSection":[{"runtimePreview":null,"caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Start by defining the contract’s basic structure."}]}],"code":"GetInfoSection1Step1.swift","type":"step","media":null},{"content":[{"inlineContent":[{"text":"Track the specific token type to be deposited. Store its identifier in the contract’s storage using a ","type":"text"},{"type":"codeVoice","code":"@Storage"},{"type":"text","text":" variable."}],"type":"paragraph"}],"caption":[{"inlineContent":[{"type":"text","text":"Note: This variable will be initialized later in the contract’s "},{"code":"init","type":"codeVoice"},{"type":"text","text":" function."}],"type":"paragraph"}],"runtimePreview":null,"type":"step","media":null,"code":"GetInfoSection1Step2.swift"},{"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Reminder: Numeric storage variables default to 0."}]}],"media":null,"content":[{"inlineContent":[{"type":"text","text":"Create a "},{"type":"codeVoice","code":"@Mapping"},{"text":" variable to keep track of the total amount deposited by each user.","type":"text"}],"type":"paragraph"}],"code":"GetInfoSection1Step3.swift","type":"step","runtimePreview":null},{"caption":[],"media":null,"runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Add an initializer to the contract, which accepts the token identifier as a parameter."}]}],"code":"GetInfoSection1Step4.swift","type":"step"},{"code":"GetInfoSection1Step5.swift","caption":[],"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define the "},{"code":"deposit","type":"codeVoice"},{"type":"text","text":" endpoint for the contract."}]}],"media":null,"runtimePreview":null},{"caption":[],"code":"GetInfoSection1Step6.swift","media":null,"runtimePreview":null,"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Use the ","type":"text"},{"code":"Message.caller","type":"codeVoice"},{"text":" property to retrieve the address of the user making the deposit.","type":"text"}]}]},{"code":"GetInfoSection1Step7.swift","type":"step","caption":[{"inlineContent":[{"type":"text","text":"Note: The "},{"code":"Message","type":"codeVoice"},{"text":" object also allows retrieval of multi payments, non-fungible tokens, and EGLD payments.","type":"text"}],"type":"paragraph"}],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Access the single fungible token payment using "},{"code":"Message.singleFungibleEsdt","type":"codeVoice"},{"text":". If the transaction doesn’t include exactly one fungible token payment, the transaction will fail.","type":"text"}]}],"media":null,"runtimePreview":null},{"type":"step","runtimePreview":null,"code":"GetInfoSection1Step8.swift","caption":[],"content":[{"type":"paragraph","inlineContent":[{"text":"Verify the payment by comparing the token identifier with the stored value.","type":"text"}]}],"media":null},{"media":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Add the payment amount to the storage mapping for the caller’s address."}]}],"code":"GetInfoSection1Step9.swift","runtimePreview":null,"type":"step","caption":[]}]},{"stepsSection":[{"runtimePreview":null,"media":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Start by using the contract from the previous section."}]}],"type":"step","caption":[],"code":"GetInfoSection2Step1.swift"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define a global constant representing the number of seconds in a day."}]}],"caption":[],"code":"GetInfoSection2Step2.swift","runtimePreview":null,"media":null,"type":"step"},{"code":"GetInfoSection2Step3.swift","caption":[],"media":null,"type":"step","runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"Add a mapping to store the last deposit time for each user."}],"type":"paragraph"}]},{"code":"GetInfoSection2Step4.swift","content":[{"type":"paragraph","inlineContent":[{"text":"In the ","type":"text"},{"code":"deposit","type":"codeVoice"},{"type":"text","text":" endpoint, retrieve the current timestamp using "},{"code":"Blockchain.getBlockTimestamp()","type":"codeVoice"},{"type":"text","text":"."}]}],"runtimePreview":null,"caption":[{"inlineContent":[{"text":"Note: The timestamp is the number of seconds since January 1, 1970.","type":"text"}],"type":"paragraph"}],"type":"step","media":null},{"caption":[],"media":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Retrieve the last deposit time for the caller from the storage.","type":"text"}]}],"code":"GetInfoSection2Step5.swift","runtimePreview":null,"type":"step"},{"code":"GetInfoSection2Step6.swift","runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"Compute the next allowed deposit time by adding one day’s worth of seconds to the last deposit time."}],"type":"paragraph"}],"caption":[],"media":null,"type":"step"},{"type":"step","code":"GetInfoSection2Step7.swift","content":[{"type":"paragraph","inlineContent":[{"text":"Ensure the caller is allowed to deposit now.","type":"text"}]}],"media":null,"caption":[],"runtimePreview":null},{"content":[{"inlineContent":[{"text":"If the deposit isn’t allowed yet, calculate the remaining time before the next deposit is permitted.","type":"text"}],"type":"paragraph"}],"runtimePreview":null,"caption":[],"media":null,"type":"step","code":"GetInfoSection2Step8.swift"},{"runtimePreview":null,"code":"GetInfoSection2Step9.swift","media":null,"type":"step","caption":[{"inlineContent":[{"type":"text","text":"Tip: You can interpolate buffers, addresses, and numeric types into string literals when creating error messages."}],"type":"paragraph"}],"content":[{"type":"paragraph","inlineContent":[{"text":"Use the calculated time to return an error message with the remaining time.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Retrieve the caller’s token balance using "},{"type":"codeVoice","code":"Blockchain.getBalance()"},{"type":"text","text":"."}],"type":"paragraph"}],"type":"step","media":null,"runtimePreview":null,"code":"GetInfoSection2Step10.swift","caption":[{"type":"paragraph","inlineContent":[{"text":"Tip: If no token identifier is provided, the EGLD balance is returned.","type":"text"}]}]},{"code":"GetInfoSection2Step11.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Calculate the maximum allowable deposit by dividing the caller’s token balance by 10."}]}],"type":"step","runtimePreview":null,"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Note: Be cautious when performing integer division as any fractional part is discarded."}]}],"media":null},{"content":[{"type":"paragraph","inlineContent":[{"text":"Ensure the deposit amount does not exceed the maximum allowable limit.","type":"text"}]}],"type":"step","caption":[],"code":"GetInfoSection2Step12.swift","runtimePreview":null,"media":null},{"code":"GetInfoSection2Step13.swift","runtimePreview":null,"caption":[],"content":[{"inlineContent":[{"text":"Update the last deposit time for the caller to the current block timestamp.","type":"text"}],"type":"paragraph"}],"type":"step","media":null}],"contentSection":[{"mediaPosition":"trailing","content":[{"type":"paragraph","inlineContent":[{"text":"In this section, you will improve the previous contract by adding constraints: each address can deposit only once every 24 hours, and deposits must not exceed 10% of the user’s token balance.","type":"text"}]}],"kind":"contentAndMedia"}],"anchor":"Accessing-Blockchain-Context-Data","title":"Accessing Blockchain Context Data"}],"kind":"tasks"},{"kind":"callToAction","abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}],"title":"Interact with Other Contracts","action":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls","type":"reference","overridingTitle":"Get started","overridingTitleInlineContent":[{"text":"Get started","type":"text"}],"isActive":true},"featuredEyebrow":"Tutorial"}],"metadata":{"role":"project","category":"SpaceKit","categoryPathComponent":"SpaceKit","title":"Retrieving Information from the Blockchain"},"hierarchy":{"paths":[["doc:\/\/SpaceKit\/tutorials\/SpaceKit","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain"]],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","modules":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes"}]},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions"},{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call"}]}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards"},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens"},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint","kind":"task"}]}]}]},"kind":"project","schemaVersion":{"major":0,"minor":3,"patch":0},"references":{"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Burn-Tokens":{"role":"pseudoSymbol","abstract":[{"text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","kind":"section","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Burn-Tokens","type":"section","title":"Burn Tokens"},"GetInfoSection1Step2.swift":{"highlights":[{"line":4}],"fileName":"lib.swift","identifier":"GetInfoSection1Step2.swift","content":["import SpaceKit","","@Controller public struct MyController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","}"],"type":"file","fileType":"swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract":{"role":"project","estimatedTime":"20min","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"kind":"project","url":"\/tutorials\/spacekit\/codingyourfirstcontract","type":"topic","title":"Building Your First Smart Contract"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens":{"abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens","title":"Managing Non-Fungible Tokens","type":"topic","kind":"project","estimatedTime":"15min","role":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Exploring-SpaceKit's-Types":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","kind":"article","type":"topic","abstract":[],"role":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/exploring-spacekit's-types","title":"Exploring SpaceKit's Types"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls","kind":"project","type":"topic","abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}],"role":"project","url":"\/tutorials\/spacekit\/synccalls","estimatedTime":"15min","title":"Interact with Other Contracts"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Understanding-the-Buffer-Type":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","url":"\/tutorials\/spacekit\/familiarizewithtypes#Understanding-the-Buffer-Type","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"kind":"section","title":"Understanding the Buffer Type","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Calling-Contracts-Across-Shards":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/calling-contracts-across-shards","abstract":[],"kind":"article","title":"Calling Contracts Across Shards","type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Installing-the-Tools":{"abstract":[],"kind":"article","title":"Installing the Tools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools","url":"\/tutorials\/spacekit\/getting-started\/installing-the-tools","type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Creating-and-Understanding-Tokens":{"role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","abstract":[],"kind":"article","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/creating-and-understanding-tokens","type":"topic","title":"Creating and Understanding Tokens"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract","kind":"section","type":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Meta-ESDT-from-Your-Contract","title":"Issuing a Meta ESDT from Your Contract"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Declare-the-Callee-Proxy":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","kind":"section","type":"section","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/asynccalls#Declare-the-Callee-Proxy","title":"Declare the Callee Proxy"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Writing-the-Contract-Code":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"kind":"section","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Writing-the-Contract-Code","type":"section","title":"Writing the Contract Code"},"GetInfoSection1Step9.swift":{"identifier":"GetInfoSection1Step9.swift","content":["import SpaceKit","","@Init func initialize(tokenIdentifier: TokenIdentifier) {","    var controller = MyController()","    ","    controller.tokenIdentifier = tokenIdentifier","}","","@Controller public struct MyController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Mapping<Address, BigUint>(key: \"depositedTokens\") var depositedTokensForAddress","    ","    public mutating func deposit() {","        let caller = Message.caller","        let payment = Message.singleFungibleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment provided\")","        }","        ","        self.depositedTokensForAddress[caller] = self.depositedTokensForAddress[caller] + payment.amount","    }","}"],"fileType":"swift","syntax":"swift","fileName":"lib.swift","type":"file","highlights":[{"line":20},{"line":21}]},"GetInfoSection2Step13.swift":{"highlights":[{"line":42}],"fileName":"lib.swift","identifier":"GetInfoSection2Step13.swift","content":["import SpaceKit","","let secondsInADay: UInt64 = 86_400","","@Init func initialize(tokenIdentifier: TokenIdentifier) {","    var controller = MyController()","    ","    controller.tokenIdentifier = tokenIdentifier","}","","@Controller public struct MyController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Mapping<Address, UInt64>(key: \"lastDepositTime\") var lastDepositTimeForAddress","    @Mapping<Address, BigUint>(key: \"depositedTokens\") var depositedTokensForAddress","    ","    public mutating func deposit() {","        let caller = Message.caller","        let payment = Message.singleFungibleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment provided\")","        }","        ","        let callerLastDepositTime = self.lastDepositTimeForAddress[caller]","        let currentTime = Blockchain.getBlockTimestamp()","        let nextAllowedTime = callerLastDepositTime + secondsInADay","        ","        guard currentTime > nextAllowedTime else {","            let secondsRemaining = nextAllowedTime - currentTime","            ","            smartContractError(message: \"Not allowed to deposit yet. Please wait \\(secondsRemaining) seconds.\")","        }","        ","        let callerTokenBalance = caller.getBalance(tokenIdentifier: payment.tokenIdentifier)","        let maxAllowedDeposit = callerTokenBalance \/ 10","        ","        guard payment.amount <= maxAllowedDeposit else {","            smartContractError(message: \"Payment amount should not be greater than 10% of the caller's balance for the token. Allowance: \\(maxAllowedDeposit)\")","        }","        ","        self.depositedTokensForAddress[caller] = self.depositedTokensForAddress[caller] + payment.amount","        self.lastDepositTimeForAddress[caller] = currentTime","    }","}"],"type":"file","fileType":"swift","syntax":"swift"},"GetInfoSection1Step3.swift":{"identifier":"GetInfoSection1Step3.swift","content":["import SpaceKit","","@Controller public struct MyController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Mapping<Address, BigUint>(key: \"depositedTokens\") var depositedTokensForAddress","}"],"fileType":"swift","syntax":"swift","fileName":"lib.swift","type":"file","highlights":[{"line":5}]},"GetInfoSection1Step8.swift":{"highlights":[{"line":16},{"line":17},{"line":18},{"line":19}],"fileName":"lib.swift","identifier":"GetInfoSection1Step8.swift","content":["import SpaceKit","","@Init func initialize(tokenIdentifier: TokenIdentifier) {","    var controller = MyController()","    ","    controller.tokenIdentifier = tokenIdentifier","}","","@Controller public struct MyController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Mapping<Address, BigUint>(key: \"depositedTokens\") var depositedTokensForAddress","    ","    public mutating func deposit() {","        let caller = Message.caller","        let payment = Message.singleFungibleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment provided\")","        }","    }","}"],"type":"file","fileType":"swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract":{"title":"Issuing a Fungible Token from Your Contract","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","kind":"section","type":"section","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Fungible-Token-from-Your-Contract","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}]},"GetInfoSection1Step1.swift":{"identifier":"GetInfoSection1Step1.swift","content":["import SpaceKit","","@Controller public struct MyController {","    ","}"],"fileType":"swift","syntax":"swift","fileName":"lib.swift","type":"file","highlights":[]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce":{"title":"Add Quantity to an Existing Nonce","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce","kind":"section","type":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Add-Quantity-to-an-Existing-Nonce","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}]},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls":{"title":"Interacting with Contracts Across Shards","role":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","kind":"project","type":"topic","estimatedTime":"15min","url":"\/tutorials\/spacekit\/asynccalls","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}]},"GetInfoSection2Step1.swift":{"highlights":[],"fileName":"lib.swift","identifier":"GetInfoSection2Step1.swift","content":["import SpaceKit","","@Init func initialize(tokenIdentifier: TokenIdentifier) {","    var controller = MyController()","    ","    controller.tokenIdentifier = tokenIdentifier","}","","@Controller public struct MyController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Mapping<Address, BigUint>(key: \"depositedTokens\") var depositedTokensForAddress","    ","    public mutating func deposit() {","        let caller = Message.caller","        let payment = Message.singleFungibleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment provided\")","        }","        ","        self.depositedTokensForAddress[caller] = self.depositedTokensForAddress[caller] + payment.amount","    }","}"],"type":"file","fileType":"swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Create-a-New-Nonce":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce","kind":"section","type":"section","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Create-a-New-Nonce","title":"Create a New Nonce"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","estimatedTime":"10min","kind":"project","abstract":[{"text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner.","type":"text"}],"url":"\/tutorials\/spacekit\/getinfo","title":"Retrieving Information from the Blockchain","type":"topic","role":"project"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract":{"abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"url":"\/tutorials\/spacekit\/installingtools#Initializing-and-Compiling-Your-First-Smart-Contract","title":"Initializing and Compiling Your First Smart Contract","type":"section","kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Interacting-with-Other-Contracts":{"title":"Interacting with Other Contracts","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/interacting-with-other-contracts","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","type":"topic","kind":"article","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/StoreValues":{"role":"project","estimatedTime":"15min","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"kind":"project","url":"\/tutorials\/spacekit\/storevalues","type":"topic","title":"Persist Values Between Executions"},"GetInfoSection2Step10.swift":{"identifier":"GetInfoSection2Step10.swift","content":["import SpaceKit","","let secondsInADay: UInt64 = 86_400","","@Init func initialize(tokenIdentifier: TokenIdentifier) {","    var controller = MyController()","    ","    controller.tokenIdentifier = tokenIdentifier","}","","@Controller public struct MyController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Mapping<Address, UInt64>(key: \"lastDepositTime\") var lastDepositTimeForAddress","    @Mapping<Address, BigUint>(key: \"depositedTokens\") var depositedTokensForAddress","    ","    public mutating func deposit() {","        let caller = Message.caller","        let payment = Message.singleFungibleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment provided\")","        }","        ","        let currentTime = Blockchain.getBlockTimestamp()","        let callerLastDepositTime = self.lastDepositTimeForAddress[caller]","        let nextAllowedTime = callerLastDepositTime + secondsInADay","        ","        guard currentTime > nextAllowedTime else {","            let secondsRemaining = nextAllowedTime - currentTime","            ","            smartContractError(message: \"Not allowed to deposit yet. Please wait \\(secondsRemaining) seconds.\")","        }","        ","        let callerTokenBalance = caller.getBalance(tokenIdentifier: payment.tokenIdentifier)","        ","        self.depositedTokensForAddress[caller] = self.depositedTokensForAddress[caller] + payment.amount","    }","}"],"fileType":"swift","syntax":"swift","fileName":"lib.swift","type":"file","highlights":[{"line":34},{"line":35}]},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Declare-the-Callee-Proxy":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","url":"\/tutorials\/spacekit\/synccalls#Declare-the-Callee-Proxy","abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}],"kind":"section","title":"Declare the Callee Proxy","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","kind":"section","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"text":" ","type":"text"},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","title":"Issuing a Non-Fungible Token from Your Contract","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Creating-Your-Own-Types":{"title":"Creating Your Own Types","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types","kind":"section","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Creating-Your-Own-Types","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}]},"GetInfoSection1Step7.swift":{"highlights":[{"line":15}],"fileName":"lib.swift","identifier":"GetInfoSection1Step7.swift","content":["import SpaceKit","","@Init func initialize(tokenIdentifier: TokenIdentifier) {","    var controller = MyController()","    ","    controller.tokenIdentifier = tokenIdentifier","}","","@Controller public struct MyController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Mapping<Address, BigUint>(key: \"depositedTokens\") var depositedTokensForAddress","    ","    public mutating func deposit() {","        let caller = Message.caller","        let payment = Message.singleFungibleEsdt","    }","}"],"type":"file","fileType":"swift","syntax":"swift"},"GetInfoSection2Step3.swift":{"identifier":"GetInfoSection2Step3.swift","content":["import SpaceKit","","let secondsInADay: UInt64 = 86_400","","@Init func initialize(tokenIdentifier: TokenIdentifier) {","    var controller = MyController()","    ","    controller.tokenIdentifier = tokenIdentifier","}","","@Controller public struct MyController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Mapping<Address, UInt64>(key: \"lastDepositTime\") var lastDepositTimeForAddress","    @Mapping<Address, BigUint>(key: \"depositedTokens\") var depositedTokensForAddress","    ","    public mutating func deposit() {","        let caller = Message.caller","        let payment = Message.singleFungibleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment provided\")","        }","        ","        self.depositedTokensForAddress[caller] = self.depositedTokensForAddress[caller] + payment.amount","    }","}"],"fileType":"swift","syntax":"swift","fileName":"lib.swift","type":"file","highlights":[{"line":13}]},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Enhancing-Contracts-with-Token-Attributes":{"abstract":[],"title":"Enhancing Contracts with Token Attributes","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/enhancing-contracts-with-token-attributes","kind":"article","role":"article"},"GetInfoSection2Step12.swift":{"highlights":[{"line":25},{"line":37},{"line":38},{"line":39},{"line":40}],"fileName":"lib.swift","identifier":"GetInfoSection2Step12.swift","content":["import SpaceKit","","let secondsInADay: UInt64 = 86_400","","@Init func initialize(tokenIdentifier: TokenIdentifier) {","    var controller = MyController()","    ","    controller.tokenIdentifier = tokenIdentifier","}","","@Controller public struct MyController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Mapping<Address, UInt64>(key: \"lastDepositTime\") var lastDepositTimeForAddress","    @Mapping<Address, BigUint>(key: \"depositedTokens\") var depositedTokensForAddress","    ","    public mutating func deposit() {","        let caller = Message.caller","        let payment = Message.singleFungibleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment provided\")","        }","        ","        let callerLastDepositTime = self.lastDepositTimeForAddress[caller]","        let currentTime = Blockchain.getBlockTimestamp()","        let nextAllowedTime = callerLastDepositTime + secondsInADay","        ","        guard currentTime > nextAllowedTime else {","            let secondsRemaining = nextAllowedTime - currentTime","            ","            smartContractError(message: \"Not allowed to deposit yet. Please wait \\(secondsRemaining) seconds.\")","        }","        ","        let callerTokenBalance = caller.getBalance(tokenIdentifier: payment.tokenIdentifier)","        let maxAllowedDeposit = callerTokenBalance \/ 10","        ","        guard payment.amount <= maxAllowedDeposit else {","            smartContractError(message: \"Payment amount should not be greater than 10% of the caller's balance for the token. Allowance: \\(maxAllowedDeposit)\")","        }","        ","        self.depositedTokensForAddress[caller] = self.depositedTokensForAddress[caller] + payment.amount","    }","}"],"type":"file","fileType":"swift","syntax":"swift"},"GetInfoSection2Step6.swift":{"identifier":"GetInfoSection2Step6.swift","content":["import SpaceKit","","let secondsInADay: UInt64 = 86_400","","@Init func initialize(tokenIdentifier: TokenIdentifier) {","    var controller = MyController()","    ","    controller.tokenIdentifier = tokenIdentifier","}","","@Controller public struct MyController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Mapping<Address, UInt64>(key: \"lastDepositTime\") var lastDepositTimeForAddress","    @Mapping<Address, BigUint>(key: \"depositedTokens\") var depositedTokensForAddress","    ","    public mutating func deposit() {","        let caller = Message.caller","        let payment = Message.singleFungibleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment provided\")","        }","        ","        let currentTime = Blockchain.getBlockTimestamp()","        let callerLastDepositTime = self.lastDepositTimeForAddress[caller]","        let nextAllowedTime = callerLastDepositTime + secondsInADay","        ","        self.depositedTokensForAddress[caller] = self.depositedTokensForAddress[caller] + payment.amount","    }","}"],"fileType":"swift","syntax":"swift","fileName":"lib.swift","type":"file","highlights":[{"line":26}]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes","kind":"project","type":"topic","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"role":"project","url":"\/tutorials\/spacekit\/familiarizewithtypes","estimatedTime":"20min","title":"Exploring SpaceKit's Types"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Working-with-Storage-for-Single-Value-Persistence":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence","url":"\/tutorials\/spacekit\/storevalues#Working-with-Storage-for-Single-Value-Persistence","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"kind":"section","title":"Working with @Storage for Single Value Persistence","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","kind":"project","type":"topic","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"role":"project","url":"\/tutorials\/spacekit\/installingtools","estimatedTime":"10min","title":"Install the Necessary Tools"},"GetInfoSection2Step9.swift":{"highlights":[{"line":30},{"line":31}],"fileName":"lib.swift","identifier":"GetInfoSection2Step9.swift","content":["import SpaceKit","","let secondsInADay: UInt64 = 86_400","","@Init func initialize(tokenIdentifier: TokenIdentifier) {","    var controller = MyController()","    ","    controller.tokenIdentifier = tokenIdentifier","}","","@Controller public struct MyController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Mapping<Address, UInt64>(key: \"lastDepositTime\") var lastDepositTimeForAddress","    @Mapping<Address, BigUint>(key: \"depositedTokens\") var depositedTokensForAddress","    ","    public mutating func deposit() {","        let caller = Message.caller","        let payment = Message.singleFungibleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment provided\")","        }","        ","        let currentTime = Blockchain.getBlockTimestamp()","        let callerLastDepositTime = self.lastDepositTimeForAddress[caller]","        let nextAllowedTime = callerLastDepositTime + secondsInADay","        ","        guard currentTime > nextAllowedTime else {","            let secondsRemaining = nextAllowedTime - currentTime","            ","            smartContractError(message: \"Not allowed to deposit yet. Please wait \\(secondsRemaining) seconds.\")","        }","        ","        self.depositedTokensForAddress[caller] = self.depositedTokensForAddress[caller] + payment.amount","    }","}"],"type":"file","fileType":"swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"kind":"section","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","type":"section","title":"Issuing a Semi-Fungible Token from Your Contract"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes":{"abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"url":"\/tutorials\/spacekit\/tokenattributes","title":"Enhance Your Contracts with Token Attributes","type":"topic","kind":"project","estimatedTime":"15min","role":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes"},"GetInfoSection2Step8.swift":{"highlights":[{"line":29}],"fileType":"swift","type":"file","content":["import SpaceKit","","let secondsInADay: UInt64 = 86_400","","@Init func initialize(tokenIdentifier: TokenIdentifier) {","    var controller = MyController()","    ","    controller.tokenIdentifier = tokenIdentifier","}","","@Controller public struct MyController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Mapping<Address, UInt64>(key: \"lastDepositTime\") var lastDepositTimeForAddress","    @Mapping<Address, BigUint>(key: \"depositedTokens\") var depositedTokensForAddress","    ","    public mutating func deposit() {","        let caller = Message.caller","        let payment = Message.singleFungibleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment provided\")","        }","        ","        let currentTime = Blockchain.getBlockTimestamp()","        let callerLastDepositTime = self.lastDepositTimeForAddress[caller]","        let nextAllowedTime = callerLastDepositTime + secondsInADay","        ","        guard currentTime > nextAllowedTime else {","            let secondsRemaining = nextAllowedTime - currentTime","        }","        ","        self.depositedTokensForAddress[caller] = self.depositedTokensForAddress[caller] + payment.amount","    }","}"],"fileName":"lib.swift","syntax":"swift","identifier":"GetInfoSection2Step8.swift"},"doc://SpaceKit/tutorials/SpaceKit":{"title":"Meet SpaceKit","url":"\/tutorials\/spacekit","role":"overview","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","type":"topic","kind":"overview","abstract":[{"text":"Discover how SpaceKit simplifies blockchain development using Swift. Dive into the world of Web3 with ease and efficiency.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint":{"title":"Implementing the changeTokenLockDuration Endpoint","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint","kind":"section","type":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-changeTokenLockDuration-Endpoint","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}]},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-unlockFunds-Endpoint":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"kind":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-unlockFunds-Endpoint","type":"section","title":"Implementing the unlockFunds Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Installing-SpaceKits-Dependencies":{"kind":"section","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","url":"\/tutorials\/spacekit\/installingtools#Installing-SpaceKits-Dependencies","title":"Installing SpaceKit's Dependencies","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Perform-a-Synchronous-Call":{"title":"Perform a Synchronous Call","url":"\/tutorials\/spacekit\/synccalls#Perform-a-Synchronous-Call","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","type":"section","kind":"section","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Transaction-Context-Data":{"title":"Accessing Transaction Context Data","url":"\/tutorials\/spacekit\/getinfo#Accessing-Transaction-Context-Data","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","type":"section","kind":"section","abstract":[{"text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner.","type":"text"}]},"GetInfoSection1Step5.swift":{"highlights":[{"line":12},{"line":13},{"line":14},{"line":15}],"identifier":"GetInfoSection1Step5.swift","type":"file","fileType":"swift","fileName":"lib.swift","syntax":"swift","content":["import SpaceKit","","@Init func initialize(tokenIdentifier: TokenIdentifier) {","    var controller = MyController()","    ","    controller.tokenIdentifier = tokenIdentifier","}","","@Controller public struct MyController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Mapping<Address, BigUint>(key: \"depositedTokens\") var depositedTokensForAddress","    ","    public mutating func deposit() {","        ","    }","}"]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges":{"title":"Handling Heap Allocation Challenges","role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Handling-Heap-Allocation-Challenges","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Retrieving-Information-from-the-Blockchain":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","kind":"article","type":"topic","abstract":[],"role":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/retrieving-information-from-the-blockchain","title":"Retrieving Information from the Blockchain"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Initializing-the-Project":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"kind":"section","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Initializing-the-Project","type":"section","title":"Initializing the Project"},"GetInfoSection2Step7.swift":{"highlights":[{"line":28},{"line":29},{"line":30},{"line":31}],"fileType":"swift","type":"file","content":["import SpaceKit","","let secondsInADay: UInt64 = 86_400","","@Init func initialize(tokenIdentifier: TokenIdentifier) {","    var controller = MyController()","    ","    controller.tokenIdentifier = tokenIdentifier","}","","@Controller public struct MyController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Mapping<Address, UInt64>(key: \"lastDepositTime\") var lastDepositTimeForAddress","    @Mapping<Address, BigUint>(key: \"depositedTokens\") var depositedTokensForAddress","    ","    public mutating func deposit() {","        let caller = Message.caller","        let payment = Message.singleFungibleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment provided\")","        }","        ","        let currentTime = Blockchain.getBlockTimestamp()","        let callerLastDepositTime = self.lastDepositTimeForAddress[caller]","        let nextAllowedTime = callerLastDepositTime + secondsInADay","        ","        guard currentTime > nextAllowedTime else {","            ","        }","        ","        self.depositedTokensForAddress[caller] = self.depositedTokensForAddress[caller] + payment.amount","    }","}"],"fileName":"lib.swift","syntax":"swift","identifier":"GetInfoSection2Step7.swift"},"GetInfoSection1Step6.swift":{"identifier":"GetInfoSection1Step6.swift","content":["import SpaceKit","","@Init func initialize(tokenIdentifier: TokenIdentifier) {","    var controller = MyController()","    ","    controller.tokenIdentifier = tokenIdentifier","}","","@Controller public struct MyController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Mapping<Address, BigUint>(key: \"depositedTokens\") var depositedTokensForAddress","    ","    public mutating func deposit() {","        let caller = Message.caller","    }","}"],"type":"file","fileType":"swift","highlights":[{"line":14}],"fileName":"lib.swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-BigUint-Type":{"title":"Working with the BigUint Type","url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-BigUint-Type","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","type":"section","kind":"section","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}]},"GetInfoSection1Step4.swift":{"syntax":"swift","content":["import SpaceKit","","@Init func initialize(tokenIdentifier: TokenIdentifier) {","    var controller = MyController()","    ","    controller.tokenIdentifier = tokenIdentifier","}","","@Controller public struct MyController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Mapping<Address, BigUint>(key: \"depositedTokens\") var depositedTokensForAddress","}"],"fileName":"lib.swift","fileType":"swift","type":"file","identifier":"GetInfoSection1Step4.swift","highlights":[{"line":3},{"line":4},{"line":5},{"line":6},{"line":7},{"line":8}]},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Blockchain-Context-Data":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data","kind":"section","type":"section","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/getinfo#Accessing-Blockchain-Context-Data","title":"Accessing Blockchain Context Data"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","kind":"section","abstract":[{"text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with.","type":"text"}],"url":"\/tutorials\/spacekit\/operationsonfungibletokens#Assign-Mint-and-Burn-Roles","title":"Assign Mint and Burn Roles","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-Vector-Type":{"abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-Vector-Type","title":"Working with the Vector Type","type":"section","kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Setting-Up-the-SpaceKit-CLI":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"kind":"section","url":"\/tutorials\/spacekit\/installingtools#Setting-Up-the-SpaceKit-CLI","type":"section","title":"Setting Up the SpaceKit CLI"},"GetInfoSection2Step4.swift":{"fileName":"lib.swift","fileType":"swift","type":"file","highlights":[{"line":24},{"line":25}],"syntax":"swift","identifier":"GetInfoSection2Step4.swift","content":["import SpaceKit","","let secondsInADay: UInt64 = 86_400","","@Init func initialize(tokenIdentifier: TokenIdentifier) {","    var controller = MyController()","    ","    controller.tokenIdentifier = tokenIdentifier","}","","@Controller public struct MyController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Mapping<Address, UInt64>(key: \"lastDepositTime\") var lastDepositTimeForAddress","    @Mapping<Address, BigUint>(key: \"depositedTokens\") var depositedTokensForAddress","    ","    public mutating func deposit() {","        let caller = Message.caller","        let payment = Message.singleFungibleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment provided\")","        }","        ","        let currentTime = Blockchain.getBlockTimestamp()","        ","        self.depositedTokensForAddress[caller] = self.depositedTokensForAddress[caller] + payment.amount","    }","}"]},"GetInfoSection2Step5.swift":{"content":["import SpaceKit","","let secondsInADay: UInt64 = 86_400","","@Init func initialize(tokenIdentifier: TokenIdentifier) {","    var controller = MyController()","    ","    controller.tokenIdentifier = tokenIdentifier","}","","@Controller public struct MyController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Mapping<Address, UInt64>(key: \"lastDepositTime\") var lastDepositTimeForAddress","    @Mapping<Address, BigUint>(key: \"depositedTokens\") var depositedTokensForAddress","    ","    public mutating func deposit() {","        let caller = Message.caller","        let payment = Message.singleFungibleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment provided\")","        }","        ","        let currentTime = Blockchain.getBlockTimestamp()","        let callerLastDepositTime = self.lastDepositTimeForAddress[caller]","        ","        self.depositedTokensForAddress[caller] = self.depositedTokensForAddress[caller] + payment.amount","    }","}"],"highlights":[{"line":25}],"identifier":"GetInfoSection2Step5.swift","fileType":"swift","syntax":"swift","fileName":"lib.swift","type":"file"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Perform-an-Asynchronous-Call":{"abstract":[{"text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources.","type":"text"}],"url":"\/tutorials\/spacekit\/asynccalls#Perform-an-Asynchronous-Call","title":"Perform an Asynchronous Call","type":"section","kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Mint-New-Tokens":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","kind":"section","type":"section","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Mint-New-Tokens","title":"Mint New Tokens"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles":{"title":"Assign Create, AddQuantity, and Burn Roles","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","kind":"section","type":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Assign-Create-AddQuantity-and-Burn-Roles","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}]},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens","kind":"project","type":"topic","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"role":"project","url":"\/tutorials\/spacekit\/understandtokens","estimatedTime":"15min","title":"Understand the ESDT Standard"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens":{"title":"Managing Fungible Tokens","role":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","kind":"project","type":"topic","estimatedTime":"15min","url":"\/tutorials\/spacekit\/operationsonfungibletokens","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}]},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-lockFunds-Endpoint":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint","kind":"section","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-lockFunds-Endpoint","title":"Implementing the lockFunds Endpoint","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Building-Your-First-Smart-Contract":{"role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","abstract":[],"kind":"article","url":"\/tutorials\/spacekit\/getting-started\/building-your-first-smart-contract","type":"topic","title":"Building Your First Smart Contract"},"GetInfoSection2Step11.swift":{"highlights":[{"line":35}],"type":"file","content":["import SpaceKit","","let secondsInADay: UInt64 = 86_400","","@Init func initialize(tokenIdentifier: TokenIdentifier) {","    var controller = MyController()","    ","    controller.tokenIdentifier = tokenIdentifier","}","","@Controller public struct MyController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Mapping<Address, UInt64>(key: \"lastDepositTime\") var lastDepositTimeForAddress","    @Mapping<Address, BigUint>(key: \"depositedTokens\") var depositedTokensForAddress","    ","    public mutating func deposit() {","        let caller = Message.caller","        let payment = Message.singleFungibleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment provided\")","        }","        ","        let currentTime = Blockchain.getBlockTimestamp()","        let callerLastDepositTime = self.lastDepositTimeForAddress[caller]","        let nextAllowedTime = callerLastDepositTime + secondsInADay","        ","        guard currentTime > nextAllowedTime else {","            let secondsRemaining = nextAllowedTime - currentTime","            ","            smartContractError(message: \"Not allowed to deposit yet. Please wait \\(secondsRemaining) seconds.\")","        }","        ","        let callerTokenBalance = caller.getBalance(tokenIdentifier: payment.tokenIdentifier)","        let maxAllowedDeposit = callerTokenBalance \/ 10","        ","        self.depositedTokensForAddress[caller] = self.depositedTokensForAddress[caller] + payment.amount","    }","}"],"fileName":"lib.swift","identifier":"GetInfoSection2Step11.swift","syntax":"swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Non-Fungible-Tokens":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-non-fungible-tokens","abstract":[],"kind":"article","title":"Managing Non-Fungible Tokens","type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Burn-Tokens":{"abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"kind":"section","title":"Burn Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Burn-Tokens","type":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Persisting-Data-Across-Executions":{"title":"Persisting Data Across Executions","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/persisting-data-across-executions","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","type":"topic","kind":"article","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Fungible-Tokens":{"abstract":[],"kind":"article","title":"Managing Fungible Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-fungible-tokens","type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"kind":"section","url":"\/tutorials\/spacekit\/storevalues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","type":"section","title":"Leveraging @Mapping for Dynamic Key-Value Storage"},"GetInfoSection2Step2.swift":{"highlights":[{"line":3},{"line":4}],"fileType":"swift","content":["import SpaceKit","","let secondsInADay: UInt64 = 86_400","","@Init func initialize(tokenIdentifier: TokenIdentifier) {","    var controller = MyController()","    ","    controller.tokenIdentifier = tokenIdentifier","}","","@Controller public struct MyController {","    @Storage(key: \"tokenIdentifier\") var tokenIdentifier: TokenIdentifier","    @Mapping<Address, BigUint>(key: \"depositedTokens\") var depositedTokensForAddress","    ","    public mutating func deposit() {","        let caller = Message.caller","        let payment = Message.singleFungibleEsdt","        ","        guard payment.tokenIdentifier == self.tokenIdentifier else {","            smartContractError(message: \"Wrong payment provided\")","        }","        ","        self.depositedTokensForAddress[caller] = self.depositedTokensForAddress[caller] + payment.amount","    }","}"],"identifier":"GetInfoSection2Step2.swift","type":"file","fileName":"lib.swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Testing-the-Contract":{"abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Testing-the-Contract","title":"Testing the Contract","kind":"section","type":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract"}}}

{"schemaVersion":{"minor":3,"patch":0,"major":0},"metadata":{"category":"SpaceKit","title":"Interact with Other Contracts","role":"project","categoryPathComponent":"SpaceKit"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/tutorials\/spacekit\/synccalls"]}],"identifier":{"url":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls","interfaceLanguage":"swift"},"sections":[{"estimatedTimeInMinutes":15,"title":"Interact with Other Contracts","content":[{"type":"paragraph","inlineContent":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"In this tutorial, you will learn how to implement synchronous interactions between smart contracts. These interactions are only possible when both the calling and the called contracts reside on the same shard, a concept that we will explore in more detail later.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A synchronous call is executed immediately, and once the called contract finishes execution, the control returns to the caller. If the call fails, the entire transaction is reverted, meaning no changes are recorded on the blockchain."}]}],"chapter":"Interacting with Other Contracts","kind":"hero"},{"kind":"tasks","tasks":[{"contentSection":[{"content":[{"inlineContent":[{"type":"text","text":"A proxy represents the endpoints and parameters of the called contract. It defines the structure of the calls that will be made. However, you will specify the actual contract to call separately in your contract’s logic."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The proxy is an enum annotated with "},{"type":"codeVoice","code":"@Proxy"},{"type":"text","text":", where:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Each case name corresponds to an endpoint of the contract you want to call."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The associated values represent the parameters for that endpoint."}]}]}]}],"kind":"contentAndMedia","mediaPosition":"trailing"}],"anchor":"Declare-the-Callee-Proxy","stepsSection":[{"media":null,"runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"Consider this contract. We will create another contract that will call it."}],"type":"paragraph"}],"code":"SyncCallsSection1Step1.swift","type":"step","caption":[{"type":"paragraph","inlineContent":[{"text":"You don’t always need access to the contract’s Swift code. All you need is the endpoint name and the types of the parameters (in the correct order). You can find this information in the contract’s ABI or reverse-engineer it from a blockchain explorer.","type":"text"}]}]},{"media":null,"code":"SyncCallsSection1Step2.swift","runtimePreview":null,"caption":[],"content":[{"inlineContent":[{"type":"text","text":"Now, create the structure for the contract that will call the previous one."}],"type":"paragraph"}],"type":"step"},{"content":[{"type":"paragraph","inlineContent":[{"text":"Declare the ","type":"text"},{"type":"codeVoice","code":"@Proxy"},{"text":" enum, which will describe the endpoints of the called contract.","type":"text"}]}],"runtimePreview":null,"media":null,"code":"SyncCallsSection1Step3.swift","type":"step","caption":[]},{"runtimePreview":null,"media":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Add a case for the "},{"code":"deposit","type":"codeVoice"},{"type":"text","text":" endpoint."}]}],"type":"step","caption":[{"type":"paragraph","inlineContent":[{"text":"Since ","type":"text"},{"type":"codeVoice","code":"deposit"},{"type":"text","text":" doesn’t require any parameters, no associated value is necessary."}]}],"code":"SyncCallsSection1Step4.swift"},{"runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Add a case for the "},{"type":"codeVoice","code":"withdraw"},{"type":"text","text":" endpoint."}]}],"media":null,"type":"step","code":"SyncCallsSection1Step5.swift","caption":[{"type":"paragraph","inlineContent":[{"text":"Note: The proxy only defines the input parameters, not the return types.","type":"text"}]}]},{"code":"SyncCallsSection1Step6.swift","media":null,"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Note: The proxy doesn’t describe the return type of the endpoint."}]}],"content":[{"inlineContent":[{"type":"text","text":"Add a case for the "},{"code":"getTotalDepositedAmount","type":"codeVoice"},{"text":" endpoint.","type":"text"}],"type":"paragraph"}],"type":"step","runtimePreview":null}],"title":"Declare the Callee Proxy"},{"title":"Perform a Synchronous Call","stepsSection":[{"media":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"Here is the complete code from the previous section."}],"type":"paragraph"}],"runtimePreview":null,"caption":[],"code":"SyncCallsSection1Step6.swift"},{"code":"SyncCallsSection2Step2.swift","type":"step","caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The parameter "},{"type":"codeVoice","code":"receiverAddress"},{"text":" is the called contract’s address.","type":"text"}]}],"media":null,"runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Add an endpoint called ","type":"text"},{"code":"callDeposit","type":"codeVoice"},{"type":"text","text":" that will trigger the "},{"type":"codeVoice","code":"deposit"},{"text":" endpoint.","type":"text"}]}]},{"runtimePreview":null,"type":"step","content":[{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"deposit"},{"text":" endpoint requires an EGLD payment. Retrieve it, and you’ll pass it along during the call setup in a later step.","type":"text"}],"type":"paragraph"}],"media":null,"code":"SyncCallsSection2Step3.swift","caption":[]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Instantiate the ","type":"text"},{"code":"deposit","type":"codeVoice"},{"type":"text","text":" case from the "},{"code":"@Proxy","type":"codeVoice"},{"type":"text","text":" enum."}]}],"caption":[],"code":"SyncCallsSection2Step4.swift","runtimePreview":null,"type":"step","media":null},{"content":[{"inlineContent":[{"type":"text","text":"Use the "},{"code":"callAndIgnoreResult","type":"codeVoice"},{"text":" method, which is auto-generated by ","type":"text"},{"type":"codeVoice","code":"@Proxy"},{"type":"text","text":", to invoke the contract. Set the "},{"type":"codeVoice","code":"receiver"},{"text":" parameter to the on-chain address of the CalleeProxy.","type":"text"}],"type":"paragraph"}],"runtimePreview":null,"code":"SyncCallsSection2Step5.swift","type":"step","caption":[{"type":"paragraph","inlineContent":[{"text":"Note: Since ","type":"text"},{"type":"codeVoice","code":"deposit"},{"type":"text","text":" doesn’t return any value, use "},{"type":"codeVoice","code":"callAndIgnoreResult"},{"text":" instead of ","type":"text"},{"code":"call","type":"codeVoice"},{"type":"text","text":"."}]}],"media":null},{"type":"step","caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Note: If you need to transfer ESDT tokens, use the "},{"type":"codeVoice","code":"esdtTransfers"},{"type":"text","text":" parameter."}]}],"runtimePreview":null,"media":null,"code":"SyncCallsSection2Step6.swift","content":[{"inlineContent":[{"type":"text","text":"Forward the EGLD payment using the optional "},{"code":"egldValue","type":"codeVoice"},{"text":" parameter to complete the call.","type":"text"}],"type":"paragraph"}]},{"code":"SyncCallsSection2Step7.swift","type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Add an endpoint called ","type":"text"},{"code":"callWithdraw","type":"codeVoice"},{"text":" that will invoke the ","type":"text"},{"type":"codeVoice","code":"withdraw"},{"type":"text","text":" endpoint."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This function should accept the receiver’s address as well as an "},{"type":"codeVoice","code":"amount"},{"text":" parameter that will be passed to the ","type":"text"},{"code":"withdraw","type":"codeVoice"},{"type":"text","text":" endpoint."}]}],"media":null,"runtimePreview":null},{"runtimePreview":null,"content":[{"inlineContent":[{"text":"Instantiate the ","type":"text"},{"type":"codeVoice","code":"withdraw"},{"text":" case from the ","type":"text"},{"type":"codeVoice","code":"@Proxy"},{"type":"text","text":" enum and pass the "},{"code":"amount","type":"codeVoice"},{"type":"text","text":" argument."}],"type":"paragraph"}],"media":null,"caption":[],"type":"step","code":"SyncCallsSection2Step8.swift"},{"caption":[],"media":null,"code":"SyncCallsSection2Step9.swift","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use the "},{"code":"call","type":"codeVoice"},{"type":"text","text":" method to execute the contract call, passing the called contract’s address as the "},{"type":"codeVoice","code":"receiver"},{"text":", just like before.","type":"text"}]}],"type":"step"},{"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Important: Because the "},{"code":"@Proxy","type":"codeVoice"},{"type":"text","text":" enum does not define return values, you must explicitly declare the type here."}]}],"runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Store the returned value in a variable named "},{"type":"codeVoice","code":"payment"},{"type":"text","text":"."}]}],"type":"step","media":null,"code":"SyncCallsSection2Step10.swift"},{"caption":[],"content":[{"type":"paragraph","inlineContent":[{"text":"Ensure that the resulting payment is greater than zero.","type":"text"}]}],"code":"SyncCallsSection2Step11.swift","runtimePreview":null,"media":null,"type":"step"}],"anchor":"Perform-a-Synchronous-Call","contentSection":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Once you have set up the proxy, invoking the contract is straightforward.","type":"text"}]}],"mediaPosition":"trailing","kind":"contentAndMedia"}]}]},{"title":"Interacting with Contracts Across Shards","kind":"callToAction","action":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","isActive":true,"overridingTitleInlineContent":[{"text":"Get started","type":"text"}],"type":"reference","overridingTitle":"Get started"},"featuredEyebrow":"Tutorial","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}]}],"hierarchy":{"modules":[{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract"}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types"},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","kind":"task"}]}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Build-a-Coin-Flip-Smart-Contract","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro#Set-Up-the-Project","kind":"task"}]}]},{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Flip-Structure","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Implement-Contract-Storage"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Contract-Init"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Define-the-Storage-for-the-Flip-Contract"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Add-Administrative-Endpoints-to-the-Flip-Contract","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-the-Minimum-Block-Bounty-Delay","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-Maximum-Bet-Limits","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Increase-Contract-Reserves"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Withdraw-Contract-Reserves","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Implement-the-Game-Logic-for-the-Flip-Contract","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-flip-Endpoint"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-makeFlip-Function"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Define-the-bounty-Endpoint","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Set-Up-Testing-in-the-SwiftVM","projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Set-Up-the-Test-Project"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Declare-Constants-for-the-Test-Environment","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Configure-the-Initial-Blockchain-State"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Write-Tests-for-the-Setup-Helpers","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Admin-Endpoints","projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-the-Maximum-Bet-Configuration-Endpoints","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-increaseReserve-Endpoint"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-withdrawReserve-Endpoint","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Game-Logic-for-the-Flip-Contract","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Create-Utility-Functions-for-flip-and-bounty","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Cases-for-the-flip-Endpoint","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Successful-Calls-to-the-flip-Endpoint"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Case-for-the-bounty-Endpoint"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-the-bounty-Endpoint"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","paths":[["doc:\/\/SpaceKit\/tutorials\/SpaceKit","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts"]]},"kind":"project","references":{"SyncCallsSection2Step4.swift":{"type":"file","fileType":"swift","content":["import SpaceKit","","@Proxy enum CalleeProxy {","    case deposit","    case withdraw(amount: BigUint)","    case getTotalDepositedAmount","}","","@Controller public struct MyController {","    public func callDeposit(receiverAddress: Address) {","        let payment = Message.egldValue","        ","        CalleeProxy","            .deposit","    }","}"],"identifier":"SyncCallsSection2Step4.swift","fileName":"lib.swift","syntax":"swift","highlights":[{"line":12},{"line":13},{"line":14}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractIntro#Set-Up-the-Project":{"url":"\/tutorials\/spacekit\/flipcontractintro#Set-Up-the-Project","kind":"section","type":"section","role":"pseudoSymbol","title":"Set Up the Project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro#Set-Up-the-Project","abstract":[{"type":"text","text":"In this tutorial, you’ll write and test a complete smart contract that relies on random number generation to implement a coin flip mechanic. Players wager a chosen amount of any token and face a 50% chance of doubling their bet—or losing it. A small fee is deducted from each wager and sent to the developer’s wallet."}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Withdraw-Contract-Reserves":{"url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Withdraw-Contract-Reserves","role":"pseudoSymbol","kind":"section","title":"Withdraw Contract Reserves","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Withdraw-Contract-Reserves","type":"section","abstract":[{"type":"text","text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets."}]},"SyncCallsSection1Step3.swift":{"syntax":"swift","fileName":"lib.swift","type":"file","highlights":[{"line":3},{"line":4},{"line":5},{"line":6}],"fileType":"swift","content":["import SpaceKit","","@Proxy enum CalleeProxy {","    ","}","","@Controller public struct MyController {","    ","}"],"identifier":"SyncCallsSection1Step3.swift"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce":{"title":"Add Quantity to an Existing Nonce","role":"pseudoSymbol","kind":"section","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Add-Quantity-to-an-Existing-Nonce","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Set-Maximum-Bet-Limits":{"kind":"section","abstract":[{"type":"text","text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets."}],"type":"section","url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Set-Maximum-Bet-Limits","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-Maximum-Bet-Limits","title":"Set Maximum Bet Limits"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Mint-New-Tokens":{"url":"\/tutorials\/spacekit\/operationsonfungibletokens#Mint-New-Tokens","role":"pseudoSymbol","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","type":"section","title":"Mint New Tokens","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Declare-the-Callee-Proxy":{"type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","url":"\/tutorials\/spacekit\/synccalls#Declare-the-Callee-Proxy","title":"Declare the Callee Proxy","kind":"section","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}],"role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-Failure-Case-for-the-bounty-Endpoint":{"url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-Failure-Case-for-the-bounty-Endpoint","role":"pseudoSymbol","kind":"section","title":"Test Failure Case for the bounty Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Case-for-the-bounty-Endpoint","type":"section","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"text":".","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls":{"title":"Interacting with Contracts Across Shards","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"kind":"project","role":"project","estimatedTime":"15min","type":"topic","url":"\/tutorials\/spacekit\/asynccalls"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract":{"url":"\/tutorials\/spacekit\/flipcontractinittests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract","role":"pseudoSymbol","kind":"section","title":"Create Helper Functions to Deploy and Configure the Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract","type":"section","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}]},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Persisting-Data-Across-Executions":{"title":"Persisting Data Across Executions","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","type":"topic","abstract":[],"kind":"article","role":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/persisting-data-across-executions"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Working-with-Storage-for-Single-Value-Persistence":{"title":"Working with @Storage for Single Value Persistence","role":"pseudoSymbol","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"kind":"section","url":"\/tutorials\/spacekit\/storevalues#Working-with-Storage-for-Single-Value-Persistence","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Create-Utility-Functions-for-flip-and-bounty":{"url":"\/tutorials\/spacekit\/flipcontracttestthegame#Create-Utility-Functions-for-flip-and-bounty","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Create-Utility-Functions-for-flip-and-bounty","kind":"section","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"text":".","type":"text"}],"role":"pseudoSymbol","title":"Create Utility Functions for flip and bounty"},"SyncCallsSection1Step1.swift":{"content":["import SpaceKit","","@Controller public struct CalleeController {","    public func deposit() {","        \/\/ Implements the logic to handle a deposit.","        \/\/ This endpoint requires an input EGLD payment.","    }","    ","    public func withdraw(amount: BigUint) -> TokenPayment {","        \/\/ Executes the logic to withdraw the specified amount.","        \/\/ Returns a TokenPayment that represents the amount withdrawn.","    }","    ","    public func getTotalDepositedAmount() -> BigUint {","        \/\/ Retrieves the total deposited amount.","        \/\/ This is a view function that likely accesses a stored value.","    }","}"],"fileType":"swift","syntax":"swift","identifier":"SyncCallsSection1Step1.swift","highlights":[],"type":"file","fileName":"CalleeProxy.swift"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Calling-Contracts-Across-Shards":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","title":"Calling Contracts Across Shards","kind":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/calling-contracts-across-shards","abstract":[],"type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Test-the-withdrawReserve-Endpoint":{"type":"section","kind":"section","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}],"title":"Test the withdrawReserve Endpoint","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/flipcontracttestadmin#Test-the-withdrawReserve-Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-withdrawReserve-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Fungible-Tokens":{"url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-fungible-tokens","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens","kind":"article","abstract":[],"role":"article","title":"Managing Fungible Tokens"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage#Implement-Contract-Storage":{"url":"\/tutorials\/spacekit\/flipcontractwritethestorage#Implement-Contract-Storage","kind":"section","type":"section","role":"pseudoSymbol","title":"Implement Contract Storage","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Implement-Contract-Storage","abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin":{"estimatedTime":"20min","url":"\/tutorials\/spacekit\/flipcontractwriteadmin","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin","type":"topic","kind":"project","title":"Add Administrative Endpoints to the Flip Contract","role":"project","abstract":[{"text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Set-Up-the-Test-Project":{"title":"Set Up the Test Project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Set-Up-the-Test-Project","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}],"url":"\/tutorials\/spacekit\/flipcontractinittests#Set-Up-the-Test-Project","type":"section","kind":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame#Implement-the-makeFlip-Function":{"url":"\/tutorials\/spacekit\/flipcontractwritethegame#Implement-the-makeFlip-Function","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-makeFlip-Function","kind":"section","abstract":[{"type":"text","text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics."}],"role":"pseudoSymbol","title":"Implement the makeFlip Function"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Perform-an-Asynchronous-Call":{"url":"\/tutorials\/spacekit\/asynccalls#Perform-an-Asynchronous-Call","kind":"section","type":"section","role":"pseudoSymbol","title":"Perform an Asynchronous Call","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}]},"SyncCallsSection1Step2.swift":{"syntax":"swift","fileName":"lib.swift","type":"file","highlights":[],"fileType":"swift","content":["import SpaceKit","","@Controller public struct MyController {","    ","}"],"identifier":"SyncCallsSection1Step2.swift"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Creating-Your-Own-Types":{"title":"Creating Your Own Types","role":"pseudoSymbol","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"kind":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Creating-Your-Own-Types","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Creating-and-Understanding-Tokens":{"url":"\/tutorials\/spacekit\/create-and-manage-tokens\/creating-and-understanding-tokens","kind":"article","type":"topic","role":"article","title":"Creating and Understanding Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-the-bounty-Endpoint":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-the-bounty-Endpoint","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"text":".","type":"text"}],"role":"pseudoSymbol","title":"Test the bounty Endpoint","kind":"section","url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-the-bounty-Endpoint","type":"section"},"SyncCallsSection2Step2.swift":{"content":["import SpaceKit","","@Proxy enum CalleeProxy {","    case deposit","    case withdraw(amount: BigUint)","    case getTotalDepositedAmount","}","","@Controller public struct MyController {","    public func callDeposit(receiverAddress: Address) {","        ","    }","}"],"fileType":"swift","syntax":"swift","identifier":"SyncCallsSection2Step2.swift","highlights":[{"line":10},{"line":11},{"line":12}],"type":"file","fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles":{"abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Assign-Mint-and-Burn-Roles","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","kind":"section","type":"section","title":"Assign Mint and Burn Roles"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Test-the-Admin-Endpoints":{"type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Admin-Endpoints","role":"article","abstract":[],"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/test-the-admin-endpoints","kind":"article","title":"Test the Admin Endpoints"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Declare-the-Callee-Proxy":{"url":"\/tutorials\/spacekit\/asynccalls#Declare-the-Callee-Proxy","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"title":"Declare the Callee Proxy","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Set-the-Minimum-Block-Bounty-Delay":{"url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Set-the-Minimum-Block-Bounty-Delay","role":"pseudoSymbol","kind":"section","title":"Set the Minimum Block Bounty Delay","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-the-Minimum-Block-Bounty-Delay","type":"section","abstract":[{"text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Test-the-Game-Logic-for-the-Flip-Contract":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/test-the-game-logic-for-the-flip-contract","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Game-Logic-for-the-Flip-Contract","kind":"article","abstract":[],"role":"article","title":"Test the Game Logic for the Flip Contract"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage#Define-the-Contract-Init":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Contract-Init","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/flipcontractwritethestorage#Define-the-Contract-Init","abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}],"title":"Define the Contract Init","type":"section","kind":"section"},"SyncCallsSection1Step5.swift":{"syntax":"swift","fileName":"lib.swift","type":"file","highlights":[{"line":5}],"fileType":"swift","content":["import SpaceKit","","@Proxy enum CalleeProxy {","    case deposit","    case withdraw(amount: BigUint)","}","","@Controller public struct MyController {","    ","}"],"identifier":"SyncCallsSection1Step5.swift"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests":{"url":"\/tutorials\/spacekit\/flipcontractinittests","type":"topic","kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests","estimatedTime":"20min","abstract":[{"text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential.","type":"text"}],"title":"Set Up Testing in the SwiftVM","role":"project"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Understanding-the-Buffer-Type":{"title":"Understanding the Buffer Type","role":"pseudoSymbol","kind":"section","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Understanding-the-Buffer-Type","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools":{"title":"Install the Necessary Tools","estimatedTime":"10min","url":"\/tutorials\/spacekit\/installingtools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"role":"project","kind":"project","type":"topic"},"SyncCallsSection2Step10.swift":{"content":["import SpaceKit","","@Proxy enum CalleeProxy {","    case deposit","    case withdraw(amount: BigUint)","    case getTotalDepositedAmount","}","","@Controller public struct MyController {","    public func callDeposit(receiverAddress: Address) {","        let payment = Message.egldValue","        ","        CalleeProxy","            .deposit","            .callAndIgnoreResult(","                receiver: receiverAddress,","                egldValue: payment","            )","    }","    ","    public func callWithdraw(","        receiverAddress: Address,","        amount: BigUint","    ) {","        let payment: TokenPayment = CalleeProxy","            .withdraw(amount: amount)","            .call(","                receiver: receiverAddress","            )","    }","}"],"fileType":"swift","syntax":"swift","identifier":"SyncCallsSection2Step10.swift","highlights":[{"line":25}],"type":"file","fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract":{"type":"section","kind":"section","url":"\/tutorials\/spacekit\/installingtools#Initializing-and-Compiling-Your-First-Smart-Contract","abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"title":"Initializing and Compiling Your First Smart Contract","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-BigUint-Type":{"url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-BigUint-Type","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","kind":"section","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"role":"pseudoSymbol","title":"Working with the BigUint Type"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Testing-the-Contract":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Testing-the-Contract","role":"pseudoSymbol","kind":"section","title":"Testing the Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract","type":"section","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Burn-Tokens":{"url":"\/tutorials\/spacekit\/operationsonfungibletokens#Burn-Tokens","kind":"section","type":"section","role":"pseudoSymbol","title":"Burn Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","abstract":[{"text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with.","type":"text"}]},"SyncCallsSection2Step8.swift":{"syntax":"swift","fileName":"lib.swift","type":"file","highlights":[{"line":25},{"line":26}],"fileType":"swift","content":["import SpaceKit","","@Proxy enum CalleeProxy {","    case deposit","    case withdraw(amount: BigUint)","    case getTotalDepositedAmount","}","","@Controller public struct MyController {","    public func callDeposit(receiverAddress: Address) {","        let payment = Message.egldValue","        ","        CalleeProxy","            .deposit","            .callAndIgnoreResult(","                receiver: receiverAddress,","                egldValue: payment","            )","    }","    ","    public func callWithdraw(","        receiverAddress: Address,","        amount: BigUint","    ) {","        CalleeProxy","            .withdraw(amount: amount)","    }","}"],"identifier":"SyncCallsSection2Step8.swift"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-Vector-Type":{"url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-Vector-Type","type":"section","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"title":"Working with the Vector Type","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Enhancing-Contracts-with-Token-Attributes":{"abstract":[],"role":"article","kind":"article","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/enhancing-contracts-with-token-attributes","type":"topic","title":"Enhancing Contracts with Token Attributes","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Writing-the-Contract-Code":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Writing-the-Contract-Code","role":"pseudoSymbol","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","type":"section","title":"Writing the Contract Code","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges":{"title":"Handling Heap Allocation Challenges","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"kind":"section","role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Handling-Heap-Allocation-Challenges"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame#Implement-the-flip-Endpoint":{"kind":"section","abstract":[{"type":"text","text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics."}],"type":"section","url":"\/tutorials\/spacekit\/flipcontractwritethegame#Implement-the-flip-Endpoint","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-flip-Endpoint","title":"Implement the flip Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls":{"title":"Interact with Other Contracts","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls","abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}],"kind":"project","role":"project","estimatedTime":"15min","type":"topic","url":"\/tutorials\/spacekit\/synccalls"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Implement-the-Game-Logic-for-the-Flip-Contract":{"title":"Implement the Game Logic for the Flip Contract","role":"article","kind":"article","abstract":[],"type":"topic","url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/implement-the-game-logic-for-the-flip-contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Implement-the-Game-Logic-for-the-Flip-Contract"},"SyncCallsSection2Step9.swift":{"content":["import SpaceKit","","@Proxy enum CalleeProxy {","    case deposit","    case withdraw(amount: BigUint)","    case getTotalDepositedAmount","}","","@Controller public struct MyController {","    public func callDeposit(receiverAddress: Address) {","        let payment = Message.egldValue","        ","        CalleeProxy","            .deposit","            .callAndIgnoreResult(","                receiver: receiverAddress,","                egldValue: payment","            )","    }","    ","    public func callWithdraw(","        receiverAddress: Address,","        amount: BigUint","    ) {","        CalleeProxy","            .withdraw(amount: amount)","            .call(","                receiver: receiverAddress","            )","    }","}"],"fileType":"swift","syntax":"swift","identifier":"SyncCallsSection2Step9.swift","highlights":[{"line":27},{"line":28},{"line":29}],"type":"file","fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Burn-Tokens":{"title":"Burn Tokens","role":"pseudoSymbol","kind":"section","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Burn-Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens"},"doc://SpaceKit/tutorials/SpaceKit":{"title":"Meet SpaceKit","abstract":[{"type":"text","text":"Discover how SpaceKit simplifies blockchain development using Swift. Dive into the world of Web3 with ease and efficiency."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","url":"\/tutorials\/spacekit","role":"overview","kind":"overview","type":"topic"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Declare-Constants-for-the-Test-Environment":{"title":"Declare Constants for the Test Environment","role":"pseudoSymbol","kind":"section","abstract":[{"text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/flipcontractinittests#Declare-Constants-for-the-Test-Environment","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Declare-Constants-for-the-Test-Environment"},"SyncCallsSection2Step11.swift":{"syntax":"swift","fileName":"lib.swift","type":"file","highlights":[{"line":30},{"line":31},{"line":32},{"line":33}],"fileType":"swift","content":["import SpaceKit","","@Proxy enum CalleeProxy {","    case deposit","    case withdraw(amount: BigUint)","    case getTotalDepositedAmount","}","","@Controller public struct MyController {","    public func callDeposit(receiverAddress: Address) {","        let payment = Message.egldValue","        ","        CalleeProxy","            .deposit","            .callAndIgnoreResult(","                receiver: receiverAddress,","                egldValue: payment","            )","    }","    ","    public func callWithdraw(","        receiverAddress: Address,","        amount: BigUint","    ) {","        let payment: TokenPayment = CalleeProxy","            .withdraw(amount: amount)","            .call(","                receiver: receiverAddress","            )","        ","        guard payment.amount > 0 else {","            smartContractError(message: \"No payment received\")","        }","    }","}"],"identifier":"SyncCallsSection2Step11.swift"},"SyncCallsSection2Step3.swift":{"type":"file","identifier":"SyncCallsSection2Step3.swift","highlights":[{"line":11}],"fileType":"swift","content":["import SpaceKit","","@Proxy enum CalleeProxy {","    case deposit","    case withdraw(amount: BigUint)","    case getTotalDepositedAmount","}","","@Controller public struct MyController {","    public func callDeposit(receiverAddress: Address) {","        let payment = Message.egldValue","    }","}"],"syntax":"swift","fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Write-Tests-for-the-Setup-Helpers":{"type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Write-Tests-for-the-Setup-Helpers","role":"pseudoSymbol","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}],"url":"\/tutorials\/spacekit\/flipcontractinittests#Write-Tests-for-the-Setup-Helpers","kind":"section","title":"Write Tests for the Setup Helpers"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Perform-a-Synchronous-Call":{"kind":"section","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/synccalls#Perform-a-Synchronous-Call","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","title":"Perform a Synchronous Call"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Verify-the-Maximum-Bet-Configuration-Endpoints":{"url":"\/tutorials\/spacekit\/flipcontracttestadmin#Verify-the-Maximum-Bet-Configuration-Endpoints","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-the-Maximum-Bet-Configuration-Endpoints","kind":"section","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}],"role":"pseudoSymbol","title":"Verify the Maximum Bet Configuration Endpoints"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract":{"title":"Issuing a Semi-Fungible Token from Your Contract","type":"section","role":"pseudoSymbol","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"text":" ","type":"text"},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Transaction-Context-Data":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/getinfo#Accessing-Transaction-Context-Data","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"title":"Accessing Transaction Context Data","type":"section","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","url":"\/tutorials\/spacekit\/storevalues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","role":"pseudoSymbol","type":"section","kind":"section","abstract":[{"text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory.","type":"text"}],"title":"Leveraging @Mapping for Dynamic Key-Value Storage"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage#Define-the-Flip-Structure":{"abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}],"url":"\/tutorials\/spacekit\/flipcontractwritethestorage#Define-the-Flip-Structure","role":"pseudoSymbol","title":"Define the Flip Structure","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Flip-Structure"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Exploring-SpaceKit's-Types":{"abstract":[],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","title":"Exploring SpaceKit's Types","type":"topic","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/exploring-spacekit's-types","kind":"article","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Configure-the-Initial-Blockchain-State":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Configure-the-Initial-Blockchain-State","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/flipcontractinittests#Configure-the-Initial-Blockchain-State","type":"section","title":"Configure the Initial Blockchain State","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}],"kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints":{"url":"\/tutorials\/spacekit\/flipcontracttestadmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints","kind":"section","type":"section","role":"pseudoSymbol","title":"Verify That Only the Owner Can Access Admin Endpoints","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}]},"SyncCallsSection2Step5.swift":{"identifier":"SyncCallsSection2Step5.swift","fileType":"swift","fileName":"lib.swift","type":"file","syntax":"swift","content":["import SpaceKit","","@Proxy enum CalleeProxy {","    case deposit","    case withdraw(amount: BigUint)","    case getTotalDepositedAmount","}","","@Controller public struct MyController {","    public func callDeposit(receiverAddress: Address) {","        let payment = Message.egldValue","        ","        CalleeProxy","            .deposit","            .callAndIgnoreResult(","                receiver: receiverAddress","            )","    }","}"],"highlights":[{"line":15},{"line":16},{"line":17}]},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Build-a-Coin-Flip-Smart-Contract":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/build-a-coin-flip-smart-contract","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Build-a-Coin-Flip-Smart-Contract","kind":"article","abstract":[],"role":"article","title":"Build a Coin Flip Smart Contract"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens":{"estimatedTime":"15min","type":"topic","title":"Managing Non-Fungible Tokens","role":"project","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Blockchain-Context-Data":{"abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"url":"\/tutorials\/spacekit\/getinfo#Accessing-Blockchain-Context-Data","role":"pseudoSymbol","title":"Accessing Blockchain Context Data","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract","kind":"project","estimatedTime":"20min","type":"topic","role":"project","title":"Building Your First Smart Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract","abstract":[{"text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Create-a-New-Nonce":{"abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"role":"pseudoSymbol","kind":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Create-a-New-Nonce","type":"section","title":"Create a New Nonce","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint":{"abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"role":"pseudoSymbol","kind":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-changeTokenLockDuration-Endpoint","type":"section","title":"Implementing the changeTokenLockDuration Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Retrieving-Information-from-the-Blockchain":{"type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","role":"article","abstract":[],"url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/retrieving-information-from-the-blockchain","kind":"article","title":"Retrieving Information from the Blockchain"},"SyncCallsSection2Step7.swift":{"content":["import SpaceKit","","@Proxy enum CalleeProxy {","    case deposit","    case withdraw(amount: BigUint)","    case getTotalDepositedAmount","}","","@Controller public struct MyController {","    public func callDeposit(receiverAddress: Address) {","        let payment = Message.egldValue","        ","        CalleeProxy","            .deposit","            .callAndIgnoreResult(","                receiver: receiverAddress,","                egldValue: payment","            )","    }","    ","    public func callWithdraw(","        receiverAddress: Address,","        amount: BigUint","    ) {","        ","    }","}"],"fileType":"swift","syntax":"swift","identifier":"SyncCallsSection2Step7.swift","highlights":[{"line":20},{"line":21},{"line":22},{"line":23},{"line":24},{"line":25},{"line":26}],"type":"file","fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin":{"title":"Test the Admin Endpoints","type":"topic","role":"project","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}],"kind":"project","estimatedTime":"20min","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin","url":"\/tutorials\/spacekit\/flipcontracttestadmin"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-unlockFunds-Endpoint":{"type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-unlockFunds-Endpoint","title":"Implementing the unlockFunds Endpoint","kind":"section","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Test-the-increaseReserve-Endpoint":{"kind":"section","abstract":[{"text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/flipcontracttestadmin#Test-the-increaseReserve-Endpoint","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-increaseReserve-Endpoint","title":"Test the increaseReserve Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame","title":"Test the Game Logic for the Flip Contract","kind":"project","estimatedTime":"20min","url":"\/tutorials\/spacekit\/flipcontracttestthegame","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"type":"text","text":"."}],"type":"topic","role":"project"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Add-Administrative-Endpoints-to-the-Flip-Contract":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/add-administrative-endpoints-to-the-flip-contract","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Add-Administrative-Endpoints-to-the-Flip-Contract","kind":"article","abstract":[],"role":"article","title":"Add Administrative Endpoints to the Flip Contract"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-Failure-Cases-for-the-flip-Endpoint":{"url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-Failure-Cases-for-the-flip-Endpoint","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Cases-for-the-flip-Endpoint","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"code":"GameController","type":"codeVoice"},{"text":".","type":"text"}],"kind":"section","title":"Test Failure Cases for the flip Endpoint","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract":{"title":"Issuing a Meta ESDT from Your Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"kind":"section","role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Meta-ESDT-from-Your-Contract"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract":{"url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Fungible-Token-from-Your-Contract","role":"pseudoSymbol","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","type":"section","title":"Issuing a Fungible Token from Your Contract","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues":{"abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"role":"project","estimatedTime":"15min","kind":"project","url":"\/tutorials\/spacekit\/storevalues","type":"topic","title":"Persist Values Between Executions","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens":{"type":"topic","estimatedTime":"15min","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","role":"project","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"url":"\/tutorials\/spacekit\/operationsonfungibletokens","kind":"project","title":"Managing Fungible Tokens"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage":{"title":"Define the Storage for the Flip Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage","abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}],"kind":"project","role":"project","estimatedTime":"20min","type":"topic","url":"\/tutorials\/spacekit\/flipcontractwritethestorage"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Installing-the-Tools":{"abstract":[],"role":"article","kind":"article","url":"\/tutorials\/spacekit\/getting-started\/installing-the-tools","type":"topic","title":"Installing the Tools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Non-Fungible-Tokens":{"url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-non-fungible-tokens","kind":"article","type":"topic","role":"article","title":"Managing Non-Fungible Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame#Define-the-bounty-Endpoint":{"abstract":[{"text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics.","type":"text"}],"kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Define-the-bounty-Endpoint","type":"section","title":"Define the bounty Endpoint","url":"\/tutorials\/spacekit\/flipcontractwritethegame#Define-the-bounty-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Assign-Create-AddQuantity-and-Burn-Roles","kind":"section","type":"section","role":"pseudoSymbol","title":"Assign Create, AddQuantity, and Burn Roles","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Initializing-the-Project":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Initializing-the-Project","role":"pseudoSymbol","kind":"section","title":"Initializing the Project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","type":"section","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}]},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Setting-Up-the-SpaceKit-CLI":{"url":"\/tutorials\/spacekit\/installingtools#Setting-Up-the-SpaceKit-CLI","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI","kind":"section","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"role":"pseudoSymbol","title":"Setting Up the SpaceKit CLI"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","url":"\/tutorials\/spacekit\/tokenattributes","role":"project","type":"topic","kind":"project","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"estimatedTime":"15min","title":"Enhance Your Contracts with Token Attributes"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Increase-Contract-Reserves":{"url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Increase-Contract-Reserves","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Increase-Contract-Reserves","kind":"section","abstract":[{"type":"text","text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets."}],"role":"pseudoSymbol","title":"Increase Contract Reserves"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens":{"url":"\/tutorials\/spacekit\/understandtokens","estimatedTime":"15min","role":"project","kind":"project","title":"Understand the ESDT Standard","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens","type":"topic","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}]},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Interacting-with-Other-Contracts":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","title":"Interacting with Other Contracts","kind":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/interacting-with-other-contracts","abstract":[],"type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-lockFunds-Endpoint":{"url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-lockFunds-Endpoint","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint","kind":"section","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"role":"pseudoSymbol","title":"Implementing the lockFunds Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","role":"project","url":"\/tutorials\/spacekit\/getinfo","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"title":"Retrieving Information from the Blockchain","type":"topic","estimatedTime":"10min","kind":"project"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Installing-SpaceKits-Dependencies":{"url":"\/tutorials\/spacekit\/installingtools#Installing-SpaceKits-Dependencies","role":"pseudoSymbol","kind":"section","title":"Installing SpaceKit's Dependencies","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","type":"section","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes":{"type":"topic","url":"\/tutorials\/spacekit\/familiarizewithtypes","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes","estimatedTime":"20min","role":"project","kind":"project","title":"Exploring SpaceKit's Types","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract":{"title":"Issuing a Non-Fungible Token from Your Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","type":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"kind":"section","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Non-Fungible-Token-from-Your-Contract"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Building-Your-First-Smart-Contract":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","title":"Building Your First Smart Contract","kind":"article","url":"\/tutorials\/spacekit\/getting-started\/building-your-first-smart-contract","abstract":[],"type":"topic","role":"article"},"SyncCallsSection1Step4.swift":{"content":["import SpaceKit","","@Proxy enum CalleeProxy {","    case deposit","}","","@Controller public struct MyController {","    ","}"],"fileType":"swift","syntax":"swift","highlights":[{"line":4}],"identifier":"SyncCallsSection1Step4.swift","type":"file","fileName":"lib.swift"},"SyncCallsSection1Step6.swift":{"content":["import SpaceKit","","@Proxy enum CalleeProxy {","    case deposit","    case withdraw(amount: BigUint)","    case getTotalDepositedAmount","}","","@Controller public struct MyController {","    ","}"],"fileType":"swift","syntax":"swift","identifier":"SyncCallsSection1Step6.swift","highlights":[],"type":"file","fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Set-Up-Testing-in-the-SwiftVM":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/set-up-testing-in-the-swiftvm","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Set-Up-Testing-in-the-SwiftVM","kind":"article","abstract":[],"role":"article","title":"Set Up Testing in the SwiftVM"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractIntro":{"type":"topic","url":"\/tutorials\/spacekit\/flipcontractintro","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro","estimatedTime":"20min","role":"project","kind":"project","title":"Build a Coin Flip Smart Contract","abstract":[{"text":"In this tutorial, you’ll write and test a complete smart contract that relies on random number generation to implement a coin flip mechanic. Players wager a chosen amount of any token and face a 50% chance of doubling their bet—or losing it. A small fee is deducted from each wager and sent to the developer’s wallet.","type":"text"}]},"SyncCallsSection2Step6.swift":{"content":["import SpaceKit","","@Proxy enum CalleeProxy {","    case deposit","    case withdraw(amount: BigUint)","    case getTotalDepositedAmount","}","","@Controller public struct MyController {","    public func callDeposit(receiverAddress: Address) {","        let payment = Message.egldValue","        ","        CalleeProxy","            .deposit","            .callAndIgnoreResult(","                receiver: receiverAddress,","                egldValue: payment","            )","    }","}"],"fileType":"swift","syntax":"swift","highlights":[{"line":16},{"line":17}],"identifier":"SyncCallsSection2Step6.swift","type":"file","fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame","estimatedTime":"20min","abstract":[{"type":"text","text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics."}],"role":"project","title":"Implement the Game Logic for the Flip Contract","kind":"project","url":"\/tutorials\/spacekit\/flipcontractwritethegame","type":"topic"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Define-the-Storage-for-the-Flip-Contract":{"title":"Define the Storage for the Flip Contract","role":"article","kind":"article","abstract":[],"type":"topic","url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/define-the-storage-for-the-flip-contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Define-the-Storage-for-the-Flip-Contract"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-Successful-Calls-to-the-flip-Endpoint":{"title":"Test Successful Calls to the flip Endpoint","role":"pseudoSymbol","kind":"section","abstract":[{"text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the ","type":"text"},{"type":"codeVoice","code":"GameController"},{"type":"text","text":"."}],"type":"section","url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-Successful-Calls-to-the-flip-Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Successful-Calls-to-the-flip-Endpoint"}}}
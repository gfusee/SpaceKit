{"kind":"project","metadata":{"role":"project","categoryPathComponent":"SpaceKit","title":"Define the Storage for the Flip Contract","category":"SpaceKit"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/tutorials\/spacekit\/flipcontractwritethestorage"]}],"schemaVersion":{"minor":3,"patch":0,"major":0},"hierarchy":{"paths":[["doc:\/\/SpaceKit\/tutorials\/SpaceKit","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Define-the-Storage-for-the-Flip-Contract"]],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","modules":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract"}]}]},{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes"}]},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","kind":"task"}]}]},{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens"},{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens"},{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens"},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Build-a-Coin-Flip-Smart-Contract","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro#Set-Up-the-Project","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro"}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Flip-Structure","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Implement-Contract-Storage"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Contract-Init","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Define-the-Storage-for-the-Flip-Contract"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Add-Administrative-Endpoints-to-the-Flip-Contract","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-the-Minimum-Block-Bounty-Delay"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-Maximum-Bet-Limits"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Increase-Contract-Reserves"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Withdraw-Contract-Reserves","kind":"task"}]}]},{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-flip-Endpoint","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-makeFlip-Function"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Define-the-bounty-Endpoint"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Implement-the-Game-Logic-for-the-Flip-Contract"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Set-Up-Testing-in-the-SwiftVM","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Set-Up-the-Test-Project"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Declare-Constants-for-the-Test-Environment"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Configure-the-Initial-Blockchain-State"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Write-Tests-for-the-Setup-Helpers"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Admin-Endpoints","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-the-Maximum-Bet-Configuration-Endpoints"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-increaseReserve-Endpoint"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-withdrawReserve-Endpoint","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Game-Logic-for-the-Flip-Contract","projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Create-Utility-Functions-for-flip-and-bounty"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Cases-for-the-flip-Endpoint"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Successful-Calls-to-the-flip-Endpoint","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Case-for-the-bounty-Endpoint"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-the-bounty-Endpoint"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame"}]}]},"sections":[{"estimatedTimeInMinutes":20,"content":[{"type":"paragraph","inlineContent":[{"text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"Flip"},{"text":": A structure that stores individual flip information such as the player’s address and the bet amount.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"StorageController"},{"type":"text","text":": A controller that manages the contract’s stored values."}]}]},{"content":[{"inlineContent":[{"code":"init","type":"codeVoice"},{"type":"text","text":": The initializer function called during contract deployment, used to configure initial storage."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"AdminController"},{"text":": A controller restricted to the contract owner, used to perform administrative operations like setting bet limits or managing funds.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"GameController","type":"codeVoice"},{"text":": A controller that defines the game logic and player interactions, including flipping and bountying.","type":"text"}]}]}],"type":"unorderedList"},{"inlineContent":[{"text":"In this tutorial, you’ll define the ","type":"text"},{"type":"codeVoice","code":"Flip"},{"type":"text","text":" structure and implement the storage logic."}],"type":"paragraph"}],"title":"Define the Storage for the Flip Contract","kind":"hero","chapter":"Define the Storage for the Flip Contract"},{"tasks":[{"contentSection":[{"content":[{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Flip"},{"type":"text","text":" structure contains all relevant data for a single coin flip. This model will be reused throughout the contract, so start by defining it."}],"type":"paragraph"}],"mediaPosition":"trailing","kind":"contentAndMedia"}],"title":"Define the Flip Structure","anchor":"Define-the-Flip-Structure","stepsSection":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Create a new file named "},{"type":"codeVoice","code":"Flip.swift"},{"type":"text","text":" inside "},{"type":"codeVoice","code":"Contracts\/Flip\/Source"},{"text":".","type":"text"}]}],"type":"step","code":"FlipContractWriteTheStorageSection1Step1.swift","runtimePreview":null,"caption":[],"media":null},{"content":[{"inlineContent":[{"type":"text","text":"Import the SpaceKit framework."}],"type":"paragraph"}],"caption":[],"media":null,"code":"FlipContractWriteTheStorageSection1Step2.swift","runtimePreview":null,"type":"step"},{"caption":[],"code":"FlipContractWriteTheStorageSection1Step3.swift","type":"step","media":null,"runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Declare a structure named ","type":"text"},{"type":"codeVoice","code":"Flip"},{"text":", and annotate it with ","type":"text"},{"type":"codeVoice","code":"@Codable"},{"text":" to enable encoding and decoding.","type":"text"}]}]},{"media":null,"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This identifier is used to track individual flips."}]}],"code":"FlipContractWriteTheStorageSection1Step4.swift","runtimePreview":null,"type":"step","content":[{"inlineContent":[{"text":"Add a ","type":"text"},{"type":"codeVoice","code":"UInt64"},{"type":"text","text":" property named "},{"type":"codeVoice","code":"id"},{"text":".","type":"text"}],"type":"paragraph"}]},{"media":null,"runtimePreview":null,"code":"FlipContractWriteTheStorageSection1Step5.swift","type":"step","caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Add a property named "},{"type":"codeVoice","code":"playerAddress"},{"type":"text","text":" of type "},{"code":"Address","type":"codeVoice"},{"type":"text","text":"."}]}]},{"runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Add a property named ","type":"text"},{"type":"codeVoice","code":"tokenIdentifier"},{"text":" of type ","type":"text"},{"code":"TokenIdentifier","type":"codeVoice"},{"type":"text","text":"."}]}],"caption":[{"inlineContent":[{"type":"text","text":"This identifies the token the player used for the bet."}],"type":"paragraph"}],"code":"FlipContractWriteTheStorageSection1Step6.swift","media":null,"type":"step"},{"content":[{"type":"paragraph","inlineContent":[{"text":"Add a ","type":"text"},{"code":"UInt64","type":"codeVoice"},{"text":" property named ","type":"text"},{"type":"codeVoice","code":"tokenNonce"},{"type":"text","text":"."}]}],"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This distinguishes between tokens sharing the same identifier."}]}],"code":"FlipContractWriteTheStorageSection1Step7.swift","runtimePreview":null,"media":null,"type":"step"},{"type":"step","code":"FlipContractWriteTheStorageSection1Step8.swift","caption":[{"inlineContent":[{"type":"text","text":"This stores the amount bet by the player."}],"type":"paragraph"}],"media":null,"content":[{"inlineContent":[{"text":"Add a ","type":"text"},{"code":"BigUint","type":"codeVoice"},{"text":" property named ","type":"text"},{"type":"codeVoice","code":"amount"},{"type":"text","text":"."}],"type":"paragraph"}],"runtimePreview":null},{"caption":[{"inlineContent":[{"type":"text","text":"This defines the reward for the account that bounties the flip."}],"type":"paragraph"}],"type":"step","media":null,"content":[{"inlineContent":[{"type":"text","text":"Add a "},{"type":"codeVoice","code":"BigUint"},{"type":"text","text":" property named "},{"type":"codeVoice","code":"bounty"},{"type":"text","text":"."}],"type":"paragraph"}],"code":"FlipContractWriteTheStorageSection1Step9.swift","runtimePreview":null},{"type":"step","media":null,"caption":[{"inlineContent":[{"type":"text","text":"This is the block number at which the flip was initiated."}],"type":"paragraph"}],"code":"FlipContractWriteTheStorageSection1Step10.swift","content":[{"inlineContent":[{"type":"text","text":"Add a "},{"type":"codeVoice","code":"UInt64"},{"type":"text","text":" property named "},{"type":"codeVoice","code":"blockNonce"},{"type":"text","text":"."}],"type":"paragraph"}],"runtimePreview":null},{"type":"step","content":[{"inlineContent":[{"type":"text","text":"Add a "},{"type":"codeVoice","code":"UInt64"},{"text":" property named ","type":"text"},{"type":"codeVoice","code":"minimumBlockBounty"},{"text":".","type":"text"}],"type":"paragraph"}],"media":null,"code":"FlipContractWriteTheStorageSection1Step11.swift","runtimePreview":null,"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This is the minimum number of blocks to wait before the flip can be bountied."}]}]}]},{"contentSection":[{"content":[{"inlineContent":[{"type":"text","text":"Smart contracts must persist data between calls. In this section, you’ll define all necessary storage for the Flip contract."}],"type":"paragraph"}],"mediaPosition":"trailing","kind":"contentAndMedia"}],"stepsSection":[{"media":null,"code":"FlipContractWriteTheStorageSection2Step1.swift","content":[{"inlineContent":[{"type":"text","text":"Create a new file named "},{"type":"codeVoice","code":"StorageController.swift"},{"type":"text","text":" inside "},{"code":"Contracts\/Flip\/Source","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"}],"type":"step","caption":[],"runtimePreview":null},{"runtimePreview":null,"content":[{"inlineContent":[{"text":"Import the SpaceKit framework.","type":"text"}],"type":"paragraph"}],"media":null,"type":"step","caption":[],"code":"FlipContractWriteTheStorageSection2Step2.swift"},{"type":"step","code":"FlipContractWriteTheStorageSection2Step3.swift","media":null,"caption":[],"runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Declare a controller named "},{"code":"StorageController","type":"codeVoice"},{"text":".","type":"text"}]}]},{"media":null,"caption":[],"content":[{"inlineContent":[{"type":"text","text":"Store the percentage of the bet taken as owner fees."}],"type":"paragraph"}],"type":"step","code":"FlipContractWriteTheStorageSection2Step4.swift","runtimePreview":null},{"content":[{"inlineContent":[{"text":"Store the percentage awarded to the bounty performer.","type":"text"}],"type":"paragraph"}],"caption":[],"runtimePreview":null,"type":"step","code":"FlipContractWriteTheStorageSection2Step5.swift","media":null},{"caption":[],"runtimePreview":null,"content":[{"inlineContent":[{"text":"Store the minimum number of blocks required before bountying.","type":"text"}],"type":"paragraph"}],"type":"step","media":null,"code":"FlipContractWriteTheStorageSection2Step6.swift"},{"content":[{"type":"paragraph","inlineContent":[{"text":"Track the ID of the most recent flip.","type":"text"}]}],"runtimePreview":null,"type":"step","caption":[],"media":null,"code":"FlipContractWriteTheStorageSection2Step7.swift"},{"content":[{"type":"paragraph","inlineContent":[{"text":"Track the ID of the last bountied flip.","type":"text"}]}],"type":"step","caption":[],"code":"FlipContractWriteTheStorageSection2Step8.swift","runtimePreview":null,"media":null},{"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Declare a mapping from flip ID to "},{"type":"codeVoice","code":"Flip"},{"type":"text","text":" structures."}]}],"media":null,"code":"FlipContractWriteTheStorageSection2Step9.swift","runtimePreview":null,"caption":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Tip"}],"type":"strong"},{"type":"text","text":": Avoid using arrays for large-scale storage due to performance concerns."}],"type":"paragraph"}]},{"code":"FlipContractWriteTheStorageSection2Step10.swift","runtimePreview":null,"caption":[{"inlineContent":[{"inlineContent":[{"text":"Note","type":"text"}],"type":"strong"},{"type":"text","text":": This is functionally equivalent to "},{"type":"codeVoice","code":"@Mapping"},{"type":"text","text":" with multiple keys."}],"type":"paragraph"}],"media":null,"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define a mapper for absolute maximum bets per token and nonce."}]}]},{"type":"step","runtimePreview":null,"media":null,"caption":[],"code":"FlipContractWriteTheStorageSection2Step11.swift","content":[{"inlineContent":[{"type":"text","text":"Similarly, store the maximum allowed bet as a percentage of the contract’s reserves."}],"type":"paragraph"}]},{"caption":[{"inlineContent":[{"inlineContent":[{"text":"Important","type":"text"}],"type":"strong"},{"text":": These balances differ from the contract’s on-chain balance as they include locked bounties.","type":"text"}],"type":"paragraph"}],"media":null,"code":"FlipContractWriteTheStorageSection2Step12.swift","runtimePreview":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"Maintain the token reserves per identifier and nonce."}],"type":"paragraph"}]},{"media":null,"code":"FlipContractWriteTheStorageSection2Step13.swift","type":"step","caption":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Note","type":"text"}],"type":"strong"},{"text":": Use manual view declarations for stored values that don’t expose accessors by default.","type":"text"}]}],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"(Optional) Add a view function to expose the stored owner fee percentage."}]}],"runtimePreview":null},{"code":"FlipContractWriteTheStorageSection2Step14.swift","content":[{"inlineContent":[{"type":"text","text":"(Optional) Add a view for the bounty fee percentage."}],"type":"paragraph"}],"runtimePreview":null,"caption":[],"type":"step","media":null},{"media":null,"content":[{"type":"paragraph","inlineContent":[{"text":"(Optional) Add a view for the minimum block delay before bountying.","type":"text"}]}],"runtimePreview":null,"type":"step","code":"FlipContractWriteTheStorageSection2Step15.swift","caption":[]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"(Optional) Add a view for retrieving the latest registered flip ID."}]}],"code":"FlipContractWriteTheStorageSection2Step16.swift","caption":[],"type":"step","media":null,"runtimePreview":null},{"code":"FlipContractWriteTheStorageSection2Step17.swift","type":"step","runtimePreview":null,"media":null,"caption":[],"content":[{"inlineContent":[{"text":"(Optional) Add a view for retrieving the latest bountied flip ID.","type":"text"}],"type":"paragraph"}]},{"type":"step","media":null,"caption":[],"code":"FlipContractWriteTheStorageSection2Step18.swift","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"(Optional) Add a view for retrieving a flip by its ID."}]}]}],"anchor":"Implement-Contract-Storage","title":"Implement Contract Storage"},{"anchor":"Define-the-Contract-Init","contentSection":[{"mediaPosition":"trailing","kind":"contentAndMedia","content":[{"inlineContent":[{"text":"Our storage is written, however we want to initialise some values at deploy time. This is done by the initilizer function: a public function annotated @Init on the global scope.","type":"text"}],"type":"paragraph"}]}],"stepsSection":[{"content":[{"inlineContent":[{"text":"Create a new file named ","type":"text"},{"type":"codeVoice","code":"init.swift"},{"text":" in the ","type":"text"},{"code":"Contracts\/Flip\/Source","type":"codeVoice"},{"type":"text","text":" directory."}],"type":"paragraph"}],"type":"step","media":null,"runtimePreview":null,"caption":[],"code":"FlipContractWriteTheStorageSection3Step1.swift"},{"caption":[],"code":"FlipContractWriteTheStorageSection3Step2.swift","runtimePreview":null,"content":[{"inlineContent":[{"text":"Import the ","type":"text"},{"type":"codeVoice","code":"SpaceKit"},{"type":"text","text":" framework."}],"type":"paragraph"}],"type":"step","media":null},{"runtimePreview":null,"caption":[{"type":"paragraph","inlineContent":[{"text":"This function accepts three arguments, which represent the initial values for the contract’s storage.","type":"text"}]}],"content":[{"type":"paragraph","inlineContent":[{"text":"Define a public function annotated with ","type":"text"},{"type":"codeVoice","code":"@Init"},{"type":"text","text":"."}]}],"media":null,"type":"step","code":"FlipContractWriteTheStorageSection3Step3.swift"},{"media":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Create an instance of the "},{"type":"codeVoice","code":"StorageController"},{"text":".","type":"text"}]}],"type":"step","caption":[],"code":"FlipContractWriteTheStorageSection3Step4.swift","runtimePreview":null},{"media":null,"caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Set the initial values for the owner fee and bounty fee percentages."}]}],"runtimePreview":null,"code":"FlipContractWriteTheStorageSection3Step5.swift","type":"step"},{"caption":[],"media":null,"content":[{"inlineContent":[{"text":"Add a safety check to ensure the minimum number of blocks required before bountying is greater than zero.","type":"text"}],"type":"paragraph"}],"type":"step","code":"FlipContractWriteTheStorageSection3Step6.swift","runtimePreview":null},{"content":[{"inlineContent":[{"text":"Store the validated block delay as the initial value for the bounty threshold.","type":"text"}],"type":"paragraph"}],"caption":[],"media":null,"runtimePreview":null,"type":"step","code":"FlipContractWriteTheStorageSection3Step7.swift"}],"title":"Define the Contract Init"}],"kind":"tasks"},{"title":"Add Administrative Endpoints to the Flip Contract","kind":"callToAction","abstract":[{"text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets.","type":"text"}],"action":{"isActive":true,"overridingTitleInlineContent":[{"text":"Get started","type":"text"}],"type":"reference","overridingTitle":"Get started","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin"},"featuredEyebrow":"Tutorial"}],"identifier":{"url":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage","interfaceLanguage":"swift"},"references":{"FlipContractWriteTheStorageSection2Step3.swift":{"syntax":"swift","content":["import SpaceKit","","@Controller public struct StorageController {","    ","}"],"highlights":[{"line":2},{"line":3},{"line":4},{"line":5}],"type":"file","identifier":"FlipContractWriteTheStorageSection2Step3.swift","fileName":"StorageController.swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests":{"url":"\/tutorials\/spacekit\/flipcontractinittests","type":"topic","kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests","estimatedTime":"20min","abstract":[{"text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential.","type":"text"}],"title":"Set Up Testing in the SwiftVM","role":"project"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract":{"type":"section","kind":"section","url":"\/tutorials\/spacekit\/installingtools#Initializing-and-Compiling-Your-First-Smart-Contract","abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"title":"Initializing and Compiling Your First Smart Contract","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-BigUint-Type":{"url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-BigUint-Type","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","kind":"section","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"role":"pseudoSymbol","title":"Working with the BigUint Type"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin":{"title":"Test the Admin Endpoints","type":"topic","role":"project","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}],"kind":"project","estimatedTime":"20min","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin","url":"\/tutorials\/spacekit\/flipcontracttestadmin"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Assign-Create-AddQuantity-and-Burn-Roles","kind":"section","type":"section","role":"pseudoSymbol","title":"Assign Create, AddQuantity, and Burn Roles","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools":{"title":"Install the Necessary Tools","estimatedTime":"10min","url":"\/tutorials\/spacekit\/installingtools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"role":"project","kind":"project","type":"topic"},"FlipContractWriteTheStorageSection1Step6.swift":{"syntax":"swift","identifier":"FlipContractWriteTheStorageSection1Step6.swift","highlights":[{"line":6}],"fileName":"Flip.swift","fileType":"swift","type":"file","content":["import SpaceKit","","@Codable public struct Flip {","    let id: UInt64","    let playerAddress: Address","    let tokenIdentifier: TokenIdentifier","}"]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage#Define-the-Contract-Init":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Contract-Init","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/flipcontractwritethestorage#Define-the-Contract-Init","abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}],"title":"Define the Contract Init","type":"section","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Creating-and-Understanding-Tokens":{"url":"\/tutorials\/spacekit\/create-and-manage-tokens\/creating-and-understanding-tokens","kind":"article","type":"topic","role":"article","title":"Creating and Understanding Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Build-a-Coin-Flip-Smart-Contract":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/build-a-coin-flip-smart-contract","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Build-a-Coin-Flip-Smart-Contract","kind":"article","abstract":[],"role":"article","title":"Build a Coin Flip Smart Contract"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Test-the-Game-Logic-for-the-Flip-Contract":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/test-the-game-logic-for-the-flip-contract","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Game-Logic-for-the-Flip-Contract","kind":"article","abstract":[],"role":"article","title":"Test the Game Logic for the Flip Contract"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Installing-SpaceKits-Dependencies":{"url":"\/tutorials\/spacekit\/installingtools#Installing-SpaceKits-Dependencies","role":"pseudoSymbol","kind":"section","title":"Installing SpaceKit's Dependencies","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","type":"section","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Burn-Tokens":{"url":"\/tutorials\/spacekit\/operationsonfungibletokens#Burn-Tokens","kind":"section","type":"section","role":"pseudoSymbol","title":"Burn Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","abstract":[{"text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract":{"title":"Issuing a Meta ESDT from Your Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"kind":"section","role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Meta-ESDT-from-Your-Contract"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues":{"abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"role":"project","estimatedTime":"15min","kind":"project","url":"\/tutorials\/spacekit\/storevalues","type":"topic","title":"Persist Values Between Executions","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Persisting-Data-Across-Executions":{"title":"Persisting Data Across Executions","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","type":"topic","abstract":[],"kind":"article","role":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/persisting-data-across-executions"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Set-Up-Testing-in-the-SwiftVM":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/set-up-testing-in-the-swiftvm","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Set-Up-Testing-in-the-SwiftVM","kind":"article","abstract":[],"role":"article","title":"Set Up Testing in the SwiftVM"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractIntro#Set-Up-the-Project":{"url":"\/tutorials\/spacekit\/flipcontractintro#Set-Up-the-Project","kind":"section","type":"section","role":"pseudoSymbol","title":"Set Up the Project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro#Set-Up-the-Project","abstract":[{"type":"text","text":"In this tutorial, you’ll write and test a complete smart contract that relies on random number generation to implement a coin flip mechanic. Players wager a chosen amount of any token and face a 50% chance of doubling their bet—or losing it. A small fee is deducted from each wager and sent to the developer’s wallet."}]},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Perform-a-Synchronous-Call":{"kind":"section","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/synccalls#Perform-a-Synchronous-Call","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","title":"Perform a Synchronous Call"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Test-the-increaseReserve-Endpoint":{"kind":"section","abstract":[{"text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/flipcontracttestadmin#Test-the-increaseReserve-Endpoint","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-increaseReserve-Endpoint","title":"Test the increaseReserve Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractIntro":{"type":"topic","url":"\/tutorials\/spacekit\/flipcontractintro","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro","estimatedTime":"20min","role":"project","kind":"project","title":"Build a Coin Flip Smart Contract","abstract":[{"text":"In this tutorial, you’ll write and test a complete smart contract that relies on random number generation to implement a coin flip mechanic. Players wager a chosen amount of any token and face a 50% chance of doubling their bet—or losing it. A small fee is deducted from each wager and sent to the developer’s wallet.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls":{"title":"Interact with Other Contracts","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls","abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}],"kind":"project","role":"project","estimatedTime":"15min","type":"topic","url":"\/tutorials\/spacekit\/synccalls"},"FlipContractWriteTheStorageSection3Step2.swift":{"syntax":"swift","content":["import SpaceKit"],"highlights":[{"line":1}],"type":"file","identifier":"FlipContractWriteTheStorageSection3Step2.swift","fileName":"init.swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame","title":"Test the Game Logic for the Flip Contract","kind":"project","estimatedTime":"20min","url":"\/tutorials\/spacekit\/flipcontracttestthegame","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"type":"text","text":"."}],"type":"topic","role":"project"},"FlipContractWriteTheStorageSection3Step3.swift":{"syntax":"swift","identifier":"FlipContractWriteTheStorageSection3Step3.swift","highlights":[{"line":2},{"line":3},{"line":4},{"line":5},{"line":6},{"line":7},{"line":8}],"fileName":"init.swift","fileType":"swift","type":"file","content":["import SpaceKit","","@Init public func initialize(","    ownerPercentFees: UInt64,","    bountyPercentFees: UInt64,","    minimumBlockBounty: UInt64",") {","}"]},"FlipContractWriteTheStorageSection3Step6.swift":{"syntax":"swift","content":["import SpaceKit","","@Init public func initialize(","    ownerPercentFees: UInt64,","    bountyPercentFees: UInt64,","    minimumBlockBounty: UInt64",") {","    var storageController = StorageController()","    ","    storageController.ownerPercentFees = ownerPercentFees","    storageController.bountyPercentFees = bountyPercentFees","    ","    require(","        minimumBlockBounty > 0,","        \"Minimum block bounty should be greater than zero.\"","    )","}"],"highlights":[{"line":12},{"line":13},{"line":14},{"line":15},{"line":16}],"type":"file","identifier":"FlipContractWriteTheStorageSection3Step6.swift","fileName":"init.swift","fileType":"swift"},"FlipContractWriteTheStorageSection2Step18.swift":{"syntax":"swift","identifier":"FlipContractWriteTheStorageSection2Step18.swift","highlights":[{"line":61},{"line":62},{"line":63},{"line":64}],"fileName":"StorageController.swift","fileType":"swift","type":"file","content":["import SpaceKit","","@Controller public struct StorageController {","    @Storage(key: \"ownerPercentFees\") var ownerPercentFees: UInt64","    @Storage(key: \"bountyPercentFees\") var bountyPercentFees: UInt64","    @Storage(key: \"minimumBlockBounty\") var minimumBlockBounty: UInt64","    @Storage(key: \"lastFlipId\") var lastFlipId: UInt64","    @Storage(key: \"lastBountyFlipId\") var lastBountyFlipId: UInt64","    ","    @Mapping<UInt64, Flip>(key: \"flipForId\") var flipForId","    ","    public func getMaximumBet(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<BigUint> {","        SingleValueMapper(baseKey: \"maximumBet\") {","            tokenIdentifier","            tokenNonce","        }","    }","    ","    public func getMaximumBetPercent(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<UInt64> {","        SingleValueMapper(baseKey: \"maximumBetPercent\") {","            tokenIdentifier","            tokenNonce","        }","    }","    ","    public func getTokenReserve(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<BigUint> {","        SingleValueMapper(baseKey: \"tokenReserve\") {","            tokenIdentifier","            tokenNonce","        }","    }","    ","    public func getOwnerPercentFees() -> UInt64 {","        self.ownerPercentFees","    }","    ","    public func getBountyPercentFees() -> UInt64 {","        self.bountyPercentFees","    }","    ","    public func getMinimumBlockBounty() -> UInt64 {","        self.minimumBlockBounty","    }","    ","    public func getLastFlipId() -> UInt64 {","        self.lastFlipId","    }","    ","    public func getLastBountyFlipId() -> UInt64 {","        self.lastBountyFlipId","    }","    ","    public func getFlipForId(id: UInt64) -> Flip {","        self.flipForId[id]","    }","}"]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-Failure-Cases-for-the-flip-Endpoint":{"url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-Failure-Cases-for-the-flip-Endpoint","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Cases-for-the-flip-Endpoint","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"code":"GameController","type":"codeVoice"},{"text":".","type":"text"}],"kind":"section","title":"Test Failure Cases for the flip Endpoint","role":"pseudoSymbol"},"FlipContractWriteTheStorageSection2Step14.swift":{"syntax":"swift","content":["import SpaceKit","","@Controller public struct StorageController {","    @Storage(key: \"ownerPercentFees\") var ownerPercentFees: UInt64","    @Storage(key: \"bountyPercentFees\") var bountyPercentFees: UInt64","    @Storage(key: \"minimumBlockBounty\") var minimumBlockBounty: UInt64","    @Storage(key: \"lastFlipId\") var lastFlipId: UInt64","    @Storage(key: \"lastBountyFlipId\") var lastBountyFlipId: UInt64","    ","    @Mapping<UInt64, Flip>(key: \"flipForId\") var flipForId","    ","    public func getMaximumBet(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<BigUint> {","        SingleValueMapper(baseKey: \"maximumBet\") {","            tokenIdentifier","            tokenNonce","        }","    }","    ","    public func getMaximumBetPercent(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<UInt64> {","        SingleValueMapper(baseKey: \"maximumBetPercent\") {","            tokenIdentifier","            tokenNonce","        }","    }","    ","    public func getTokenReserve(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<BigUint> {","        SingleValueMapper(baseKey: \"tokenReserve\") {","            tokenIdentifier","            tokenNonce","        }","    }","    ","    public func getOwnerPercentFees() -> UInt64 {","        self.ownerPercentFees","    }","    ","    public func getBountyPercentFees() -> UInt64 {","        self.bountyPercentFees","    }","}"],"highlights":[{"line":45},{"line":46},{"line":47},{"line":48}],"type":"file","identifier":"FlipContractWriteTheStorageSection2Step14.swift","fileName":"StorageController.swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Building-Your-First-Smart-Contract":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","title":"Building Your First Smart Contract","kind":"article","url":"\/tutorials\/spacekit\/getting-started\/building-your-first-smart-contract","abstract":[],"type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame#Implement-the-makeFlip-Function":{"url":"\/tutorials\/spacekit\/flipcontractwritethegame#Implement-the-makeFlip-Function","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-makeFlip-Function","kind":"section","abstract":[{"type":"text","text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics."}],"role":"pseudoSymbol","title":"Implement the makeFlip Function"},"FlipContractWriteTheStorageSection1Step1.swift":{"syntax":"swift","identifier":"FlipContractWriteTheStorageSection1Step1.swift","highlights":[],"fileName":"Flip.swift","fileType":"swift","type":"file","content":[""]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-the-bounty-Endpoint":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-the-bounty-Endpoint","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"text":".","type":"text"}],"role":"pseudoSymbol","title":"Test the bounty Endpoint","kind":"section","url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-the-bounty-Endpoint","type":"section"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract","kind":"project","estimatedTime":"20min","type":"topic","role":"project","title":"Building Your First Smart Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract","abstract":[{"text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Creating-Your-Own-Types":{"title":"Creating Your Own Types","role":"pseudoSymbol","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"kind":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Creating-Your-Own-Types","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-unlockFunds-Endpoint":{"type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-unlockFunds-Endpoint","title":"Implementing the unlockFunds Endpoint","kind":"section","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"role":"pseudoSymbol"},"FlipContractWriteTheStorageSection2Step6.swift":{"syntax":"swift","content":["import SpaceKit","","@Controller public struct StorageController {","    @Storage(key: \"ownerPercentFees\") var ownerPercentFees: UInt64","    @Storage(key: \"bountyPercentFees\") var bountyPercentFees: UInt64","    @Storage(key: \"minimumBlockBounty\") var minimumBlockBounty: UInt64","}"],"highlights":[{"line":6}],"type":"file","identifier":"FlipContractWriteTheStorageSection2Step6.swift","fileName":"StorageController.swift","fileType":"swift"},"FlipContractWriteTheStorageSection3Step1.swift":{"syntax":"swift","identifier":"FlipContractWriteTheStorageSection3Step1.swift","highlights":[],"fileName":"init.swift","fileType":"swift","type":"file","content":[""]},"FlipContractWriteTheStorageSection2Step7.swift":{"syntax":"swift","content":["import SpaceKit","","@Controller public struct StorageController {","    @Storage(key: \"ownerPercentFees\") var ownerPercentFees: UInt64","    @Storage(key: \"bountyPercentFees\") var bountyPercentFees: UInt64","    @Storage(key: \"minimumBlockBounty\") var minimumBlockBounty: UInt64","    @Storage(key: \"lastFlipId\") var lastFlipId: UInt64","}"],"highlights":[{"line":7}],"type":"file","identifier":"FlipContractWriteTheStorageSection2Step7.swift","fileName":"StorageController.swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Test-the-Admin-Endpoints":{"type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Admin-Endpoints","role":"article","abstract":[],"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/test-the-admin-endpoints","kind":"article","title":"Test the Admin Endpoints"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Declare-the-Callee-Proxy":{"url":"\/tutorials\/spacekit\/asynccalls#Declare-the-Callee-Proxy","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"title":"Declare the Callee Proxy","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","url":"\/tutorials\/spacekit\/storevalues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","role":"pseudoSymbol","type":"section","kind":"section","abstract":[{"text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory.","type":"text"}],"title":"Leveraging @Mapping for Dynamic Key-Value Storage"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens":{"estimatedTime":"15min","type":"topic","title":"Managing Non-Fungible Tokens","role":"project","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Testing-the-Contract":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Testing-the-Contract","role":"pseudoSymbol","kind":"section","title":"Testing the Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract","type":"section","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Mint-New-Tokens":{"url":"\/tutorials\/spacekit\/operationsonfungibletokens#Mint-New-Tokens","role":"pseudoSymbol","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","type":"section","title":"Mint New Tokens","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Interacting-with-Other-Contracts":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","title":"Interacting with Other Contracts","kind":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/interacting-with-other-contracts","abstract":[],"type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Enhancing-Contracts-with-Token-Attributes":{"abstract":[],"role":"article","kind":"article","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/enhancing-contracts-with-token-attributes","type":"topic","title":"Enhancing Contracts with Token Attributes","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame#Implement-the-flip-Endpoint":{"kind":"section","abstract":[{"type":"text","text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics."}],"type":"section","url":"\/tutorials\/spacekit\/flipcontractwritethegame#Implement-the-flip-Endpoint","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-flip-Endpoint","title":"Implement the flip Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Transaction-Context-Data":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/getinfo#Accessing-Transaction-Context-Data","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"title":"Accessing Transaction Context Data","type":"section","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","role":"project","url":"\/tutorials\/spacekit\/getinfo","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"title":"Retrieving Information from the Blockchain","type":"topic","estimatedTime":"10min","kind":"project"},"FlipContractWriteTheStorageSection2Step4.swift":{"syntax":"swift","identifier":"FlipContractWriteTheStorageSection2Step4.swift","highlights":[{"line":4}],"fileName":"StorageController.swift","fileType":"swift","type":"file","content":["import SpaceKit","","@Controller public struct StorageController {","    @Storage(key: \"ownerPercentFees\") var ownerPercentFees: UInt64","}"]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints":{"url":"\/tutorials\/spacekit\/flipcontracttestadmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints","kind":"section","type":"section","role":"pseudoSymbol","title":"Verify That Only the Owner Can Access Admin Endpoints","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Set-the-Minimum-Block-Bounty-Delay":{"url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Set-the-Minimum-Block-Bounty-Delay","role":"pseudoSymbol","kind":"section","title":"Set the Minimum Block Bounty Delay","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-the-Minimum-Block-Bounty-Delay","type":"section","abstract":[{"text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles":{"abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Assign-Mint-and-Burn-Roles","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","kind":"section","type":"section","title":"Assign Mint and Burn Roles"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-lockFunds-Endpoint":{"url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-lockFunds-Endpoint","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint","kind":"section","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"role":"pseudoSymbol","title":"Implementing the lockFunds Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls":{"title":"Interacting with Contracts Across Shards","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"kind":"project","role":"project","estimatedTime":"15min","type":"topic","url":"\/tutorials\/spacekit\/asynccalls"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage#Implement-Contract-Storage":{"url":"\/tutorials\/spacekit\/flipcontractwritethestorage#Implement-Contract-Storage","kind":"section","type":"section","role":"pseudoSymbol","title":"Implement Contract Storage","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Implement-Contract-Storage","abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}]},"FlipContractWriteTheStorageSection1Step11.swift":{"syntax":"swift","content":["import SpaceKit","","@Codable public struct Flip {","    let id: UInt64","    let playerAddress: Address","    let tokenIdentifier: TokenIdentifier","    let tokenNonce: UInt64","    let amount: BigUint","    let bounty: BigUint","    let blockNonce: UInt64","    let minimumBlockBounty: UInt64","}"],"highlights":[{"line":11}],"type":"file","identifier":"FlipContractWriteTheStorageSection1Step11.swift","fileName":"Flip.swift","fileType":"swift"},"FlipContractWriteTheStorageSection3Step7.swift":{"syntax":"swift","identifier":"FlipContractWriteTheStorageSection3Step7.swift","highlights":[{"line":17},{"line":18}],"fileName":"init.swift","fileType":"swift","type":"file","content":["import SpaceKit","","@Init public func initialize(","    ownerPercentFees: UInt64,","    bountyPercentFees: UInt64,","    minimumBlockBounty: UInt64",") {","    var storageController = StorageController()","    ","    storageController.ownerPercentFees = ownerPercentFees","    storageController.bountyPercentFees = bountyPercentFees","    ","    require(","        minimumBlockBounty > 0,","        \"Minimum block bounty should be greater than zero.\"","    )","    ","    storageController.minimumBlockBounty = minimumBlockBounty","}"]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Increase-Contract-Reserves":{"url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Increase-Contract-Reserves","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Increase-Contract-Reserves","kind":"section","abstract":[{"type":"text","text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets."}],"role":"pseudoSymbol","title":"Increase Contract Reserves"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Understanding-the-Buffer-Type":{"title":"Understanding the Buffer Type","role":"pseudoSymbol","kind":"section","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Understanding-the-Buffer-Type","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type"},"FlipContractWriteTheStorageSection2Step17.swift":{"syntax":"swift","content":["import SpaceKit","","@Controller public struct StorageController {","    @Storage(key: \"ownerPercentFees\") var ownerPercentFees: UInt64","    @Storage(key: \"bountyPercentFees\") var bountyPercentFees: UInt64","    @Storage(key: \"minimumBlockBounty\") var minimumBlockBounty: UInt64","    @Storage(key: \"lastFlipId\") var lastFlipId: UInt64","    @Storage(key: \"lastBountyFlipId\") var lastBountyFlipId: UInt64","    ","    @Mapping<UInt64, Flip>(key: \"flipForId\") var flipForId","    ","    public func getMaximumBet(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<BigUint> {","        SingleValueMapper(baseKey: \"maximumBet\") {","            tokenIdentifier","            tokenNonce","        }","    }","    ","    public func getMaximumBetPercent(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<UInt64> {","        SingleValueMapper(baseKey: \"maximumBetPercent\") {","            tokenIdentifier","            tokenNonce","        }","    }","    ","    public func getTokenReserve(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<BigUint> {","        SingleValueMapper(baseKey: \"tokenReserve\") {","            tokenIdentifier","            tokenNonce","        }","    }","    ","    public func getOwnerPercentFees() -> UInt64 {","        self.ownerPercentFees","    }","    ","    public func getBountyPercentFees() -> UInt64 {","        self.bountyPercentFees","    }","    ","    public func getMinimumBlockBounty() -> UInt64 {","        self.minimumBlockBounty","    }","    ","    public func getLastFlipId() -> UInt64 {","        self.lastFlipId","    }","    ","    public func getLastBountyFlipId() -> UInt64 {","        self.lastBountyFlipId","    }","}"],"highlights":[{"line":57},{"line":58},{"line":59},{"line":60}],"type":"file","identifier":"FlipContractWriteTheStorageSection2Step17.swift","fileName":"StorageController.swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Exploring-SpaceKit's-Types":{"abstract":[],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","title":"Exploring SpaceKit's Types","type":"topic","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/exploring-spacekit's-types","kind":"article","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Withdraw-Contract-Reserves":{"url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Withdraw-Contract-Reserves","role":"pseudoSymbol","kind":"section","title":"Withdraw Contract Reserves","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Withdraw-Contract-Reserves","type":"section","abstract":[{"type":"text","text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets."}]},"FlipContractWriteTheStorageSection2Step5.swift":{"syntax":"swift","identifier":"FlipContractWriteTheStorageSection2Step5.swift","highlights":[{"line":5}],"fileName":"StorageController.swift","fileType":"swift","type":"file","content":["import SpaceKit","","@Controller public struct StorageController {","    @Storage(key: \"ownerPercentFees\") var ownerPercentFees: UInt64","    @Storage(key: \"bountyPercentFees\") var bountyPercentFees: UInt64","}"]},"FlipContractWriteTheStorageSection1Step7.swift":{"syntax":"swift","content":["import SpaceKit","","@Codable public struct Flip {","    let id: UInt64","    let playerAddress: Address","    let tokenIdentifier: TokenIdentifier","    let tokenNonce: UInt64","}"],"highlights":[{"line":7}],"type":"file","identifier":"FlipContractWriteTheStorageSection1Step7.swift","fileName":"Flip.swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Define-the-Storage-for-the-Flip-Contract":{"title":"Define the Storage for the Flip Contract","role":"article","kind":"article","abstract":[],"type":"topic","url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/define-the-storage-for-the-flip-contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Define-the-Storage-for-the-Flip-Contract"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Declare-Constants-for-the-Test-Environment":{"title":"Declare Constants for the Test Environment","role":"pseudoSymbol","kind":"section","abstract":[{"text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/flipcontractinittests#Declare-Constants-for-the-Test-Environment","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Declare-Constants-for-the-Test-Environment"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract":{"title":"Issuing a Non-Fungible Token from Your Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","type":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"kind":"section","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Non-Fungible-Token-from-Your-Contract"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Write-Tests-for-the-Setup-Helpers":{"type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Write-Tests-for-the-Setup-Helpers","role":"pseudoSymbol","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}],"url":"\/tutorials\/spacekit\/flipcontractinittests#Write-Tests-for-the-Setup-Helpers","kind":"section","title":"Write Tests for the Setup Helpers"},"FlipContractWriteTheStorageSection3Step4.swift":{"syntax":"swift","identifier":"FlipContractWriteTheStorageSection3Step4.swift","highlights":[{"line":8}],"fileName":"init.swift","fileType":"swift","type":"file","content":["import SpaceKit","","@Init public func initialize(","    ownerPercentFees: UInt64,","    bountyPercentFees: UInt64,","    minimumBlockBounty: UInt64",") {","    var storageController = StorageController()","}"]},"FlipContractWriteTheStorageSection2Step16.swift":{"syntax":"swift","content":["import SpaceKit","","@Controller public struct StorageController {","    @Storage(key: \"ownerPercentFees\") var ownerPercentFees: UInt64","    @Storage(key: \"bountyPercentFees\") var bountyPercentFees: UInt64","    @Storage(key: \"minimumBlockBounty\") var minimumBlockBounty: UInt64","    @Storage(key: \"lastFlipId\") var lastFlipId: UInt64","    @Storage(key: \"lastBountyFlipId\") var lastBountyFlipId: UInt64","    ","    @Mapping<UInt64, Flip>(key: \"flipForId\") var flipForId","    ","    public func getMaximumBet(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<BigUint> {","        SingleValueMapper(baseKey: \"maximumBet\") {","            tokenIdentifier","            tokenNonce","        }","    }","    ","    public func getMaximumBetPercent(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<UInt64> {","        SingleValueMapper(baseKey: \"maximumBetPercent\") {","            tokenIdentifier","            tokenNonce","        }","    }","    ","    public func getTokenReserve(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<BigUint> {","        SingleValueMapper(baseKey: \"tokenReserve\") {","            tokenIdentifier","            tokenNonce","        }","    }","    ","    public func getOwnerPercentFees() -> UInt64 {","        self.ownerPercentFees","    }","    ","    public func getBountyPercentFees() -> UInt64 {","        self.bountyPercentFees","    }","    ","    public func getMinimumBlockBounty() -> UInt64 {","        self.minimumBlockBounty","    }","    ","    public func getLastFlipId() -> UInt64 {","        self.lastFlipId","    }","}"],"highlights":[{"line":53},{"line":54},{"line":55},{"line":56}],"type":"file","identifier":"FlipContractWriteTheStorageSection2Step16.swift","fileName":"StorageController.swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Writing-the-Contract-Code":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Writing-the-Contract-Code","role":"pseudoSymbol","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","type":"section","title":"Writing the Contract Code","kind":"section"},"FlipContractWriteTheStorageSection2Step15.swift":{"syntax":"swift","identifier":"FlipContractWriteTheStorageSection2Step15.swift","highlights":[{"line":49},{"line":50},{"line":51},{"line":52}],"fileName":"StorageController.swift","fileType":"swift","type":"file","content":["import SpaceKit","","@Controller public struct StorageController {","    @Storage(key: \"ownerPercentFees\") var ownerPercentFees: UInt64","    @Storage(key: \"bountyPercentFees\") var bountyPercentFees: UInt64","    @Storage(key: \"minimumBlockBounty\") var minimumBlockBounty: UInt64","    @Storage(key: \"lastFlipId\") var lastFlipId: UInt64","    @Storage(key: \"lastBountyFlipId\") var lastBountyFlipId: UInt64","    ","    @Mapping<UInt64, Flip>(key: \"flipForId\") var flipForId","    ","    public func getMaximumBet(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<BigUint> {","        SingleValueMapper(baseKey: \"maximumBet\") {","            tokenIdentifier","            tokenNonce","        }","    }","    ","    public func getMaximumBetPercent(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<UInt64> {","        SingleValueMapper(baseKey: \"maximumBetPercent\") {","            tokenIdentifier","            tokenNonce","        }","    }","    ","    public func getTokenReserve(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<BigUint> {","        SingleValueMapper(baseKey: \"tokenReserve\") {","            tokenIdentifier","            tokenNonce","        }","    }","    ","    public func getOwnerPercentFees() -> UInt64 {","        self.ownerPercentFees","    }","    ","    public func getBountyPercentFees() -> UInt64 {","        self.bountyPercentFees","    }","    ","    public func getMinimumBlockBounty() -> UInt64 {","        self.minimumBlockBounty","    }","}"]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Test-the-withdrawReserve-Endpoint":{"type":"section","kind":"section","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}],"title":"Test the withdrawReserve Endpoint","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/flipcontracttestadmin#Test-the-withdrawReserve-Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-withdrawReserve-Endpoint"},"FlipContractWriteTheStorageSection1Step9.swift":{"syntax":"swift","content":["import SpaceKit","","@Codable public struct Flip {","    let id: UInt64","    let playerAddress: Address","    let tokenIdentifier: TokenIdentifier","    let tokenNonce: UInt64","    let amount: BigUint","    let bounty: BigUint","}"],"highlights":[{"line":9}],"type":"file","identifier":"FlipContractWriteTheStorageSection1Step9.swift","fileName":"Flip.swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Implement-the-Game-Logic-for-the-Flip-Contract":{"title":"Implement the Game Logic for the Flip Contract","role":"article","kind":"article","abstract":[],"type":"topic","url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/implement-the-game-logic-for-the-flip-contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Implement-the-Game-Logic-for-the-Flip-Contract"},"FlipContractWriteTheStorageSection2Step12.swift":{"syntax":"swift","identifier":"FlipContractWriteTheStorageSection2Step12.swift","highlights":[{"line":31},{"line":32},{"line":33},{"line":34},{"line":35},{"line":36},{"line":37},{"line":38},{"line":39},{"line":40}],"fileName":"StorageController.swift","fileType":"swift","type":"file","content":["import SpaceKit","","@Controller public struct StorageController {","    @Storage(key: \"ownerPercentFees\") var ownerPercentFees: UInt64","    @Storage(key: \"bountyPercentFees\") var bountyPercentFees: UInt64","    @Storage(key: \"minimumBlockBounty\") var minimumBlockBounty: UInt64","    @Storage(key: \"lastFlipId\") var lastFlipId: UInt64","    @Storage(key: \"lastBountyFlipId\") var lastBountyFlipId: UInt64","    ","    @Mapping<UInt64, Flip>(key: \"flipForId\") var flipForId","    ","    public func getMaximumBet(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<BigUint> {","        SingleValueMapper(baseKey: \"maximumBet\") {","            tokenIdentifier","            tokenNonce","        }","    }","    ","    public func getMaximumBetPercent(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<UInt64> {","        SingleValueMapper(baseKey: \"maximumBetPercent\") {","            tokenIdentifier","            tokenNonce","        }","    }","    ","    public func getTokenReserve(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<BigUint> {","        SingleValueMapper(baseKey: \"tokenReserve\") {","            tokenIdentifier","            tokenNonce","        }","    }","}"]},"FlipContractWriteTheStorageSection1Step2.swift":{"syntax":"swift","content":["import SpaceKit"],"highlights":[{"line":1}],"type":"file","identifier":"FlipContractWriteTheStorageSection1Step2.swift","fileName":"Flip.swift","fileType":"swift"},"FlipContractWriteTheStorageSection1Step8.swift":{"syntax":"swift","identifier":"FlipContractWriteTheStorageSection1Step8.swift","highlights":[{"line":8}],"fileName":"Flip.swift","fileType":"swift","type":"file","content":["import SpaceKit","","@Codable public struct Flip {","    let id: UInt64","    let playerAddress: Address","    let tokenIdentifier: TokenIdentifier","    let tokenNonce: UInt64","    let amount: BigUint","}"]},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract":{"url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Fungible-Token-from-Your-Contract","role":"pseudoSymbol","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","type":"section","title":"Issuing a Fungible Token from Your Contract","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract":{"title":"Issuing a Semi-Fungible Token from Your Contract","type":"section","role":"pseudoSymbol","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"text":" ","type":"text"},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract"},"FlipContractWriteTheStorageSection3Step5.swift":{"syntax":"swift","content":["import SpaceKit","","@Init public func initialize(","    ownerPercentFees: UInt64,","    bountyPercentFees: UInt64,","    minimumBlockBounty: UInt64",") {","    var storageController = StorageController()","    ","    storageController.ownerPercentFees = ownerPercentFees","    storageController.bountyPercentFees = bountyPercentFees","}"],"highlights":[{"line":9},{"line":10},{"line":11}],"type":"file","identifier":"FlipContractWriteTheStorageSection3Step5.swift","fileName":"init.swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract":{"url":"\/tutorials\/spacekit\/flipcontractinittests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract","role":"pseudoSymbol","kind":"section","title":"Create Helper Functions to Deploy and Configure the Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract","type":"section","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}]},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Declare-the-Callee-Proxy":{"type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","url":"\/tutorials\/spacekit\/synccalls#Declare-the-Callee-Proxy","title":"Declare the Callee Proxy","kind":"section","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}],"role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens":{"url":"\/tutorials\/spacekit\/understandtokens","estimatedTime":"15min","role":"project","kind":"project","title":"Understand the ESDT Standard","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens","type":"topic","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame","estimatedTime":"20min","abstract":[{"type":"text","text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics."}],"role":"project","title":"Implement the Game Logic for the Flip Contract","kind":"project","url":"\/tutorials\/spacekit\/flipcontractwritethegame","type":"topic"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges":{"title":"Handling Heap Allocation Challenges","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"kind":"section","role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Handling-Heap-Allocation-Challenges"},"FlipContractWriteTheStorageSection1Step3.swift":{"syntax":"swift","identifier":"FlipContractWriteTheStorageSection1Step3.swift","highlights":[{"line":2},{"line":3},{"line":4}],"fileName":"Flip.swift","fileType":"swift","type":"file","content":["import SpaceKit","","@Codable public struct Flip {","}"]},"FlipContractWriteTheStorageSection2Step9.swift":{"syntax":"swift","content":["import SpaceKit","","@Controller public struct StorageController {","    @Storage(key: \"ownerPercentFees\") var ownerPercentFees: UInt64","    @Storage(key: \"bountyPercentFees\") var bountyPercentFees: UInt64","    @Storage(key: \"minimumBlockBounty\") var minimumBlockBounty: UInt64","    @Storage(key: \"lastFlipId\") var lastFlipId: UInt64","    @Storage(key: \"lastBountyFlipId\") var lastBountyFlipId: UInt64","    ","    @Mapping<UInt64, Flip>(key: \"flipForId\") var flipForId","}"],"highlights":[{"line":9},{"line":10}],"type":"file","identifier":"FlipContractWriteTheStorageSection2Step9.swift","fileName":"StorageController.swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit":{"title":"Meet SpaceKit","abstract":[{"type":"text","text":"Discover how SpaceKit simplifies blockchain development using Swift. Dive into the world of Web3 with ease and efficiency."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","url":"\/tutorials\/spacekit","role":"overview","kind":"overview","type":"topic"},"FlipContractWriteTheStorageSection1Step4.swift":{"syntax":"swift","identifier":"FlipContractWriteTheStorageSection1Step4.swift","highlights":[{"line":4}],"fileName":"Flip.swift","fileType":"swift","type":"file","content":["import SpaceKit","","@Codable public struct Flip {","    let id: UInt64","}"]},"FlipContractWriteTheStorageSection2Step2.swift":{"highlights":[{"line":1}],"content":["import SpaceKit"],"syntax":"swift","identifier":"FlipContractWriteTheStorageSection2Step2.swift","fileType":"swift","fileName":"StorageController.swift","type":"file"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Initializing-the-Project":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Initializing-the-Project","role":"pseudoSymbol","kind":"section","title":"Initializing the Project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","type":"section","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}]},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Fungible-Tokens":{"url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-fungible-tokens","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens","kind":"article","abstract":[],"role":"article","title":"Managing Fungible Tokens"},"FlipContractWriteTheStorageSection1Step10.swift":{"type":"file","fileType":"swift","content":["import SpaceKit","","@Codable public struct Flip {","    let id: UInt64","    let playerAddress: Address","    let tokenIdentifier: TokenIdentifier","    let tokenNonce: UInt64","    let amount: BigUint","    let bounty: BigUint","    let blockNonce: UInt64","}"],"syntax":"swift","identifier":"FlipContractWriteTheStorageSection1Step10.swift","fileName":"Flip.swift","highlights":[{"line":10}]},"FlipContractWriteTheStorageSection1Step5.swift":{"highlights":[{"line":5}],"content":["import SpaceKit","","@Codable public struct Flip {","    let id: UInt64","    let playerAddress: Address","}"],"syntax":"swift","identifier":"FlipContractWriteTheStorageSection1Step5.swift","fileType":"swift","fileName":"Flip.swift","type":"file"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint":{"abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"role":"pseudoSymbol","kind":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-changeTokenLockDuration-Endpoint","type":"section","title":"Implementing the changeTokenLockDuration Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint"},"FlipContractWriteTheStorageSection2Step1.swift":{"type":"file","fileType":"swift","content":[""],"syntax":"swift","identifier":"FlipContractWriteTheStorageSection2Step1.swift","fileName":"StorageController.swift","highlights":[]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes":{"type":"topic","url":"\/tutorials\/spacekit\/familiarizewithtypes","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes","estimatedTime":"20min","role":"project","kind":"project","title":"Exploring SpaceKit's Types","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame#Define-the-bounty-Endpoint":{"abstract":[{"text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics.","type":"text"}],"kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Define-the-bounty-Endpoint","type":"section","title":"Define the bounty Endpoint","url":"\/tutorials\/spacekit\/flipcontractwritethegame#Define-the-bounty-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Installing-the-Tools":{"abstract":[],"role":"article","kind":"article","url":"\/tutorials\/spacekit\/getting-started\/installing-the-tools","type":"topic","title":"Installing the Tools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Setting-Up-the-SpaceKit-CLI":{"url":"\/tutorials\/spacekit\/installingtools#Setting-Up-the-SpaceKit-CLI","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI","kind":"section","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"role":"pseudoSymbol","title":"Setting Up the SpaceKit CLI"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Configure-the-Initial-Blockchain-State":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Configure-the-Initial-Blockchain-State","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/flipcontractinittests#Configure-the-Initial-Blockchain-State","type":"section","title":"Configure the Initial Blockchain State","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}],"kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce":{"title":"Add Quantity to an Existing Nonce","role":"pseudoSymbol","kind":"section","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Add-Quantity-to-an-Existing-Nonce","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage#Define-the-Flip-Structure":{"abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}],"url":"\/tutorials\/spacekit\/flipcontractwritethestorage#Define-the-Flip-Structure","role":"pseudoSymbol","title":"Define the Flip Structure","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Flip-Structure"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Non-Fungible-Tokens":{"url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-non-fungible-tokens","kind":"article","type":"topic","role":"article","title":"Managing Non-Fungible Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Create-Utility-Functions-for-flip-and-bounty":{"url":"\/tutorials\/spacekit\/flipcontracttestthegame#Create-Utility-Functions-for-flip-and-bounty","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Create-Utility-Functions-for-flip-and-bounty","kind":"section","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"text":".","type":"text"}],"role":"pseudoSymbol","title":"Create Utility Functions for flip and bounty"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-Failure-Case-for-the-bounty-Endpoint":{"url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-Failure-Case-for-the-bounty-Endpoint","role":"pseudoSymbol","kind":"section","title":"Test Failure Case for the bounty Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Case-for-the-bounty-Endpoint","type":"section","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"text":".","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin":{"estimatedTime":"20min","url":"\/tutorials\/spacekit\/flipcontractwriteadmin","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin","type":"topic","kind":"project","title":"Add Administrative Endpoints to the Flip Contract","role":"project","abstract":[{"text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Verify-the-Maximum-Bet-Configuration-Endpoints":{"url":"\/tutorials\/spacekit\/flipcontracttestadmin#Verify-the-Maximum-Bet-Configuration-Endpoints","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-the-Maximum-Bet-Configuration-Endpoints","kind":"section","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}],"role":"pseudoSymbol","title":"Verify the Maximum Bet Configuration Endpoints"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Create-a-New-Nonce":{"abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"role":"pseudoSymbol","kind":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Create-a-New-Nonce","type":"section","title":"Create a New Nonce","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Blockchain-Context-Data":{"abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"url":"\/tutorials\/spacekit\/getinfo#Accessing-Blockchain-Context-Data","role":"pseudoSymbol","title":"Accessing Blockchain Context Data","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data"},"FlipContractWriteTheStorageSection2Step10.swift":{"fileName":"StorageController.swift","type":"file","content":["import SpaceKit","","@Controller public struct StorageController {","    @Storage(key: \"ownerPercentFees\") var ownerPercentFees: UInt64","    @Storage(key: \"bountyPercentFees\") var bountyPercentFees: UInt64","    @Storage(key: \"minimumBlockBounty\") var minimumBlockBounty: UInt64","    @Storage(key: \"lastFlipId\") var lastFlipId: UInt64","    @Storage(key: \"lastBountyFlipId\") var lastBountyFlipId: UInt64","    ","    @Mapping<UInt64, Flip>(key: \"flipForId\") var flipForId","    ","    public func getMaximumBet(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<BigUint> {","        SingleValueMapper(baseKey: \"maximumBet\") {","            tokenIdentifier","            tokenNonce","        }","    }","}"],"fileType":"swift","highlights":[{"line":11},{"line":12},{"line":13},{"line":14},{"line":15},{"line":16},{"line":17},{"line":18},{"line":19},{"line":20}],"identifier":"FlipContractWriteTheStorageSection2Step10.swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Calling-Contracts-Across-Shards":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","title":"Calling Contracts Across Shards","kind":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/calling-contracts-across-shards","abstract":[],"type":"topic","role":"article"},"FlipContractWriteTheStorageSection2Step13.swift":{"fileName":"StorageController.swift","fileType":"swift","type":"file","identifier":"FlipContractWriteTheStorageSection2Step13.swift","highlights":[{"line":41},{"line":42},{"line":43},{"line":44}],"syntax":"swift","content":["import SpaceKit","","@Controller public struct StorageController {","    @Storage(key: \"ownerPercentFees\") var ownerPercentFees: UInt64","    @Storage(key: \"bountyPercentFees\") var bountyPercentFees: UInt64","    @Storage(key: \"minimumBlockBounty\") var minimumBlockBounty: UInt64","    @Storage(key: \"lastFlipId\") var lastFlipId: UInt64","    @Storage(key: \"lastBountyFlipId\") var lastBountyFlipId: UInt64","    ","    @Mapping<UInt64, Flip>(key: \"flipForId\") var flipForId","    ","    public func getMaximumBet(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<BigUint> {","        SingleValueMapper(baseKey: \"maximumBet\") {","            tokenIdentifier","            tokenNonce","        }","    }","    ","    public func getMaximumBetPercent(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<UInt64> {","        SingleValueMapper(baseKey: \"maximumBetPercent\") {","            tokenIdentifier","            tokenNonce","        }","    }","    ","    public func getTokenReserve(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<BigUint> {","        SingleValueMapper(baseKey: \"tokenReserve\") {","            tokenIdentifier","            tokenNonce","        }","    }","    ","    public func getOwnerPercentFees() -> UInt64 {","        self.ownerPercentFees","    }","}"]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-Vector-Type":{"url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-Vector-Type","type":"section","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"title":"Working with the Vector Type","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Set-Up-the-Test-Project":{"title":"Set Up the Test Project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Set-Up-the-Test-Project","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}],"url":"\/tutorials\/spacekit\/flipcontractinittests#Set-Up-the-Test-Project","type":"section","kind":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens":{"type":"topic","estimatedTime":"15min","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","role":"project","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"url":"\/tutorials\/spacekit\/operationsonfungibletokens","kind":"project","title":"Managing Fungible Tokens"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Add-Administrative-Endpoints-to-the-Flip-Contract":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/add-administrative-endpoints-to-the-flip-contract","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Add-Administrative-Endpoints-to-the-Flip-Contract","kind":"article","abstract":[],"role":"article","title":"Add Administrative Endpoints to the Flip Contract"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Perform-an-Asynchronous-Call":{"url":"\/tutorials\/spacekit\/asynccalls#Perform-an-Asynchronous-Call","kind":"section","type":"section","role":"pseudoSymbol","title":"Perform an Asynchronous Call","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Burn-Tokens":{"title":"Burn Tokens","role":"pseudoSymbol","kind":"section","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Burn-Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage":{"title":"Define the Storage for the Flip Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage","abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}],"kind":"project","role":"project","estimatedTime":"20min","type":"topic","url":"\/tutorials\/spacekit\/flipcontractwritethestorage"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Set-Maximum-Bet-Limits":{"kind":"section","abstract":[{"type":"text","text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets."}],"type":"section","url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Set-Maximum-Bet-Limits","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-Maximum-Bet-Limits","title":"Set Maximum Bet Limits"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Retrieving-Information-from-the-Blockchain":{"type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","role":"article","abstract":[],"url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/retrieving-information-from-the-blockchain","kind":"article","title":"Retrieving Information from the Blockchain"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-Successful-Calls-to-the-flip-Endpoint":{"title":"Test Successful Calls to the flip Endpoint","role":"pseudoSymbol","kind":"section","abstract":[{"text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the ","type":"text"},{"type":"codeVoice","code":"GameController"},{"type":"text","text":"."}],"type":"section","url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-Successful-Calls-to-the-flip-Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Successful-Calls-to-the-flip-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","url":"\/tutorials\/spacekit\/tokenattributes","role":"project","type":"topic","kind":"project","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"estimatedTime":"15min","title":"Enhance Your Contracts with Token Attributes"},"FlipContractWriteTheStorageSection2Step11.swift":{"fileName":"StorageController.swift","fileType":"swift","type":"file","identifier":"FlipContractWriteTheStorageSection2Step11.swift","highlights":[{"line":21},{"line":22},{"line":23},{"line":24},{"line":25},{"line":26},{"line":27},{"line":28},{"line":29},{"line":30}],"syntax":"swift","content":["import SpaceKit","","@Controller public struct StorageController {","    @Storage(key: \"ownerPercentFees\") var ownerPercentFees: UInt64","    @Storage(key: \"bountyPercentFees\") var bountyPercentFees: UInt64","    @Storage(key: \"minimumBlockBounty\") var minimumBlockBounty: UInt64","    @Storage(key: \"lastFlipId\") var lastFlipId: UInt64","    @Storage(key: \"lastBountyFlipId\") var lastBountyFlipId: UInt64","    ","    @Mapping<UInt64, Flip>(key: \"flipForId\") var flipForId","    ","    public func getMaximumBet(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<BigUint> {","        SingleValueMapper(baseKey: \"maximumBet\") {","            tokenIdentifier","            tokenNonce","        }","    }","    ","    public func getMaximumBetPercent(","        tokenIdentifier: TokenIdentifier,","        tokenNonce: UInt64","    ) -> SingleValueMapper<UInt64> {","        SingleValueMapper(baseKey: \"maximumBetPercent\") {","            tokenIdentifier","            tokenNonce","        }","    }","}"]},"FlipContractWriteTheStorageSection2Step8.swift":{"fileType":"swift","type":"file","fileName":"StorageController.swift","identifier":"FlipContractWriteTheStorageSection2Step8.swift","highlights":[{"line":8}],"content":["import SpaceKit","","@Controller public struct StorageController {","    @Storage(key: \"ownerPercentFees\") var ownerPercentFees: UInt64","    @Storage(key: \"bountyPercentFees\") var bountyPercentFees: UInt64","    @Storage(key: \"minimumBlockBounty\") var minimumBlockBounty: UInt64","    @Storage(key: \"lastFlipId\") var lastFlipId: UInt64","    @Storage(key: \"lastBountyFlipId\") var lastBountyFlipId: UInt64","}"],"syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Working-with-Storage-for-Single-Value-Persistence":{"title":"Working with @Storage for Single Value Persistence","role":"pseudoSymbol","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"kind":"section","url":"\/tutorials\/spacekit\/storevalues#Working-with-Storage-for-Single-Value-Persistence","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence"}}}
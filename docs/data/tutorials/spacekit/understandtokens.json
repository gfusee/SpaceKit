{"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens"},"metadata":{"category":"SpaceKit","title":"Understand the ESDT Standard","role":"project","categoryPathComponent":"SpaceKit"},"kind":"project","variants":[{"paths":["\/tutorials\/spacekit\/understandtokens"],"traits":[{"interfaceLanguage":"swift"}]}],"schemaVersion":{"major":0,"patch":0,"minor":3},"hierarchy":{"modules":[{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract"}]},{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues"}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens"}]},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes"}],"paths":[["doc:\/\/SpaceKit\/tutorials\/SpaceKit","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens"]],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit"},"sections":[{"title":"Understand the ESDT Standard","kind":"hero","content":[{"type":"paragraph","inlineContent":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"type":"text","text":" "},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Fungible tokens"}],"type":"strong"},{"text":" are interchangeable, like traditional currencies. For example, one USDC token has the same value as another.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Non-fungible tokens"}],"type":"strong"},{"type":"text","text":" represent unique assets. In a flight ticket collection, each ticket is distinct, with specific attributes like seat number and boarding options."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Semi-fungible tokens","type":"text"}]},{"type":"text","text":" combine aspects of fungibility and uniqueness. For example, state bonds with a unique year of issuance are fungible within their group but distinct between groups."}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Meta-esdt tokens"}],"type":"strong"},{"type":"text","text":" expand semi-fungibility by enabling on-chain attributes, supporting complex operations with types like "},{"type":"codeVoice","code":"Buffer"},{"text":", ","type":"text"},{"type":"codeVoice","code":"BigUint"},{"text":", and even custom ","type":"text"},{"type":"codeVoice","code":"@Codable"},{"text":" structs or enums.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"The ESDT standard enables various token operations, such as minting, burning, and freezing, ensuring transparency by requiring all supported actions to be defined at issuance."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Semi-fungible tokens operate similarly to NFTs, but for a given nonce, there can be multiple identical tokens. For example, state bonds labeled "},{"type":"codeVoice","code":"$BOND"},{"type":"text","text":" could have different nonces for the year they were issued. If "},{"type":"codeVoice","code":"$BOND#1"},{"type":"text","text":" represents bonds from 2010 and "},{"code":"$BOND#2","type":"codeVoice"},{"text":" represents those from 2011, all tokens with the same nonce are fungible within their group, as they share the same maturity date.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Meta-esdt tokens enhance this concept by allowing attributes to be added on-chain for each nonce. These attributes can be of any SpaceKit-compatible type, such as ","type":"text"},{"code":"Buffer","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"BigUint"},{"type":"text","text":", or "},{"type":"codeVoice","code":"UInt64"},{"type":"text","text":", or even complex structs and enums with the "},{"code":"@Codable","type":"codeVoice"},{"text":" annotation. Meta-esdt is powerful because it enables contracts to process on-chain logic using these attributes.","type":"text"}]},{"inlineContent":[{"text":"The ESDT standard supports various token operations like minting, burning, freezing, and more. These actions must be explicitly declared at the time of token issuance, ensuring transparency. For example, a non-mintable ESDT cannot be minted or altered after issuance.","type":"text"}],"type":"paragraph"}],"chapter":"Creating and Understanding Tokens","estimatedTimeInMinutes":15},{"kind":"tasks","tasks":[{"stepsSection":[{"code":"UnderstandTokensSection1Step1.swift","content":[{"inlineContent":[{"type":"text","text":"Define the contract structure."}],"type":"paragraph"}],"caption":[],"type":"step","media":null,"runtimePreview":null},{"code":"UnderstandTokensSection1Step2.swift","runtimePreview":null,"type":"step","caption":[],"media":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Declare storage to hold the token identifier."}]}]},{"caption":[{"inlineContent":[{"text":"Ensure the caller pays the issuance fee.","type":"text"}],"type":"paragraph"}],"runtimePreview":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"Implement an endpoint for token issuance."}],"type":"paragraph"}],"media":null,"code":"UnderstandTokensSection1Step3.swift"},{"caption":[],"runtimePreview":null,"type":"step","media":null,"content":[{"inlineContent":[{"text":"Restrict issuance to the contract owner and prevent duplicate token identifiers.","type":"text"}],"type":"paragraph"}],"code":"UnderstandTokensSection1Step4.swift"},{"type":"step","caption":[],"code":"UnderstandTokensSection1Step5.swift","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Retrieve the issuance fee from the caller.","type":"text"}]}],"media":null},{"content":[{"inlineContent":[{"type":"text","text":"Make an asynchronous call to the token issuance contract, defining properties such as "},{"code":"canMint","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"}],"type":"step","media":null,"caption":[{"inlineContent":[{"type":"text","text":"Use a human-readable display name for the token."}],"type":"paragraph"}],"code":"UnderstandTokensSection1Step6.swift","runtimePreview":null},{"caption":[{"inlineContent":[{"text":"Retain the caller’s payment to refund in case of failure.","type":"text"}],"type":"paragraph"}],"media":null,"runtimePreview":null,"code":"UnderstandTokensSection1Step7.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Register a promise to handle the asynchronous call."}]}],"type":"step"},{"caption":[{"inlineContent":[{"text":"You can retrieve the new identifier in the payments if initialSupply > 0, if initialSupply == 0 you can declare result as a AsyncCallResult<Buffer> to retrieve it.","type":"text"}],"type":"paragraph"}],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Create a callback to process the result of the asynchronous call."}]}],"type":"step","code":"UnderstandTokensSection1Step8.swift","media":null,"runtimePreview":null},{"runtimePreview":null,"type":"step","content":[{"inlineContent":[{"text":"Save the issued token identifier and initial supply in storage upon success.","type":"text"}],"type":"paragraph"}],"media":null,"code":"UnderstandTokensSection1Step9.swift","caption":[]},{"caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Refund the caller in case of an issuance error."}]}],"code":"UnderstandTokensSection1Step10.swift","media":null,"runtimePreview":null,"type":"step"},{"caption":[],"media":null,"code":"UnderstandTokensSection1Step11.swift","runtimePreview":null,"content":[{"inlineContent":[{"text":"Link the callback to the promise registration.","type":"text"}],"type":"paragraph"}],"type":"step"}],"title":"Issuing a Fungible Token from Your Contract","contentSection":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Issuing a fungible token involves invoking a built-in smart contract. On networks like MultiversX, the issuance fee is 0.5 EGLD. In this section, you’ll create a mintable and burnable token called ","type":"text"},{"type":"codeVoice","code":"SPACE"},{"type":"text","text":", with essential properties tailored to your needs."}]}],"kind":"contentAndMedia","mediaPosition":"trailing"}],"anchor":"Issuing-a-Fungible-Token-from-Your-Contract"},{"contentSection":[{"kind":"contentAndMedia","content":[{"inlineContent":[{"type":"text","text":"Once you’ve learned how to issue a fungible token, creating other types of tokens follows a similar process."}],"type":"paragraph"}],"mediaPosition":"trailing"}],"title":"Issuing a Non-Fungible Token from Your Contract","stepsSection":[{"runtimePreview":null,"type":"step","code":"UnderstandTokensSection3Step1.swift","content":[{"inlineContent":[{"text":"Use the ","type":"text"},{"type":"codeVoice","code":"Blockchain.issueNonFungibleToken"},{"type":"text","text":" function to issue a non-fungible token."}],"type":"paragraph"}],"media":null,"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Important: The result type of the asynchronous call in the callback differs from the one in the previous section."}]}]}],"anchor":"Issuing-a-Non-Fungible-Token-from-Your-Contract"},{"stepsSection":[{"type":"step","media":null,"code":"UnderstandTokensSection4Step1.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use the "},{"type":"codeVoice","code":"Blockchain.issueSemiFungibleToken"},{"text":" function to issue a semi-fungible token.","type":"text"}]}],"runtimePreview":null,"caption":[]}],"contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"text":"Semi-fungible tokens share similarities with non-fungible tokens, but they allow multiple tokens per nonce. As a result, issuing a semi-fungible token closely follows the steps for issuing a non-fungible token.","type":"text"}]}],"mediaPosition":"trailing"}],"title":"Issuing a Semi-Fungible Token from Your Contract","anchor":"Issuing-a-Semi-Fungible-Token-from-Your-Contract"},{"title":"Issuing a Meta ESDT from Your Contract","anchor":"Issuing-a-Meta-ESDT-from-Your-Contract","contentSection":[{"content":[{"inlineContent":[{"type":"text","text":"Beyond NFTs and SFTs, the SpaceVM introduces Meta ESDTs, a specialized type of semi-fungible token. Meta ESDTs function like standard ESDT fungible tokens but include additional properties. For example, they can be used for locked tokens where their properties define the release schedule."}],"type":"paragraph"}],"mediaPosition":"trailing","kind":"contentAndMedia"}],"stepsSection":[{"code":"UnderstandTokensSection5Step1.swift","type":"step","runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"Use the "},{"type":"codeVoice","code":"Blockchain.issueSemiFungibleToken"},{"type":"text","text":" function to issue a Meta ESDT."}],"type":"paragraph"}],"media":null,"caption":[{"inlineContent":[{"text":"Note: The only difference from issuing a semi-fungible token is the specification of the number of decimal places.","type":"text"}],"type":"paragraph"}]}]}]},{"title":"Managing Fungible Tokens","action":{"type":"reference","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","isActive":true,"overridingTitleInlineContent":[{"text":"Get started","type":"text"}],"overridingTitle":"Get started"},"featuredEyebrow":"Tutorial","kind":"callToAction","abstract":[{"text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with.","type":"text"}]}],"references":{"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Persisting-Data-Across-Executions":{"url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/persisting-data-across-executions","role":"article","kind":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","abstract":[],"type":"topic","title":"Persisting Data Across Executions"},"UnderstandTokensSection1Step8.swift":{"type":"file","syntax":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: \/\/ We will fill this parameter later","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            \/\/ We will fill the success case later","        case .error(_):","            \/\/ We will fill the error case later","        }","    }","","}",""],"highlights":[{"line":38},{"line":39},{"line":40},{"line":41},{"line":42},{"line":43},{"line":44},{"line":45},{"line":46},{"line":47},{"line":48},{"line":49}],"identifier":"UnderstandTokensSection1Step8.swift","fileName":"lib.swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Testing-the-Contract":{"abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract","type":"section","title":"Testing the Contract","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Testing-the-Contract","role":"pseudoSymbol","kind":"section"},"UnderstandTokensSection3Step1.swift":{"content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueNonFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueNonFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: NonFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"highlights":[],"fileName":"lib.swift","identifier":"UnderstandTokensSection3Step1.swift","fileType":"swift","type":"file","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls":{"kind":"project","role":"project","url":"\/tutorials\/spacekit\/asynccalls","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","title":"Interacting with Contracts Across Shards","estimatedTime":"15min","type":"topic"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Working-with-Storage-for-Single-Value-Persistence":{"url":"\/tutorials\/spacekit\/storevalues#Working-with-Storage-for-Single-Value-Persistence","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"type":"section","title":"Working with @Storage for Single Value Persistence"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo":{"url":"\/tutorials\/spacekit\/getinfo","role":"project","title":"Retrieving Information from the Blockchain","estimatedTime":"10min","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"type":"topic","kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Understanding-the-Buffer-Type":{"abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","type":"section","title":"Understanding the Buffer Type","kind":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Understanding-the-Buffer-Type","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Fungible-Tokens":{"kind":"article","title":"Managing Fungible Tokens","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-fungible-tokens","abstract":[],"role":"article","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens"},"UnderstandTokensSection1Step3.swift":{"type":"file","syntax":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        ","    }","}",""],"highlights":[{"line":5},{"line":6},{"line":7},{"line":8}],"identifier":"UnderstandTokensSection1Step3.swift","fileName":"lib.swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-lockFunds-Endpoint":{"kind":"section","title":"Implementing the lockFunds Endpoint","type":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-lockFunds-Endpoint","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/familiarizewithtypes#Handling-Heap-Allocation-Challenges","type":"section","kind":"section","title":"Handling Heap Allocation Challenges"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract":{"title":"Issuing a Meta ESDT from Your Contract","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Meta-ESDT-from-Your-Contract","role":"pseudoSymbol","type":"section","kind":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"text":" ","type":"text"},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract"},"UnderstandTokensSection1Step10.swift":{"content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: \/\/ We will fill this parameter later","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"highlights":[{"line":48},{"line":49}],"fileName":"lib.swift","identifier":"UnderstandTokensSection1Step10.swift","fileType":"swift","type":"file","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Building-Your-First-Smart-Contract":{"role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","type":"topic","abstract":[],"kind":"article","url":"\/tutorials\/spacekit\/getting-started\/building-your-first-smart-contract","title":"Building Your First Smart Contract"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Assign-Create-AddQuantity-and-Burn-Roles","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"type":"section","title":"Assign Create, AddQuantity, and Burn Roles"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","url":"\/tutorials\/spacekit\/tokenattributes","estimatedTime":"15min","role":"project","type":"topic","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"title":"Enhance Your Contracts with Token Attributes","kind":"project"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","title":"Issuing a Semi-Fungible Token from Your Contract","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","kind":"section","type":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}]},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Non-Fungible-Tokens":{"kind":"article","title":"Managing Non-Fungible Tokens","type":"topic","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-non-fungible-tokens","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Declare-the-Callee-Proxy":{"kind":"section","title":"Declare the Callee Proxy","type":"section","url":"\/tutorials\/spacekit\/synccalls#Declare-the-Callee-Proxy","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Add-Quantity-to-an-Existing-Nonce","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce","type":"section","kind":"section","title":"Add Quantity to an Existing Nonce","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","url":"\/tutorials\/spacekit\/operationsonfungibletokens","estimatedTime":"15min","role":"project","type":"topic","abstract":[{"text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with.","type":"text"}],"title":"Managing Fungible Tokens","kind":"project"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Create-a-New-Nonce":{"kind":"section","title":"Create a New Nonce","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Create-a-New-Nonce","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"role":"pseudoSymbol","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens":{"url":"\/tutorials\/spacekit\/understandtokens","type":"topic","kind":"project","estimatedTime":"15min","title":"Understand the ESDT Standard","role":"project","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"text":" ","type":"text"},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens"},"UnderstandTokensSection1Step11.swift":{"type":"file","syntax":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"highlights":[{"line":35},{"line":36},{"line":37},{"line":38}],"identifier":"UnderstandTokensSection1Step11.swift","fileName":"lib.swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Mint-New-Tokens":{"kind":"section","title":"Mint New Tokens","type":"section","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Mint-New-Tokens","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-BigUint-Type":{"abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","type":"section","title":"Working with the BigUint Type","url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-BigUint-Type","role":"pseudoSymbol","kind":"section"},"UnderstandTokensSection1Step1.swift":{"content":["import SpaceKit","","@Controller public struct MyContract {","    ","}",""],"highlights":[],"fileName":"lib.swift","identifier":"UnderstandTokensSection1Step1.swift","fileType":"swift","type":"file","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract":{"abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","type":"section","title":"Issuing a Non-Fungible Token from Your Contract","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","role":"pseudoSymbol","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Perform-a-Synchronous-Call":{"abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","type":"section","title":"Perform a Synchronous Call","url":"\/tutorials\/spacekit\/synccalls#Perform-a-Synchronous-Call","role":"pseudoSymbol","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Burn-Tokens":{"kind":"section","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Burn-Tokens","title":"Burn Tokens","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"role":"pseudoSymbol","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Creating-and-Understanding-Tokens":{"role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","type":"topic","abstract":[],"kind":"article","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/creating-and-understanding-tokens","title":"Creating and Understanding Tokens"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Perform-an-Asynchronous-Call":{"url":"\/tutorials\/spacekit\/asynccalls#Perform-an-Asynchronous-Call","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"type":"section","title":"Perform an Asynchronous Call"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Writing-the-Contract-Code":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","title":"Writing the Contract Code","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Writing-the-Contract-Code","kind":"section","type":"section","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}]},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Setting-Up-the-SpaceKit-CLI":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI","type":"section","kind":"section","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"title":"Setting Up the SpaceKit CLI","url":"\/tutorials\/spacekit\/installingtools#Setting-Up-the-SpaceKit-CLI"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Retrieving-Information-from-the-Blockchain":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","title":"Retrieving Information from the Blockchain","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/retrieving-information-from-the-blockchain","abstract":[],"role":"article","kind":"article","type":"topic"},"UnderstandTokensSection1Step5.swift":{"type":"file","syntax":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","    }","}",""],"highlights":[{"line":12},{"line":13}],"identifier":"UnderstandTokensSection1Step5.swift","fileName":"lib.swift","fileType":"swift"},"UnderstandTokensSection5Step1.swift":{"content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueNonFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .registerMetaEsdt(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: MetaTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"highlights":[],"fileName":"lib.swift","identifier":"UnderstandTokensSection5Step1.swift","fileType":"swift","type":"file","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-unlockFunds-Endpoint":{"title":"Implementing the unlockFunds Endpoint","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-unlockFunds-Endpoint","role":"pseudoSymbol","type":"section","kind":"section","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens","role":"project","title":"Managing Non-Fungible Tokens","estimatedTime":"15min","type":"topic","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools":{"estimatedTime":"10min","abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"title":"Install the Necessary Tools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","role":"project","url":"\/tutorials\/spacekit\/installingtools","type":"topic","kind":"project"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Installing-the-Tools":{"kind":"article","title":"Installing the Tools","type":"topic","url":"\/tutorials\/spacekit\/getting-started\/installing-the-tools","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes":{"url":"\/tutorials\/spacekit\/familiarizewithtypes","role":"project","title":"Exploring SpaceKit's Types","estimatedTime":"20min","type":"topic","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues":{"abstract":[{"text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory.","type":"text"}],"role":"project","kind":"project","url":"\/tutorials\/spacekit\/storevalues","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues","title":"Persist Values Between Executions","type":"topic","estimatedTime":"15min"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Assign-Mint-and-Burn-Roles","type":"section","kind":"section","title":"Assign Mint and Burn Roles"},"UnderstandTokensSection4Step1.swift":{"type":"file","syntax":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueNonFungibleToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueSemiFungibleToken(","                tokenDisplayName: \"TestToken\",","                tokenTicker: \"TEST\",","                properties: SemiFungibleTokenProperties(","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canTransferCreateRole: false,","                    canChangeOwner: false,","                    canUpgrade: false,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: self.$issueTokenCallback(","                    sentValue: payment,","                    gasForCallback: 15_000_000","                )","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<TokenIdentifier> = Message.asyncCallResult()","        ","        switch result {","        case .success(let tokenIdentifier):","            self.issuedTokenIdentifier = tokenIdentifier","        case .error(_):","            Blockchain.getOwner()","                .send(egldValue: sentValue)","        }","    }","}",""],"highlights":[],"identifier":"UnderstandTokensSection4Step1.swift","fileName":"lib.swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Declare-the-Callee-Proxy":{"url":"\/tutorials\/spacekit\/asynccalls#Declare-the-Callee-Proxy","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"type":"section","title":"Declare the Callee Proxy"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint":{"role":"pseudoSymbol","title":"Implementing the changeTokenLockDuration Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint","kind":"section","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"type":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-changeTokenLockDuration-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract":{"kind":"section","title":"Initializing and Compiling Your First Smart Contract","type":"section","url":"\/tutorials\/spacekit\/installingtools#Initializing-and-Compiling-Your-First-Smart-Contract","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}]},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Initializing-the-Project":{"kind":"section","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Initializing-the-Project","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"role":"pseudoSymbol","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","title":"Initializing the Project"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-Vector-Type":{"kind":"section","title":"Working with the Vector Type","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-Vector-Type","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}]},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Transaction-Context-Data":{"kind":"section","title":"Accessing Transaction Context Data","type":"section","url":"\/tutorials\/spacekit\/getinfo#Accessing-Transaction-Context-Data","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Creating-Your-Own-Types":{"kind":"section","title":"Creating Your Own Types","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Creating-Your-Own-Types","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Burn-Tokens":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Burn-Tokens","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"type":"section","title":"Burn Tokens"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Installing-SpaceKits-Dependencies":{"kind":"section","title":"Installing SpaceKit's Dependencies","type":"section","url":"\/tutorials\/spacekit\/installingtools#Installing-SpaceKits-Dependencies","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}]},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls":{"url":"\/tutorials\/spacekit\/synccalls","role":"project","title":"Interact with Other Contracts","estimatedTime":"15min","type":"topic","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}],"kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Exploring-SpaceKit's-Types":{"kind":"article","title":"Exploring SpaceKit's Types","type":"topic","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/exploring-spacekit's-types","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","abstract":[]},"UnderstandTokensSection1Step7.swift":{"content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: \/\/ We will fill this parameter later","            )","    }","}",""],"highlights":[{"line":32},{"line":33},{"line":34},{"line":35},{"line":36}],"fileName":"lib.swift","identifier":"UnderstandTokensSection1Step7.swift","fileType":"swift","type":"file","syntax":"swift"},"UnderstandTokensSection1Step4.swift":{"type":"file","syntax":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","    }","}",""],"highlights":[{"line":7},{"line":8},{"line":9},{"line":10},{"line":11}],"fileName":"lib.swift","identifier":"UnderstandTokensSection1Step4.swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Interacting-with-Other-Contracts":{"url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/interacting-with-other-contracts","role":"article","kind":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","abstract":[],"type":"topic","title":"Interacting with Other Contracts"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract":{"abstract":[{"text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions.","type":"text"}],"role":"project","kind":"project","url":"\/tutorials\/spacekit\/codingyourfirstcontract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract","title":"Building Your First Smart Contract","type":"topic","estimatedTime":"20min"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","type":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"kind":"section","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Fungible-Token-from-Your-Contract","title":"Issuing a Fungible Token from Your Contract"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Blockchain-Context-Data":{"kind":"section","title":"Accessing Blockchain Context Data","type":"section","url":"\/tutorials\/spacekit\/getinfo#Accessing-Blockchain-Context-Data","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}]},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage":{"kind":"section","title":"Leveraging @Mapping for Dynamic Key-Value Storage","type":"section","url":"\/tutorials\/spacekit\/storevalues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}]},"UnderstandTokensSection1Step2.swift":{"content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","}",""],"highlights":[{"line":4}],"fileName":"lib.swift","identifier":"UnderstandTokensSection1Step2.swift","fileType":"swift","type":"file","syntax":"swift"},"UnderstandTokensSection1Step9.swift":{"type":"file","syntax":"swift","content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","            .registerPromise(","                gas: 30_000_000,","                value: payment,","                callback: \/\/ We will fill this parameter later","            )","    }","    ","    @Callback public mutating func issueTokenCallback(sentValue: BigUint) {","        let result: AsyncCallResult<IgnoreValue> = Message.asyncCallResult()","        ","        switch result {","        case .success(_):","            let receivedPayment = Message.singleFungibleEsdt","            ","            self.issuedTokenIdentifier = receivedPayment.tokenIdentifier","        case .error(_):","            \/\/ We will fill the error case later","        }","    }","","}",""],"highlights":[{"line":44},{"line":45},{"line":46}],"identifier":"UnderstandTokensSection1Step9.swift","fileName":"lib.swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Enhancing-Contracts-with-Token-Attributes":{"kind":"article","title":"Enhancing Contracts with Token Attributes","type":"topic","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/enhancing-contracts-with-token-attributes","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes","abstract":[]},"UnderstandTokensSection1Step6.swift":{"content":["import SpaceKit","","@Controller public struct MyContract {","    @Storage(key: \"issuedTokenIdentifier\") var issuedTokenIdentifier: TokenIdentifier","    ","    public func issueToken() {","        assertOwner()","","        if !self.$issuedTokenIdentifier.isEmpty() {","            smartContractError(message: \"Token already issued\")","        }","        ","        let payment = Message.egldValue","        ","        Blockchain","            .issueFungibleToken(","                tokenDisplayName: \"SpaceKitToken\",","                tokenTicker: \"SPACE\",","                initialSupply: 1,","                properties: FungibleTokenProperties(","                    numDecimals: 18,","                    canFreeze: false,","                    canWipe: false,","                    canPause: false,","                    canMint: true,","                    canBurn: true,","                    canChangeOwner: true,","                    canUpgrade: true,","                    canAddSpecialRoles: true","                )","            )","    }","}",""],"highlights":[{"line":14},{"line":15},{"line":16},{"line":17},{"line":18},{"line":19},{"line":20},{"line":21},{"line":22},{"line":23},{"line":24},{"line":25},{"line":26},{"line":27},{"line":28},{"line":29},{"line":30},{"line":31}],"fileName":"lib.swift","identifier":"UnderstandTokensSection1Step6.swift","fileType":"swift","type":"file","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit":{"abstract":[{"text":"Discover how SpaceKit simplifies blockchain development using Swift. Dive into the world of Web3 with ease and efficiency.","type":"text"}],"role":"overview","type":"topic","kind":"overview","title":"Meet SpaceKit","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","url":"\/tutorials\/spacekit"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Calling-Contracts-Across-Shards":{"kind":"article","title":"Calling Contracts Across Shards","type":"topic","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/calling-contracts-across-shards","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","abstract":[]}}}
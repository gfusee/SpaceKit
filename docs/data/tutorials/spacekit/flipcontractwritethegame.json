{"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/tutorials\/spacekit\/flipcontractwritethegame"]}],"sections":[{"chapter":"Implement the Game Logic for the Flip Contract","title":"Implement the Game Logic for the Flip Contract","kind":"hero","estimatedTimeInMinutes":20,"content":[{"type":"paragraph","inlineContent":[{"text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this tutorial, you’ll implement a "},{"code":"GameController","type":"codeVoice"},{"text":" containing two endpoints and one utility function:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"flip"},{"type":"text","text":": The function players call to place a bet. It processes the payment, verifies that the bet does not exceed the maximum limit, deducts and transfers the owner’s fee, and calculates (but does not immediately distribute) the bounty reward."}]}]},{"content":[{"inlineContent":[{"code":"bounty","type":"codeVoice"},{"text":": A function that allows anyone to process all pending flips in a single call. This process, referred to as “bountying a flip,” involves generating a random number—either 0 or 1—to determine whether the player wins or loses.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"code":"makeFlip","type":"codeVoice"},{"type":"text","text":": A private function responsible for resolving a single flip. Since "},{"type":"codeVoice","code":"bounty"},{"text":" needs to process multiple flips, it iterates over all pending flips and calls ","type":"text"},{"code":"makeFlip","type":"codeVoice"},{"type":"text","text":" for each one."}],"type":"paragraph"}]}],"type":"unorderedList"}]},{"kind":"tasks","tasks":[{"title":"Implement the flip Endpoint","anchor":"Implement-the-flip-Endpoint","contentSection":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Start by defining the "},{"code":"GameController","type":"codeVoice"},{"text":" and implementing the ","type":"text"},{"code":"flip","type":"codeVoice"},{"text":" endpoint.","type":"text"}]},{"inlineContent":[{"type":"text","text":"You’ll also declare a constant named "},{"type":"codeVoice","code":"HUNDRED_PERCENT"},{"type":"text","text":", set to "},{"code":"10_000","type":"codeVoice"},{"type":"text","text":". Since integer division truncates results ("},{"code":"10\/3 = 3","type":"codeVoice"},{"type":"text","text":"), fractional percentages cannot be directly represented. To work around this, consider "},{"type":"codeVoice","code":"10_000"},{"type":"text","text":" as the full percentage scale (100%). For instance, to represent "},{"code":"0.1%","type":"codeVoice"},{"type":"text","text":", use "},{"type":"codeVoice","code":"100"},{"type":"text","text":", which is "},{"code":"0.1%","type":"codeVoice"},{"type":"text","text":" of "},{"code":"10_000","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}],"mediaPosition":"trailing","kind":"contentAndMedia"}],"stepsSection":[{"type":"step","media":null,"runtimePreview":null,"code":"FlipContractWriteTheGameSection1Step1.swift","content":[{"inlineContent":[{"type":"text","text":"Create a new file named "},{"code":"GameController.swift","type":"codeVoice"},{"text":" inside ","type":"text"},{"type":"codeVoice","code":"Contracts\/Flip\/Source"},{"type":"text","text":"."}],"type":"paragraph"}],"caption":[]},{"caption":[],"runtimePreview":null,"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Import the "},{"type":"codeVoice","code":"SpaceKit"},{"type":"text","text":" framework."}]}],"media":null,"code":"FlipContractWriteTheGameSection1Step2.swift"},{"code":"FlipContractWriteTheGameSection1Step3.swift","runtimePreview":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"Define "},{"code":"HUNDRED_PERCENT","type":"codeVoice"},{"type":"text","text":" as a "},{"type":"codeVoice","code":"UInt64"},{"text":" constant.","type":"text"}],"type":"paragraph"}],"caption":[],"media":null},{"media":null,"caption":[],"type":"step","code":"FlipContractWriteTheGameSection1Step4.swift","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Declare the ","type":"text"},{"code":"GameController","type":"codeVoice"},{"type":"text","text":" controller."}]}]},{"runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define the "},{"code":"flip","type":"codeVoice"},{"type":"text","text":" endpoint."}]}],"caption":[],"media":null,"type":"step","code":"FlipContractWriteTheGameSection1Step5.swift"},{"caption":[],"code":"FlipContractWriteTheGameSection1Step6.swift","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Retrieve the payment made by the player."}]}],"type":"step","media":null},{"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Since storage values will be modified, the controller needs to be mutable."}]}],"code":"FlipContractWriteTheGameSection1Step7.swift","runtimePreview":null,"media":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Create a mutable instance of ","type":"text"},{"code":"StorageController","type":"codeVoice"},{"text":".","type":"text"}]}],"type":"step"},{"code":"FlipContractWriteTheGameSection1Step8.swift","caption":[],"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Retrieve the token reserve, absolute maximum bet, and percentage-based maximum bet.","type":"text"}]}],"media":null,"runtimePreview":null},{"type":"step","runtimePreview":null,"media":null,"caption":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Important:"}]},{"type":"text","text":" Always multiply before dividing when handling integers. "},{"type":"codeVoice","code":"100 * 300 \/ 1000 = 30"},{"type":"text","text":" is correct but "},{"type":"codeVoice","code":"100 * (300 \/ 1000) = 100 * 0 = 0"},{"type":"text","text":" is incorrect."}],"type":"paragraph"}],"content":[{"inlineContent":[{"type":"text","text":"Compute the actual maximum bet percentage value as a fraction of the token reserve."}],"type":"paragraph"}],"code":"FlipContractWriteTheGameSection1Step9.swift"},{"media":null,"runtimePreview":null,"type":"step","code":"FlipContractWriteTheGameSection1Step10.swift","content":[{"type":"paragraph","inlineContent":[{"text":"Determine the overall maximum bet by selecting the lower value between the absolute and percentage-based limits.","type":"text"}]}],"caption":[]},{"type":"step","media":null,"caption":[],"code":"FlipContractWriteTheGameSection1Step11.swift","runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"Calculate the owner’s fee."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Calculate the bounty incentive."}],"type":"paragraph"}],"runtimePreview":null,"caption":[],"code":"FlipContractWriteTheGameSection1Step12.swift","type":"step","media":null},{"caption":[{"inlineContent":[{"text":"This is the amount that will be doubled if the player wins.","type":"text"}],"type":"paragraph"}],"code":"FlipContractWriteTheGameSection1Step13.swift","runtimePreview":null,"media":null,"type":"step","content":[{"inlineContent":[{"text":"Determine the final amount representing the flip.","type":"text"}],"type":"paragraph"}]},{"runtimePreview":null,"type":"step","media":null,"content":[{"inlineContent":[{"type":"text","text":"Ensure the bet does not exceed the maximum allowed amount."}],"type":"paragraph"}],"caption":[],"code":"FlipContractWriteTheGameSection1Step14.swift"},{"type":"step","media":null,"code":"FlipContractWriteTheGameSection1Step15.swift","runtimePreview":null,"caption":[],"content":[{"inlineContent":[{"type":"text","text":"Generate a new flip ID by incrementing the previous one."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Create a ","type":"text"},{"code":"Flip","type":"codeVoice"},{"type":"text","text":" instance containing all necessary details."}]}],"runtimePreview":null,"media":null,"caption":[],"type":"step","code":"FlipContractWriteTheGameSection1Step16.swift"},{"caption":[],"type":"step","media":null,"content":[{"inlineContent":[{"text":"Reduce the token reserve by the flip amount.","type":"text"}],"type":"paragraph"}],"code":"FlipContractWriteTheGameSection1Step17.swift","runtimePreview":null},{"type":"step","code":"FlipContractWriteTheGameSection1Step18.swift","caption":[],"media":null,"content":[{"inlineContent":[{"type":"text","text":"Transfer the owner’s fee."}],"type":"paragraph"}],"runtimePreview":null},{"caption":[],"type":"step","media":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Store the new flip ID and its details.","type":"text"}]}],"code":"FlipContractWriteTheGameSection1Step19.swift","runtimePreview":null}]},{"contentSection":[{"kind":"contentAndMedia","mediaPosition":"trailing","content":[{"inlineContent":[{"type":"text","text":"Now that the contract can register flips, the next step is to define the "},{"type":"codeVoice","code":"makeFlip"},{"type":"text","text":" utility function before implementing the "},{"code":"bounty","type":"codeVoice"},{"type":"text","text":" endpoint."}],"type":"paragraph"}]}],"anchor":"Implement-the-makeFlip-Function","title":"Implement the makeFlip Function","stepsSection":[{"content":[{"inlineContent":[{"type":"text","text":"Start with the code from the previous section."}],"type":"paragraph"}],"type":"step","code":"FlipContractWriteTheGameSection1Step19.swift","caption":[],"media":null,"runtimePreview":null},{"content":[{"type":"paragraph","inlineContent":[{"text":"Declare the ","type":"text"},{"code":"makeFlip","type":"codeVoice"},{"type":"text","text":" function and mark it as "},{"code":"private","type":"codeVoice"},{"type":"text","text":" to prevent external access."}]}],"caption":[{"type":"paragraph","inlineContent":[{"text":"It takes two arguments: the address receiving the bounty reward and the flip’s details.","type":"text"}]}],"media":null,"code":"FlipContractWriteTheGameSection2Step2.swift","runtimePreview":null,"type":"step"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Generate a random number between 0 and 1."}]}],"type":"step","code":"FlipContractWriteTheGameSection2Step3.swift","caption":[{"inlineContent":[{"inlineContent":[{"text":"Tip:","type":"text"}],"type":"strong"},{"type":"text","text":" Use "},{"type":"codeVoice","code":"Randomness.nextUInt8InRange"},{"type":"text","text":", which returns a random "},{"code":"UInt8","type":"codeVoice"},{"type":"text","text":" in the specified range ("},{"code":"min","type":"codeVoice"},{"text":" inclusive, ","type":"text"},{"type":"codeVoice","code":"max"},{"text":" exclusive).","type":"text"}],"type":"paragraph"}],"media":null,"runtimePreview":null},{"type":"step","code":"FlipContractWriteTheGameSection2Step4.swift","caption":[],"runtimePreview":null,"content":[{"inlineContent":[{"text":"Check if the random number equals 1 to determine whether the flip is a win.","type":"text"}],"type":"paragraph"}],"media":null},{"code":"FlipContractWriteTheGameSection2Step5.swift","media":null,"runtimePreview":null,"caption":[],"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Transfer the bounty reward to the specified address.","type":"text"}]}]},{"runtimePreview":null,"code":"FlipContractWriteTheGameSection2Step6.swift","type":"step","media":null,"caption":[],"content":[{"type":"paragraph","inlineContent":[{"text":"Calculate the payout amount in case of a win.","type":"text"}]}]},{"type":"step","code":"FlipContractWriteTheGameSection2Step7.swift","caption":[],"media":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Instantiate a ","type":"text"},{"code":"StorageController","type":"codeVoice"},{"text":" instance.","type":"text"}]}],"runtimePreview":null},{"caption":[],"runtimePreview":null,"media":null,"content":[{"inlineContent":[{"type":"text","text":"Define conditional logic to handle winning and losing scenarios."}],"type":"paragraph"}],"code":"FlipContractWriteTheGameSection2Step8.swift","type":"step"},{"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If the flip is a win, transfer the winnings to the player."}]}],"code":"FlipContractWriteTheGameSection2Step9.swift","runtimePreview":null,"caption":[],"media":null},{"code":"FlipContractWriteTheGameSection2Step10.swift","caption":[],"type":"step","runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"If the flip is a loss, update the token reserve accordingly."}],"type":"paragraph"}],"media":null},{"code":"FlipContractWriteTheGameSection2Step11.swift","content":[{"type":"paragraph","inlineContent":[{"text":"Remove the flip entry from storage after processing.","type":"text"}]}],"caption":[],"media":null,"runtimePreview":null,"type":"step"}]},{"title":"Define the bounty Endpoint","stepsSection":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Start with the code from the previous section."}]}],"caption":[],"media":null,"code":"FlipContractWriteTheGameSection2Step11.swift","type":"step","runtimePreview":null},{"content":[{"type":"paragraph","inlineContent":[{"text":"Declare the ","type":"text"},{"code":"bounty","type":"codeVoice"},{"type":"text","text":" endpoint."}]}],"caption":[],"media":null,"code":"FlipContractWriteTheGameSection3Step2.swift","type":"step","runtimePreview":null},{"type":"step","code":"FlipContractWriteTheGameSection3Step3.swift","content":[{"type":"paragraph","inlineContent":[{"text":"Retrieve the caller.","type":"text"}]}],"media":null,"runtimePreview":null,"caption":[]},{"caption":[{"inlineContent":[{"type":"text","text":"Smart contracts can revert the transaction if the random number doesn’t suit them."}],"type":"paragraph"}],"content":[{"type":"paragraph","inlineContent":[{"text":"Ensure the caller is not a smart contract.","type":"text"}]}],"type":"step","media":null,"code":"FlipContractWriteTheGameSection3Step4.swift","runtimePreview":null},{"caption":[{"inlineContent":[{"text":"The difference allows us to know which flips are pending.","type":"text"}],"type":"paragraph"}],"code":"FlipContractWriteTheGameSection3Step5.swift","type":"step","runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"Retrieve the last flip’s id in the storage, and the last bountied flip id."}],"type":"paragraph"}],"media":null},{"media":null,"runtimePreview":null,"caption":[],"code":"FlipContractWriteTheGameSection3Step6.swift","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Ensure there is at least one flip to bounty."}]}],"type":"step"},{"code":"FlipContractWriteTheGameSection3Step7.swift","type":"step","media":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Retrieve the current block nonce."}]}],"caption":[],"runtimePreview":null},{"type":"step","media":null,"code":"FlipContractWriteTheGameSection3Step8.swift","content":[{"type":"paragraph","inlineContent":[{"text":"Create a variable that will act as a counter in the ","type":"text"},{"code":"while","type":"codeVoice"},{"text":" loop.","type":"text"}]}],"caption":[],"runtimePreview":null},{"caption":[{"type":"paragraph","inlineContent":[{"text":"Each iteration of the loop will try to ","type":"text"},{"type":"codeVoice","code":"makeFlip"},{"type":"text","text":" for a single flip."}]}],"runtimePreview":null,"content":[{"inlineContent":[{"text":"Create the ","type":"text"},{"code":"while","type":"codeVoice"},{"type":"text","text":" loop that will loop over all the pending flips."}],"type":"paragraph"}],"code":"FlipContractWriteTheGameSection3Step9.swift","media":null,"type":"step"},{"caption":[],"code":"FlipContractWriteTheGameSection3Step10.swift","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Get the loop’s flip id we will call "},{"type":"codeVoice","code":"makeFlip"},{"type":"text","text":" with."}]}],"type":"step","media":null},{"type":"step","code":"FlipContractWriteTheGameSection3Step11.swift","caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If the storage is empty, it means there is no pending flip anymore, we can "},{"code":"break","type":"codeVoice"},{"type":"text","text":" the loop."}]}],"content":[{"inlineContent":[{"text":"Check if flip exists in the storage.","type":"text"}],"type":"paragraph"}],"media":null,"runtimePreview":null},{"content":[{"inlineContent":[{"type":"text","text":"Retrieve the flip from the storage."}],"type":"paragraph"}],"caption":[],"media":null,"code":"FlipContractWriteTheGameSection3Step12.swift","type":"step","runtimePreview":null},{"type":"step","content":[{"inlineContent":[{"text":"Ensure enough blocks passed to bounty the flip. ","type":"text"},{"type":"codeVoice","code":"break"},{"text":" the loop otherwise.","type":"text"}],"type":"paragraph"}],"code":"FlipContractWriteTheGameSection3Step13.swift","caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If one pending flips cannot be bountied yet, then all the next flips cannot be too."}]}],"media":null,"runtimePreview":null},{"type":"step","code":"FlipContractWriteTheGameSection3Step14.swift","content":[{"inlineContent":[{"type":"text","text":"Call "},{"type":"codeVoice","code":"makeFlip"},{"type":"text","text":" for this flip. The bounty address is the caller of the endpoint."}],"type":"paragraph"}],"caption":[],"runtimePreview":null,"media":null},{"caption":[],"media":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Set the variable acting as a counter to the bountied flip id.","type":"text"}]}],"type":"step","code":"FlipContractWriteTheGameSection3Step15.swift","runtimePreview":null},{"code":"FlipContractWriteTheGameSection3Step16.swift","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"After the loop, ensure at least one flip has been bountied."}]}],"media":null,"caption":[],"type":"step"},{"type":"step","media":null,"content":[{"inlineContent":[{"text":"Set the last bountied flip id into the storage.","type":"text"}],"type":"paragraph"}],"code":"FlipContractWriteTheGameSection3Step17.swift","runtimePreview":null,"caption":[]}],"anchor":"Define-the-bounty-Endpoint","contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We touch to the end of our contract, let’s write the last endpoint: "},{"type":"codeVoice","code":"bounty"},{"type":"text","text":"."}]}],"mediaPosition":"trailing"}]}]},{"featuredEyebrow":"Tutorial","title":"Set Up Testing in the SwiftVM","abstract":[{"text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential.","type":"text"}],"kind":"callToAction","action":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests","type":"reference","isActive":true,"overridingTitle":"Get started","overridingTitleInlineContent":[{"text":"Get started","type":"text"}]}}],"kind":"project","identifier":{"interfaceLanguage":"swift","url":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame"},"metadata":{"categoryPathComponent":"SpaceKit","role":"project","category":"SpaceKit","title":"Implement the Game Logic for the Flip Contract"},"hierarchy":{"paths":[["doc:\/\/SpaceKit\/tutorials\/SpaceKit","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Implement-the-Game-Logic-for-the-Flip-Contract"]],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","modules":[{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","kind":"task"}]}]},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards"},{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","kind":"task"}]}]},{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens"},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Build-a-Coin-Flip-Smart-Contract","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro#Set-Up-the-Project","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Define-the-Storage-for-the-Flip-Contract","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Flip-Structure"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Implement-Contract-Storage","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Contract-Init","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Add-Administrative-Endpoints-to-the-Flip-Contract","projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-the-Minimum-Block-Bounty-Delay"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-Maximum-Bet-Limits"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Increase-Contract-Reserves","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Withdraw-Contract-Reserves","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin"}]},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-flip-Endpoint"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-makeFlip-Function","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Define-the-bounty-Endpoint"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Implement-the-Game-Logic-for-the-Flip-Contract"},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Set-Up-the-Test-Project","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Declare-Constants-for-the-Test-Environment"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Configure-the-Initial-Blockchain-State","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Write-Tests-for-the-Setup-Helpers"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Set-Up-Testing-in-the-SwiftVM"},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-the-Maximum-Bet-Configuration-Endpoints","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-increaseReserve-Endpoint"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-withdrawReserve-Endpoint","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Admin-Endpoints"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Game-Logic-for-the-Flip-Contract","projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Create-Utility-Functions-for-flip-and-bounty"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Cases-for-the-flip-Endpoint","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Successful-Calls-to-the-flip-Endpoint"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Case-for-the-bounty-Endpoint","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-the-bounty-Endpoint"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame"}]}]},"schemaVersion":{"patch":0,"major":0,"minor":3},"references":{"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Writing-the-Contract-Code":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Writing-the-Contract-Code","role":"pseudoSymbol","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","type":"section","title":"Writing the Contract Code","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Creating-and-Understanding-Tokens":{"url":"\/tutorials\/spacekit\/create-and-manage-tokens\/creating-and-understanding-tokens","kind":"article","type":"topic","role":"article","title":"Creating and Understanding Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Set-Maximum-Bet-Limits":{"kind":"section","abstract":[{"type":"text","text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets."}],"type":"section","url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Set-Maximum-Bet-Limits","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-Maximum-Bet-Limits","title":"Set Maximum Bet Limits"},"FlipContractWriteTheGameSection1Step19.swift":{"identifier":"FlipContractWriteTheGameSection1Step19.swift","fileName":"GameController.swift","syntax":"swift","type":"file","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","}"],"highlights":[],"fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests":{"url":"\/tutorials\/spacekit\/flipcontractinittests","type":"topic","kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests","estimatedTime":"20min","abstract":[{"text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential.","type":"text"}],"title":"Set Up Testing in the SwiftVM","role":"project"},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Building-Your-First-Smart-Contract":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","title":"Building Your First Smart Contract","kind":"article","url":"\/tutorials\/spacekit\/getting-started\/building-your-first-smart-contract","abstract":[],"type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Add-Administrative-Endpoints-to-the-Flip-Contract":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/add-administrative-endpoints-to-the-flip-contract","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Add-Administrative-Endpoints-to-the-Flip-Contract","kind":"article","abstract":[],"role":"article","title":"Add Administrative Endpoints to the Flip Contract"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Assign-Create-AddQuantity-and-Burn-Roles","kind":"section","type":"section","role":"pseudoSymbol","title":"Assign Create, AddQuantity, and Burn Roles","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}]},"FlipContractWriteTheGameSection1Step12.swift":{"type":"file","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","    }","}"],"highlights":[{"line":38}],"fileType":"swift","identifier":"FlipContractWriteTheGameSection1Step12.swift","fileName":"GameController.swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Create-Utility-Functions-for-flip-and-bounty":{"url":"\/tutorials\/spacekit\/flipcontracttestthegame#Create-Utility-Functions-for-flip-and-bounty","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Create-Utility-Functions-for-flip-and-bounty","kind":"section","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"text":".","type":"text"}],"role":"pseudoSymbol","title":"Create Utility Functions for flip and bounty"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce":{"title":"Add Quantity to an Existing Nonce","role":"pseudoSymbol","kind":"section","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Add-Quantity-to-an-Existing-Nonce","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce"},"FlipContractWriteTheGameSection1Step10.swift":{"identifier":"FlipContractWriteTheGameSection1Step10.swift","fileName":"GameController.swift","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","    }","}"],"syntax":"swift","type":"file","highlights":[{"line":35}],"fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Withdraw-Contract-Reserves":{"url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Withdraw-Contract-Reserves","role":"pseudoSymbol","kind":"section","title":"Withdraw Contract Reserves","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Withdraw-Contract-Reserves","type":"section","abstract":[{"type":"text","text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets."}]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes":{"type":"topic","url":"\/tutorials\/spacekit\/familiarizewithtypes","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes","estimatedTime":"20min","role":"project","kind":"project","title":"Exploring SpaceKit's Types","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint":{"abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"role":"pseudoSymbol","kind":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-changeTokenLockDuration-Endpoint","type":"section","title":"Implementing the changeTokenLockDuration Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","role":"project","url":"\/tutorials\/spacekit\/getinfo","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"title":"Retrieving Information from the Blockchain","type":"topic","estimatedTime":"10min","kind":"project"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-unlockFunds-Endpoint":{"type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-unlockFunds-Endpoint","title":"Implementing the unlockFunds Endpoint","kind":"section","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens":{"type":"topic","estimatedTime":"15min","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","role":"project","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"url":"\/tutorials\/spacekit\/operationsonfungibletokens","kind":"project","title":"Managing Fungible Tokens"},"FlipContractWriteTheGameSection3Step14.swift":{"identifier":"FlipContractWriteTheGameSection3Step14.swift","fileName":"GameController.swift","syntax":"swift","type":"file","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    public func bounty() {","        let caller = Message.caller","        ","        require(","            !caller.isSmartContract,","            \"This endpoint cannot be called by a smart contract.\"","        )","        ","        var storageController = StorageController()","        ","        let lastBountyFlipId = storageController.lastBountyFlipId","        let lastFlipId = storageController.lastFlipId","        ","        require(","            lastBountyFlipId < lastFlipId,","            \"No flip to bounty.\"","        )","        ","        let currentBlockNonce = Blockchain.getBlockNonce()","        var bountyFlipId = lastBountyFlipId","        ","        while bountyFlipId < lastFlipId {","            let flipId = bountyFlipId + 1","            ","            if storageController.$flipForId[flipId].isEmpty() {","                break","            }","            ","            let flip = storageController.flipForId[flipId]","            ","            if currentBlockNonce < flip.blockNonce + flip.minimumBlockBounty {","                break","            }","            ","            self.makeFlip(","                bountyAddress: caller,","                flip: flip","            )","        }","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","        ","        bountyAddress.send(","            tokenIdentifier: flip.tokenIdentifier,","            nonce: flip.tokenNonce,","            amount: flip.bounty","        )","        ","        let profitIfWin = flip.amount * 2","        ","        let storageController = StorageController()","        ","        if isWin {","            if flip.tokenIdentifier.isEGLD {","                flip.playerAddress","                    .send(egldValue: profitIfWin)","            } else {","                flip.playerAddress","                    .send(","                        tokenIdentifier: flip.tokenIdentifier,","                        nonce: flip.tokenNonce,","                        amount: profitIfWin","                    )","            }","        } else {","            storageController.getTokenReserve(","                tokenIdentifier: flip.tokenIdentifier,","                tokenNonce: flip.tokenNonce","            )","            .update { $0 = $0 + profitIfWin }","        }","        ","        storageController.$flipForId[flip.id].clear()","    }","}"],"highlights":[{"line":116},{"line":117},{"line":118},{"line":119},{"line":120}],"fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Enhancing-Contracts-with-Token-Attributes":{"abstract":[],"role":"article","kind":"article","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/enhancing-contracts-with-token-attributes","type":"topic","title":"Enhancing Contracts with Token Attributes","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes"},"FlipContractWriteTheGameSection3Step3.swift":{"type":"file","fileName":"GameController.swift","fileType":"swift","highlights":[{"line":84}],"identifier":"FlipContractWriteTheGameSection3Step3.swift","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    public func bounty() {","        let caller = Message.caller","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","        ","        bountyAddress.send(","            tokenIdentifier: flip.tokenIdentifier,","            nonce: flip.tokenNonce,","            amount: flip.bounty","        )","        ","        let profitIfWin = flip.amount * 2","        ","        let storageController = StorageController()","        ","        if isWin {","            if flip.tokenIdentifier.isEGLD {","                flip.playerAddress","                    .send(egldValue: profitIfWin)","            } else {","                flip.playerAddress","                    .send(","                        tokenIdentifier: flip.tokenIdentifier,","                        nonce: flip.tokenNonce,","                        amount: profitIfWin","                    )","            }","        } else {","            storageController.getTokenReserve(","                tokenIdentifier: flip.tokenIdentifier,","                tokenNonce: flip.tokenNonce","            )","            .update { $0 = $0 + profitIfWin }","        }","        ","        storageController.$flipForId[flip.id].clear()","    }","}"],"syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-Failure-Cases-for-the-flip-Endpoint":{"url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-Failure-Cases-for-the-flip-Endpoint","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Cases-for-the-flip-Endpoint","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"code":"GameController","type":"codeVoice"},{"text":".","type":"text"}],"kind":"section","title":"Test Failure Cases for the flip Endpoint","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage#Define-the-Flip-Structure":{"abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}],"url":"\/tutorials\/spacekit\/flipcontractwritethestorage#Define-the-Flip-Structure","role":"pseudoSymbol","title":"Define the Flip Structure","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Flip-Structure"},"FlipContractWriteTheGameSection2Step4.swift":{"identifier":"FlipContractWriteTheGameSection2Step4.swift","fileName":"GameController.swift","syntax":"swift","type":"file","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","    }","}"],"highlights":[{"line":88}],"fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Set-the-Minimum-Block-Bounty-Delay":{"url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Set-the-Minimum-Block-Bounty-Delay","role":"pseudoSymbol","kind":"section","title":"Set the Minimum Block Bounty Delay","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Set-the-Minimum-Block-Bounty-Delay","type":"section","abstract":[{"text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract","kind":"project","estimatedTime":"20min","type":"topic","role":"project","title":"Building Your First Smart Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract","abstract":[{"text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-the-bounty-Endpoint":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-the-bounty-Endpoint","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"text":".","type":"text"}],"role":"pseudoSymbol","title":"Test the bounty Endpoint","kind":"section","url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-the-bounty-Endpoint","type":"section"},"FlipContractWriteTheGameSection3Step11.swift":{"type":"file","fileName":"GameController.swift","fileType":"swift","highlights":[{"line":106},{"line":107},{"line":108},{"line":109}],"identifier":"FlipContractWriteTheGameSection3Step11.swift","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    public func bounty() {","        let caller = Message.caller","        ","        require(","            !caller.isSmartContract,","            \"This endpoint cannot be called by a smart contract.\"","        )","        ","        var storageController = StorageController()","        ","        let lastBountyFlipId = storageController.lastBountyFlipId","        let lastFlipId = storageController.lastFlipId","        ","        require(","            lastBountyFlipId < lastFlipId,","            \"No flip to bounty.\"","        )","        ","        let currentBlockNonce = Blockchain.getBlockNonce()","        var bountyFlipId = lastBountyFlipId","        ","        while bountyFlipId < lastFlipId {","            let flipId = bountyFlipId + 1","            ","            if storageController.$flipForId[flipId].isEmpty() {","                break","            }","        }","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","        ","        bountyAddress.send(","            tokenIdentifier: flip.tokenIdentifier,","            nonce: flip.tokenNonce,","            amount: flip.bounty","        )","        ","        let profitIfWin = flip.amount * 2","        ","        let storageController = StorageController()","        ","        if isWin {","            if flip.tokenIdentifier.isEGLD {","                flip.playerAddress","                    .send(egldValue: profitIfWin)","            } else {","                flip.playerAddress","                    .send(","                        tokenIdentifier: flip.tokenIdentifier,","                        nonce: flip.tokenNonce,","                        amount: profitIfWin","                    )","            }","        } else {","            storageController.getTokenReserve(","                tokenIdentifier: flip.tokenIdentifier,","                tokenNonce: flip.tokenNonce","            )","            .update { $0 = $0 + profitIfWin }","        }","        ","        storageController.$flipForId[flip.id].clear()","    }","}"],"syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls":{"title":"Interacting with Contracts Across Shards","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"kind":"project","role":"project","estimatedTime":"15min","type":"topic","url":"\/tutorials\/spacekit\/asynccalls"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract":{"title":"Issuing a Semi-Fungible Token from Your Contract","type":"section","role":"pseudoSymbol","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"text":" ","type":"text"},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract"},"FlipContractWriteTheGameSection1Step5.swift":{"fileType":"swift","identifier":"FlipContractWriteTheGameSection1Step5.swift","fileName":"GameController.swift","highlights":[{"line":6},{"line":7}],"type":"file","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","    }","}"],"syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-Failure-Case-for-the-bounty-Endpoint":{"url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-Failure-Case-for-the-bounty-Endpoint","role":"pseudoSymbol","kind":"section","title":"Test Failure Case for the bounty Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Failure-Case-for-the-bounty-Endpoint","type":"section","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"text":".","type":"text"}]},"FlipContractWriteTheGameSection3Step2.swift":{"type":"file","fileName":"GameController.swift","fileType":"swift","highlights":[{"line":83},{"line":84},{"line":85}],"identifier":"FlipContractWriteTheGameSection3Step2.swift","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    public func bounty() {","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","        ","        bountyAddress.send(","            tokenIdentifier: flip.tokenIdentifier,","            nonce: flip.tokenNonce,","            amount: flip.bounty","        )","        ","        let profitIfWin = flip.amount * 2","        ","        let storageController = StorageController()","        ","        if isWin {","            if flip.tokenIdentifier.isEGLD {","                flip.playerAddress","                    .send(egldValue: profitIfWin)","            } else {","                flip.playerAddress","                    .send(","                        tokenIdentifier: flip.tokenIdentifier,","                        nonce: flip.tokenNonce,","                        amount: profitIfWin","                    )","            }","        } else {","            storageController.getTokenReserve(","                tokenIdentifier: flip.tokenIdentifier,","                tokenNonce: flip.tokenNonce","            )","            .update { $0 = $0 + profitIfWin }","        }","        ","        storageController.$flipForId[flip.id].clear()","    }","}"],"syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Test-the-Admin-Endpoints":{"type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Admin-Endpoints","role":"article","abstract":[],"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/test-the-admin-endpoints","kind":"article","title":"Test the Admin Endpoints"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Persisting-Data-Across-Executions":{"title":"Persisting Data Across Executions","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","type":"topic","abstract":[],"kind":"article","role":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/persisting-data-across-executions"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Create-a-New-Nonce":{"abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"role":"pseudoSymbol","kind":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Create-a-New-Nonce","type":"section","title":"Create a New Nonce","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce"},"FlipContractWriteTheGameSection3Step17.swift":{"identifier":"FlipContractWriteTheGameSection3Step17.swift","fileName":"GameController.swift","syntax":"swift","type":"file","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    public func bounty() {","        let caller = Message.caller","        ","        require(","            !caller.isSmartContract,","            \"This endpoint cannot be called by a smart contract.\"","        )","        ","        var storageController = StorageController()","        ","        let lastBountyFlipId = storageController.lastBountyFlipId","        let lastFlipId = storageController.lastFlipId","        ","        require(","            lastBountyFlipId < lastFlipId,","            \"No flip to bounty.\"","        )","        ","        let currentBlockNonce = Blockchain.getBlockNonce()","        var bountyFlipId = lastBountyFlipId","        ","        while bountyFlipId < lastFlipId {","            let flipId = bountyFlipId + 1","            ","            if storageController.$flipForId[flipId].isEmpty() {","                break","            }","            ","            let flip = storageController.flipForId[flipId]","            ","            if currentBlockNonce < flip.blockNonce + flip.minimumBlockBounty {","                break","            }","            ","            self.makeFlip(","                bountyAddress: caller,","                flip: flip","            )","            ","            bountyFlipId = flipId","        }","        ","        require(","            bountyFlipId != lastBountyFlipId,","            \"No flip can be bounty.\"","        )","        ","        storageController.lastBountyFlipId = bountyFlipId","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","        ","        bountyAddress.send(","            tokenIdentifier: flip.tokenIdentifier,","            nonce: flip.tokenNonce,","            amount: flip.bounty","        )","        ","        let profitIfWin = flip.amount * 2","        ","        let storageController = StorageController()","        ","        if isWin {","            if flip.tokenIdentifier.isEGLD {","                flip.playerAddress","                    .send(egldValue: profitIfWin)","            } else {","                flip.playerAddress","                    .send(","                        tokenIdentifier: flip.tokenIdentifier,","                        nonce: flip.tokenNonce,","                        amount: profitIfWin","                    )","            }","        } else {","            storageController.getTokenReserve(","                tokenIdentifier: flip.tokenIdentifier,","                tokenNonce: flip.tokenNonce","            )","            .update { $0 = $0 + profitIfWin }","        }","        ","        storageController.$flipForId[flip.id].clear()","    }","}"],"highlights":[{"line":129},{"line":130}],"fileType":"swift"},"FlipContractWriteTheGameSection2Step2.swift":{"content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","    }","}"],"fileName":"GameController.swift","identifier":"FlipContractWriteTheGameSection2Step2.swift","syntax":"swift","fileType":"swift","highlights":[{"line":82},{"line":83},{"line":84},{"line":85},{"line":86},{"line":87}],"type":"file"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles":{"abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Assign-Mint-and-Burn-Roles","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","kind":"section","type":"section","title":"Assign Mint and Burn Roles"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","url":"\/tutorials\/spacekit\/storevalues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","role":"pseudoSymbol","type":"section","kind":"section","abstract":[{"text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory.","type":"text"}],"title":"Leveraging @Mapping for Dynamic Key-Value Storage"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","url":"\/tutorials\/spacekit\/tokenattributes","role":"project","type":"topic","kind":"project","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"estimatedTime":"15min","title":"Enhance Your Contracts with Token Attributes"},"FlipContractWriteTheGameSection1Step1.swift":{"type":"file","syntax":"swift","fileName":"GameController.swift","fileType":"swift","identifier":"FlipContractWriteTheGameSection1Step1.swift","highlights":[],"content":[""]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens":{"estimatedTime":"15min","type":"topic","title":"Managing Non-Fungible Tokens","role":"project","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame","title":"Test the Game Logic for the Flip Contract","kind":"project","estimatedTime":"20min","url":"\/tutorials\/spacekit\/flipcontracttestthegame","abstract":[{"type":"text","text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the "},{"type":"codeVoice","code":"GameController"},{"type":"text","text":"."}],"type":"topic","role":"project"},"FlipContractWriteTheGameSection1Step2.swift":{"content":["import SpaceKit"],"identifier":"FlipContractWriteTheGameSection1Step2.swift","type":"file","highlights":[{"line":1}],"fileName":"GameController.swift","syntax":"swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Perform-a-Synchronous-Call":{"kind":"section","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/synccalls#Perform-a-Synchronous-Call","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","title":"Perform a Synchronous Call"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Implement-the-Game-Logic-for-the-Flip-Contract":{"title":"Implement the Game Logic for the Flip Contract","role":"article","kind":"article","abstract":[],"type":"topic","url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/implement-the-game-logic-for-the-flip-contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Implement-the-Game-Logic-for-the-Flip-Contract"},"FlipContractWriteTheGameSection1Step11.swift":{"fileType":"swift","highlights":[{"line":36},{"line":37}],"syntax":"swift","type":"file","identifier":"FlipContractWriteTheGameSection1Step11.swift","fileName":"GameController.swift","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","    }","}"]},"FlipContractWriteTheGameSection2Step6.swift":{"fileName":"GameController.swift","highlights":[{"line":95},{"line":96}],"fileType":"swift","type":"file","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","        ","        bountyAddress.send(","            tokenIdentifier: flip.tokenIdentifier,","            nonce: flip.tokenNonce,","            amount: flip.bounty","        )","        ","        let profitIfWin = flip.amount * 2","    }","}"],"syntax":"swift","identifier":"FlipContractWriteTheGameSection2Step6.swift"},"FlipContractWriteTheGameSection1Step4.swift":{"content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","}"],"fileType":"swift","syntax":"swift","identifier":"FlipContractWriteTheGameSection1Step4.swift","fileName":"GameController.swift","type":"file","highlights":[{"line":4},{"line":5},{"line":6}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractIntro#Set-Up-the-Project":{"url":"\/tutorials\/spacekit\/flipcontractintro#Set-Up-the-Project","kind":"section","type":"section","role":"pseudoSymbol","title":"Set Up the Project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro#Set-Up-the-Project","abstract":[{"type":"text","text":"In this tutorial, you’ll write and test a complete smart contract that relies on random number generation to implement a coin flip mechanic. Players wager a chosen amount of any token and face a 50% chance of doubling their bet—or losing it. A small fee is deducted from each wager and sent to the developer’s wallet."}]},"FlipContractWriteTheGameSection2Step3.swift":{"identifier":"FlipContractWriteTheGameSection2Step3.swift","fileType":"swift","highlights":[{"line":87}],"syntax":"swift","fileName":"GameController.swift","type":"file","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","    }","}"]},"FlipContractWriteTheGameSection3Step12.swift":{"content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    public func bounty() {","        let caller = Message.caller","        ","        require(","            !caller.isSmartContract,","            \"This endpoint cannot be called by a smart contract.\"","        )","        ","        var storageController = StorageController()","        ","        let lastBountyFlipId = storageController.lastBountyFlipId","        let lastFlipId = storageController.lastFlipId","        ","        require(","            lastBountyFlipId < lastFlipId,","            \"No flip to bounty.\"","        )","        ","        let currentBlockNonce = Blockchain.getBlockNonce()","        var bountyFlipId = lastBountyFlipId","        ","        while bountyFlipId < lastFlipId {","            let flipId = bountyFlipId + 1","            ","            if storageController.$flipForId[flipId].isEmpty() {","                break","            }","            ","            let flip = storageController.flipForId[flipId]","        }","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","        ","        bountyAddress.send(","            tokenIdentifier: flip.tokenIdentifier,","            nonce: flip.tokenNonce,","            amount: flip.bounty","        )","        ","        let profitIfWin = flip.amount * 2","        ","        let storageController = StorageController()","        ","        if isWin {","            if flip.tokenIdentifier.isEGLD {","                flip.playerAddress","                    .send(egldValue: profitIfWin)","            } else {","                flip.playerAddress","                    .send(","                        tokenIdentifier: flip.tokenIdentifier,","                        nonce: flip.tokenNonce,","                        amount: profitIfWin","                    )","            }","        } else {","            storageController.getTokenReserve(","                tokenIdentifier: flip.tokenIdentifier,","                tokenNonce: flip.tokenNonce","            )","            .update { $0 = $0 + profitIfWin }","        }","        ","        storageController.$flipForId[flip.id].clear()","    }","}"],"identifier":"FlipContractWriteTheGameSection3Step12.swift","syntax":"swift","fileName":"GameController.swift","highlights":[{"line":110},{"line":111}],"fileType":"swift","type":"file"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Understanding-the-Buffer-Type":{"title":"Understanding the Buffer Type","role":"pseudoSymbol","kind":"section","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Understanding-the-Buffer-Type","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract":{"title":"Issuing a Non-Fungible Token from Your Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","type":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"kind":"section","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Non-Fungible-Token-from-Your-Contract"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin":{"estimatedTime":"20min","url":"\/tutorials\/spacekit\/flipcontractwriteadmin","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin","type":"topic","kind":"project","title":"Add Administrative Endpoints to the Flip Contract","role":"project","abstract":[{"text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets.","type":"text"}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage":{"title":"Define the Storage for the Flip Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage","abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}],"kind":"project","role":"project","estimatedTime":"20min","type":"topic","url":"\/tutorials\/spacekit\/flipcontractwritethestorage"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Burn-Tokens":{"title":"Burn Tokens","role":"pseudoSymbol","kind":"section","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Burn-Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage#Define-the-Contract-Init":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Define-the-Contract-Init","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/flipcontractwritethestorage#Define-the-Contract-Init","abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}],"title":"Define the Contract Init","type":"section","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Exploring-SpaceKit's-Types":{"abstract":[],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","title":"Exploring SpaceKit's Types","type":"topic","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/exploring-spacekit's-types","kind":"article","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteAdmin#Increase-Contract-Reserves":{"url":"\/tutorials\/spacekit\/flipcontractwriteadmin#Increase-Contract-Reserves","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteAdmin#Increase-Contract-Reserves","kind":"section","abstract":[{"type":"text","text":"Now that your storage is fully set up, it’s time to define the administrative endpoints that allow the contract owner to manage critical values and assets."}],"role":"pseudoSymbol","title":"Increase Contract Reserves"},"FlipContractWriteTheGameSection2Step10.swift":{"identifier":"FlipContractWriteTheGameSection2Step10.swift","syntax":"swift","fileName":"GameController.swift","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","        ","        bountyAddress.send(","            tokenIdentifier: flip.tokenIdentifier,","            nonce: flip.tokenNonce,","            amount: flip.bounty","        )","        ","        let profitIfWin = flip.amount * 2","        ","        let storageController = StorageController()","        ","        if isWin {","            if flip.tokenIdentifier.isEGLD {","                flip.playerAddress","                    .send(egldValue: profitIfWin)","            } else {","                flip.playerAddress","                    .send(","                        tokenIdentifier: flip.tokenIdentifier,","                        nonce: flip.tokenNonce,","                        amount: profitIfWin","                    )","            }","        } else {","            storageController.getTokenReserve(","                tokenIdentifier: flip.tokenIdentifier,","                tokenNonce: flip.tokenNonce","            )","            .update { $0 = $0 + profitIfWin }","        }","    }","}"],"type":"file","fileType":"swift","highlights":[{"line":113},{"line":114},{"line":115},{"line":116},{"line":117}]},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Non-Fungible-Tokens":{"url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-non-fungible-tokens","kind":"article","type":"topic","role":"article","title":"Managing Non-Fungible Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","abstract":[]},"FlipContractWriteTheGameSection3Step4.swift":{"fileName":"GameController.swift","type":"file","highlights":[{"line":85},{"line":86},{"line":87},{"line":88},{"line":89}],"content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    public func bounty() {","        let caller = Message.caller","        ","        require(","            !caller.isSmartContract,","            \"This endpoint cannot be called by a smart contract.\"","        )","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","        ","        bountyAddress.send(","            tokenIdentifier: flip.tokenIdentifier,","            nonce: flip.tokenNonce,","            amount: flip.bounty","        )","        ","        let profitIfWin = flip.amount * 2","        ","        let storageController = StorageController()","        ","        if isWin {","            if flip.tokenIdentifier.isEGLD {","                flip.playerAddress","                    .send(egldValue: profitIfWin)","            } else {","                flip.playerAddress","                    .send(","                        tokenIdentifier: flip.tokenIdentifier,","                        nonce: flip.tokenNonce,","                        amount: profitIfWin","                    )","            }","        } else {","            storageController.getTokenReserve(","                tokenIdentifier: flip.tokenIdentifier,","                tokenNonce: flip.tokenNonce","            )","            .update { $0 = $0 + profitIfWin }","        }","        ","        storageController.$flipForId[flip.id].clear()","    }","}"],"fileType":"swift","identifier":"FlipContractWriteTheGameSection3Step4.swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Setting-Up-the-SpaceKit-CLI":{"url":"\/tutorials\/spacekit\/installingtools#Setting-Up-the-SpaceKit-CLI","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI","kind":"section","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"role":"pseudoSymbol","title":"Setting Up the SpaceKit CLI"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Initializing-the-Project":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Initializing-the-Project","role":"pseudoSymbol","kind":"section","title":"Initializing the Project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","type":"section","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}]},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Working-with-Storage-for-Single-Value-Persistence":{"title":"Working with @Storage for Single Value Persistence","role":"pseudoSymbol","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"kind":"section","url":"\/tutorials\/spacekit\/storevalues#Working-with-Storage-for-Single-Value-Persistence","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence"},"doc://SpaceKit/tutorials/SpaceKit":{"title":"Meet SpaceKit","abstract":[{"type":"text","text":"Discover how SpaceKit simplifies blockchain development using Swift. Dive into the world of Web3 with ease and efficiency."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","url":"\/tutorials\/spacekit","role":"overview","kind":"overview","type":"topic"},"FlipContractWriteTheGameSection3Step16.swift":{"fileType":"swift","type":"file","fileName":"GameController.swift","identifier":"FlipContractWriteTheGameSection3Step16.swift","syntax":"swift","highlights":[{"line":124},{"line":125},{"line":126},{"line":127},{"line":128}],"content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    public func bounty() {","        let caller = Message.caller","        ","        require(","            !caller.isSmartContract,","            \"This endpoint cannot be called by a smart contract.\"","        )","        ","        var storageController = StorageController()","        ","        let lastBountyFlipId = storageController.lastBountyFlipId","        let lastFlipId = storageController.lastFlipId","        ","        require(","            lastBountyFlipId < lastFlipId,","            \"No flip to bounty.\"","        )","        ","        let currentBlockNonce = Blockchain.getBlockNonce()","        var bountyFlipId = lastBountyFlipId","        ","        while bountyFlipId < lastFlipId {","            let flipId = bountyFlipId + 1","            ","            if storageController.$flipForId[flipId].isEmpty() {","                break","            }","            ","            let flip = storageController.flipForId[flipId]","            ","            if currentBlockNonce < flip.blockNonce + flip.minimumBlockBounty {","                break","            }","            ","            self.makeFlip(","                bountyAddress: caller,","                flip: flip","            )","            ","            bountyFlipId = flipId","        }","        ","        require(","            bountyFlipId != lastBountyFlipId,","            \"No flip can be bounty.\"","        )","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","        ","        bountyAddress.send(","            tokenIdentifier: flip.tokenIdentifier,","            nonce: flip.tokenNonce,","            amount: flip.bounty","        )","        ","        let profitIfWin = flip.amount * 2","        ","        let storageController = StorageController()","        ","        if isWin {","            if flip.tokenIdentifier.isEGLD {","                flip.playerAddress","                    .send(egldValue: profitIfWin)","            } else {","                flip.playerAddress","                    .send(","                        tokenIdentifier: flip.tokenIdentifier,","                        nonce: flip.tokenNonce,","                        amount: profitIfWin","                    )","            }","        } else {","            storageController.getTokenReserve(","                tokenIdentifier: flip.tokenIdentifier,","                tokenNonce: flip.tokenNonce","            )","            .update { $0 = $0 + profitIfWin }","        }","        ","        storageController.$flipForId[flip.id].clear()","    }","}"]},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Installing-SpaceKits-Dependencies":{"url":"\/tutorials\/spacekit\/installingtools#Installing-SpaceKits-Dependencies","role":"pseudoSymbol","kind":"section","title":"Installing SpaceKit's Dependencies","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","type":"section","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Burn-Tokens":{"url":"\/tutorials\/spacekit\/operationsonfungibletokens#Burn-Tokens","kind":"section","type":"section","role":"pseudoSymbol","title":"Burn Tokens","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","abstract":[{"text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with.","type":"text"}]},"FlipContractWriteTheGameSection3Step15.swift":{"fileType":"swift","identifier":"FlipContractWriteTheGameSection3Step15.swift","syntax":"swift","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    public func bounty() {","        let caller = Message.caller","        ","        require(","            !caller.isSmartContract,","            \"This endpoint cannot be called by a smart contract.\"","        )","        ","        var storageController = StorageController()","        ","        let lastBountyFlipId = storageController.lastBountyFlipId","        let lastFlipId = storageController.lastFlipId","        ","        require(","            lastBountyFlipId < lastFlipId,","            \"No flip to bounty.\"","        )","        ","        let currentBlockNonce = Blockchain.getBlockNonce()","        var bountyFlipId = lastBountyFlipId","        ","        while bountyFlipId < lastFlipId {","            let flipId = bountyFlipId + 1","            ","            if storageController.$flipForId[flipId].isEmpty() {","                break","            }","            ","            let flip = storageController.flipForId[flipId]","            ","            if currentBlockNonce < flip.blockNonce + flip.minimumBlockBounty {","                break","            }","            ","            self.makeFlip(","                bountyAddress: caller,","                flip: flip","            )","            ","            bountyFlipId = flipId","        }","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","        ","        bountyAddress.send(","            tokenIdentifier: flip.tokenIdentifier,","            nonce: flip.tokenNonce,","            amount: flip.bounty","        )","        ","        let profitIfWin = flip.amount * 2","        ","        let storageController = StorageController()","        ","        if isWin {","            if flip.tokenIdentifier.isEGLD {","                flip.playerAddress","                    .send(egldValue: profitIfWin)","            } else {","                flip.playerAddress","                    .send(","                        tokenIdentifier: flip.tokenIdentifier,","                        nonce: flip.tokenNonce,","                        amount: profitIfWin","                    )","            }","        } else {","            storageController.getTokenReserve(","                tokenIdentifier: flip.tokenIdentifier,","                tokenNonce: flip.tokenNonce","            )","            .update { $0 = $0 + profitIfWin }","        }","        ","        storageController.$flipForId[flip.id].clear()","    }","}"],"fileName":"GameController.swift","type":"file","highlights":[{"line":121},{"line":122}]},"FlipContractWriteTheGameSection2Step11.swift":{"fileType":"swift","type":"file","fileName":"GameController.swift","identifier":"FlipContractWriteTheGameSection2Step11.swift","syntax":"swift","highlights":[],"content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","        ","        bountyAddress.send(","            tokenIdentifier: flip.tokenIdentifier,","            nonce: flip.tokenNonce,","            amount: flip.bounty","        )","        ","        let profitIfWin = flip.amount * 2","        ","        let storageController = StorageController()","        ","        if isWin {","            if flip.tokenIdentifier.isEGLD {","                flip.playerAddress","                    .send(egldValue: profitIfWin)","            } else {","                flip.playerAddress","                    .send(","                        tokenIdentifier: flip.tokenIdentifier,","                        nonce: flip.tokenNonce,","                        amount: profitIfWin","                    )","            }","        } else {","            storageController.getTokenReserve(","                tokenIdentifier: flip.tokenIdentifier,","                tokenNonce: flip.tokenNonce","            )","            .update { $0 = $0 + profitIfWin }","        }","        ","        storageController.$flipForId[flip.id].clear()","    }","}"]},"FlipContractWriteTheGameSection1Step15.swift":{"fileType":"swift","identifier":"FlipContractWriteTheGameSection1Step15.swift","syntax":"swift","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","    }","}"],"fileName":"GameController.swift","type":"file","highlights":[{"line":46},{"line":47},{"line":48}]},"FlipContractWriteTheGameSection2Step8.swift":{"fileType":"swift","type":"file","fileName":"GameController.swift","identifier":"FlipContractWriteTheGameSection2Step8.swift","syntax":"swift","highlights":[{"line":99},{"line":100},{"line":101},{"line":102},{"line":103},{"line":104}],"content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","        ","        bountyAddress.send(","            tokenIdentifier: flip.tokenIdentifier,","            nonce: flip.tokenNonce,","            amount: flip.bounty","        )","        ","        let profitIfWin = flip.amount * 2","        ","        let storageController = StorageController()","        ","        if isWin {","            \/\/ Will be filled in a later step","        } else {","            \/\/ Will be filled in a later step","        }","    }","}"]},"FlipContractWriteTheGameSection2Step5.swift":{"fileType":"swift","identifier":"FlipContractWriteTheGameSection2Step5.swift","syntax":"swift","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","        ","        bountyAddress.send(","            tokenIdentifier: flip.tokenIdentifier,","            nonce: flip.tokenNonce,","            amount: flip.bounty","        )","    }","}"],"fileName":"GameController.swift","type":"file","highlights":[{"line":89},{"line":90},{"line":91},{"line":92},{"line":93},{"line":94}]},"FlipContractWriteTheGameSection1Step17.swift":{"fileType":"swift","type":"file","fileName":"GameController.swift","identifier":"FlipContractWriteTheGameSection1Step17.swift","syntax":"swift","highlights":[{"line":60},{"line":61},{"line":62},{"line":63},{"line":64},{"line":65}],"content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","    }","}"]},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Installing-the-Tools":{"abstract":[],"role":"article","kind":"article","url":"\/tutorials\/spacekit\/getting-started\/installing-the-tools","type":"topic","title":"Installing the Tools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin":{"title":"Test the Admin Endpoints","type":"topic","role":"project","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}],"kind":"project","estimatedTime":"20min","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin","url":"\/tutorials\/spacekit\/flipcontracttestadmin"},"FlipContractWriteTheGameSection1Step6.swift":{"fileType":"swift","identifier":"FlipContractWriteTheGameSection1Step6.swift","syntax":"swift","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","    }","}"],"fileName":"GameController.swift","type":"file","highlights":[{"line":7}]},"FlipContractWriteTheGameSection1Step8.swift":{"content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","    }","}"],"highlights":[{"line":10},{"line":11},{"line":12},{"line":13},{"line":14},{"line":15},{"line":16},{"line":17},{"line":18},{"line":19},{"line":20},{"line":21},{"line":22},{"line":23},{"line":24},{"line":25},{"line":26},{"line":27},{"line":28},{"line":29},{"line":30}],"identifier":"FlipContractWriteTheGameSection1Step8.swift","syntax":"swift","type":"file","fileType":"swift","fileName":"GameController.swift"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Fungible-Tokens":{"url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-fungible-tokens","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens","kind":"article","abstract":[],"role":"article","title":"Managing Fungible Tokens"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Declare-Constants-for-the-Test-Environment":{"title":"Declare Constants for the Test Environment","role":"pseudoSymbol","kind":"section","abstract":[{"text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/flipcontractinittests#Declare-Constants-for-the-Test-Environment","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Declare-Constants-for-the-Test-Environment"},"FlipContractWriteTheGameSection3Step9.swift":{"fileType":"swift","identifier":"FlipContractWriteTheGameSection3Step9.swift","syntax":"swift","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    public func bounty() {","        let caller = Message.caller","        ","        require(","            !caller.isSmartContract,","            \"This endpoint cannot be called by a smart contract.\"","        )","        ","        var storageController = StorageController()","        ","        let lastBountyFlipId = storageController.lastBountyFlipId","        let lastFlipId = storageController.lastFlipId","        ","        require(","            lastBountyFlipId < lastFlipId,","            \"No flip to bounty.\"","        )","        ","        let currentBlockNonce = Blockchain.getBlockNonce()","        var bountyFlipId = lastBountyFlipId","        ","        while bountyFlipId < lastFlipId {","        }","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","        ","        bountyAddress.send(","            tokenIdentifier: flip.tokenIdentifier,","            nonce: flip.tokenNonce,","            amount: flip.bounty","        )","        ","        let profitIfWin = flip.amount * 2","        ","        let storageController = StorageController()","        ","        if isWin {","            if flip.tokenIdentifier.isEGLD {","                flip.playerAddress","                    .send(egldValue: profitIfWin)","            } else {","                flip.playerAddress","                    .send(","                        tokenIdentifier: flip.tokenIdentifier,","                        nonce: flip.tokenNonce,","                        amount: profitIfWin","                    )","            }","        } else {","            storageController.getTokenReserve(","                tokenIdentifier: flip.tokenIdentifier,","                tokenNonce: flip.tokenNonce","            )","            .update { $0 = $0 + profitIfWin }","        }","        ","        storageController.$flipForId[flip.id].clear()","    }","}"],"fileName":"GameController.swift","type":"file","highlights":[{"line":103},{"line":104},{"line":105}]},"FlipContractWriteTheGameSection1Step16.swift":{"identifier":"FlipContractWriteTheGameSection1Step16.swift","fileName":"GameController.swift","syntax":"swift","type":"file","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","    }","}"],"highlights":[{"line":49},{"line":50},{"line":51},{"line":52},{"line":53},{"line":54},{"line":55},{"line":56},{"line":57},{"line":58},{"line":59}],"fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues":{"abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"role":"project","estimatedTime":"15min","kind":"project","url":"\/tutorials\/spacekit\/storevalues","type":"topic","title":"Persist Values Between Executions","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Interacting-with-Other-Contracts":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","title":"Interacting with Other Contracts","kind":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/interacting-with-other-contracts","abstract":[],"type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Test-the-increaseReserve-Endpoint":{"kind":"section","abstract":[{"text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves.","type":"text"}],"type":"section","url":"\/tutorials\/spacekit\/flipcontracttestadmin#Test-the-increaseReserve-Endpoint","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-increaseReserve-Endpoint","title":"Test the increaseReserve Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-lockFunds-Endpoint":{"url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-lockFunds-Endpoint","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint","kind":"section","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"role":"pseudoSymbol","title":"Implementing the lockFunds Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-BigUint-Type":{"url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-BigUint-Type","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","kind":"section","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"role":"pseudoSymbol","title":"Working with the BigUint Type"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-Vector-Type":{"url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-Vector-Type","type":"section","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"title":"Working with the Vector Type","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Mint-New-Tokens":{"url":"\/tutorials\/spacekit\/operationsonfungibletokens#Mint-New-Tokens","role":"pseudoSymbol","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","type":"section","title":"Mint New Tokens","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Creating-Your-Own-Types":{"title":"Creating Your Own Types","role":"pseudoSymbol","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"kind":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Creating-Your-Own-Types","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Test-the-Game-Logic-for-the-Flip-Contract":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/test-the-game-logic-for-the-flip-contract","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Test-the-Game-Logic-for-the-Flip-Contract","kind":"article","abstract":[],"role":"article","title":"Test the Game Logic for the Flip Contract"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Test-the-withdrawReserve-Endpoint":{"type":"section","kind":"section","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}],"title":"Test the withdrawReserve Endpoint","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/flipcontracttestadmin#Test-the-withdrawReserve-Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Test-the-withdrawReserve-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract":{"type":"section","kind":"section","url":"\/tutorials\/spacekit\/installingtools#Initializing-and-Compiling-Your-First-Smart-Contract","abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"title":"Initializing and Compiling Your First Smart Contract","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract"},"FlipContractWriteTheGameSection3Step13.swift":{"syntax":"swift","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    public func bounty() {","        let caller = Message.caller","        ","        require(","            !caller.isSmartContract,","            \"This endpoint cannot be called by a smart contract.\"","        )","        ","        var storageController = StorageController()","        ","        let lastBountyFlipId = storageController.lastBountyFlipId","        let lastFlipId = storageController.lastFlipId","        ","        require(","            lastBountyFlipId < lastFlipId,","            \"No flip to bounty.\"","        )","        ","        let currentBlockNonce = Blockchain.getBlockNonce()","        var bountyFlipId = lastBountyFlipId","        ","        while bountyFlipId < lastFlipId {","            let flipId = bountyFlipId + 1","            ","            if storageController.$flipForId[flipId].isEmpty() {","                break","            }","            ","            let flip = storageController.flipForId[flipId]","            ","            if currentBlockNonce < flip.blockNonce + flip.minimumBlockBounty {","                break","            }","        }","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","        ","        bountyAddress.send(","            tokenIdentifier: flip.tokenIdentifier,","            nonce: flip.tokenNonce,","            amount: flip.bounty","        )","        ","        let profitIfWin = flip.amount * 2","        ","        let storageController = StorageController()","        ","        if isWin {","            if flip.tokenIdentifier.isEGLD {","                flip.playerAddress","                    .send(egldValue: profitIfWin)","            } else {","                flip.playerAddress","                    .send(","                        tokenIdentifier: flip.tokenIdentifier,","                        nonce: flip.tokenNonce,","                        amount: profitIfWin","                    )","            }","        } else {","            storageController.getTokenReserve(","                tokenIdentifier: flip.tokenIdentifier,","                tokenNonce: flip.tokenNonce","            )","            .update { $0 = $0 + profitIfWin }","        }","        ","        storageController.$flipForId[flip.id].clear()","    }","}"],"identifier":"FlipContractWriteTheGameSection3Step13.swift","fileName":"GameController.swift","highlights":[{"line":112},{"line":113},{"line":114},{"line":115}],"type":"file","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Set-Up-the-Test-Project":{"title":"Set Up the Test Project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Set-Up-the-Test-Project","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}],"url":"\/tutorials\/spacekit\/flipcontractinittests#Set-Up-the-Test-Project","type":"section","kind":"section","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame","estimatedTime":"20min","abstract":[{"type":"text","text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics."}],"role":"project","title":"Implement the Game Logic for the Flip Contract","kind":"project","url":"\/tutorials\/spacekit\/flipcontractwritethegame","type":"topic"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheStorage#Implement-Contract-Storage":{"url":"\/tutorials\/spacekit\/flipcontractwritethestorage#Implement-Contract-Storage","kind":"section","type":"section","role":"pseudoSymbol","title":"Implement Contract Storage","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheStorage#Implement-Contract-Storage","abstract":[{"type":"text","text":"With your Flip project initialized, you’re ready to begin implementing the smart contract. The contract is composed of the following components:"}]},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls":{"title":"Interact with Other Contracts","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls","abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}],"kind":"project","role":"project","estimatedTime":"15min","type":"topic","url":"\/tutorials\/spacekit\/synccalls"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools":{"title":"Install the Necessary Tools","estimatedTime":"10min","url":"\/tutorials\/spacekit\/installingtools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"role":"project","kind":"project","type":"topic"},"FlipContractWriteTheGameSection1Step13.swift":{"content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","    }","}"],"highlights":[{"line":39},{"line":40}],"fileType":"swift","fileName":"GameController.swift","syntax":"swift","identifier":"FlipContractWriteTheGameSection1Step13.swift","type":"file"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints":{"url":"\/tutorials\/spacekit\/flipcontracttestadmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints","kind":"section","type":"section","role":"pseudoSymbol","title":"Verify That Only the Owner Can Access Admin Endpoints","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-That-Only-the-Owner-Can-Access-Admin-Endpoints","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}]},"FlipContractWriteTheGameSection1Step14.swift":{"fileName":"GameController.swift","type":"file","fileType":"swift","highlights":[{"line":41},{"line":42},{"line":43},{"line":44},{"line":45}],"identifier":"FlipContractWriteTheGameSection1Step14.swift","syntax":"swift","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","    }","}"]},"FlipContractWriteTheGameSection1Step9.swift":{"fileName":"GameController.swift","identifier":"FlipContractWriteTheGameSection1Step9.swift","fileType":"swift","syntax":"swift","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","    }","}"],"type":"file","highlights":[{"line":31},{"line":32},{"line":33},{"line":34}]},"FlipContractWriteTheGameSection2Step7.swift":{"fileName":"GameController.swift","syntax":"swift","identifier":"FlipContractWriteTheGameSection2Step7.swift","fileType":"swift","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","        ","        bountyAddress.send(","            tokenIdentifier: flip.tokenIdentifier,","            nonce: flip.tokenNonce,","            amount: flip.bounty","        )","        ","        let profitIfWin = flip.amount * 2","        ","        let storageController = StorageController()","    }","}"],"highlights":[{"line":97},{"line":98}],"type":"file"},"FlipContractWriteTheGameSection2Step9.swift":{"fileName":"GameController.swift","identifier":"FlipContractWriteTheGameSection2Step9.swift","syntax":"swift","fileType":"swift","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","        ","        bountyAddress.send(","            tokenIdentifier: flip.tokenIdentifier,","            nonce: flip.tokenNonce,","            amount: flip.bounty","        )","        ","        let profitIfWin = flip.amount * 2","        ","        let storageController = StorageController()","        ","        if isWin {","            if flip.tokenIdentifier.isEGLD {","                flip.playerAddress","                    .send(egldValue: profitIfWin)","            } else {","                flip.playerAddress","                    .send(","                        tokenIdentifier: flip.tokenIdentifier,","                        nonce: flip.tokenNonce,","                        amount: profitIfWin","                    )","            }","        } else {","            \/\/ Will be filled in a later step","        }","    }","}"],"type":"file","highlights":[{"line":101},{"line":102},{"line":103},{"line":104},{"line":105},{"line":106},{"line":107},{"line":108},{"line":109},{"line":110},{"line":111}]},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Define-the-Storage-for-the-Flip-Contract":{"title":"Define the Storage for the Flip Contract","role":"article","kind":"article","abstract":[],"type":"topic","url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/define-the-storage-for-the-flip-contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Define-the-Storage-for-the-Flip-Contract"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract":{"title":"Issuing a Meta ESDT from Your Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"kind":"section","role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Meta-ESDT-from-Your-Contract"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Transaction-Context-Data":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/getinfo#Accessing-Transaction-Context-Data","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"title":"Accessing Transaction Context Data","type":"section","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestTheGame#Test-Successful-Calls-to-the-flip-Endpoint":{"title":"Test Successful Calls to the flip Endpoint","role":"pseudoSymbol","kind":"section","abstract":[{"text":"This final chapter of the testing tutorial focuses on validating the core game logic implemented in the ","type":"text"},{"type":"codeVoice","code":"GameController"},{"type":"text","text":"."}],"type":"section","url":"\/tutorials\/spacekit\/flipcontracttestthegame#Test-Successful-Calls-to-the-flip-Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestTheGame#Test-Successful-Calls-to-the-flip-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame#Implement-the-flip-Endpoint":{"kind":"section","abstract":[{"type":"text","text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics."}],"type":"section","url":"\/tutorials\/spacekit\/flipcontractwritethegame#Implement-the-flip-Endpoint","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-flip-Endpoint","title":"Implement the flip Endpoint"},"FlipContractWriteTheGameSection3Step10.swift":{"fileName":"GameController.swift","syntax":"swift","identifier":"FlipContractWriteTheGameSection3Step10.swift","fileType":"swift","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    public func bounty() {","        let caller = Message.caller","        ","        require(","            !caller.isSmartContract,","            \"This endpoint cannot be called by a smart contract.\"","        )","        ","        var storageController = StorageController()","        ","        let lastBountyFlipId = storageController.lastBountyFlipId","        let lastFlipId = storageController.lastFlipId","        ","        require(","            lastBountyFlipId < lastFlipId,","            \"No flip to bounty.\"","        )","        ","        let currentBlockNonce = Blockchain.getBlockNonce()","        var bountyFlipId = lastBountyFlipId","        ","        while bountyFlipId < lastFlipId {","            let flipId = bountyFlipId + 1","        }","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","        ","        bountyAddress.send(","            tokenIdentifier: flip.tokenIdentifier,","            nonce: flip.tokenNonce,","            amount: flip.bounty","        )","        ","        let profitIfWin = flip.amount * 2","        ","        let storageController = StorageController()","        ","        if isWin {","            if flip.tokenIdentifier.isEGLD {","                flip.playerAddress","                    .send(egldValue: profitIfWin)","            } else {","                flip.playerAddress","                    .send(","                        tokenIdentifier: flip.tokenIdentifier,","                        nonce: flip.tokenNonce,","                        amount: profitIfWin","                    )","            }","        } else {","            storageController.getTokenReserve(","                tokenIdentifier: flip.tokenIdentifier,","                tokenNonce: flip.tokenNonce","            )","            .update { $0 = $0 + profitIfWin }","        }","        ","        storageController.$flipForId[flip.id].clear()","    }","}"],"highlights":[{"line":105}],"type":"file"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractIntro":{"type":"topic","url":"\/tutorials\/spacekit\/flipcontractintro","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractIntro","estimatedTime":"20min","role":"project","kind":"project","title":"Build a Coin Flip Smart Contract","abstract":[{"text":"In this tutorial, you’ll write and test a complete smart contract that relies on random number generation to implement a coin flip mechanic. Players wager a chosen amount of any token and face a 50% chance of doubling their bet—or losing it. A small fee is deducted from each wager and sent to the developer’s wallet.","type":"text"}]},"FlipContractWriteTheGameSection3Step8.swift":{"fileName":"GameController.swift","identifier":"FlipContractWriteTheGameSection3Step8.swift","syntax":"swift","fileType":"swift","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    public func bounty() {","        let caller = Message.caller","        ","        require(","            !caller.isSmartContract,","            \"This endpoint cannot be called by a smart contract.\"","        )","        ","        var storageController = StorageController()","        ","        let lastBountyFlipId = storageController.lastBountyFlipId","        let lastFlipId = storageController.lastFlipId","        ","        require(","            lastBountyFlipId < lastFlipId,","            \"No flip to bounty.\"","        )","        ","        let currentBlockNonce = Blockchain.getBlockNonce()","        var bountyFlipId = lastBountyFlipId","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","        ","        bountyAddress.send(","            tokenIdentifier: flip.tokenIdentifier,","            nonce: flip.tokenNonce,","            amount: flip.bounty","        )","        ","        let profitIfWin = flip.amount * 2","        ","        let storageController = StorageController()","        ","        if isWin {","            if flip.tokenIdentifier.isEGLD {","                flip.playerAddress","                    .send(egldValue: profitIfWin)","            } else {","                flip.playerAddress","                    .send(","                        tokenIdentifier: flip.tokenIdentifier,","                        nonce: flip.tokenNonce,","                        amount: profitIfWin","                    )","            }","        } else {","            storageController.getTokenReserve(","                tokenIdentifier: flip.tokenIdentifier,","                tokenNonce: flip.tokenNonce","            )","            .update { $0 = $0 + profitIfWin }","        }","        ","        storageController.$flipForId[flip.id].clear()","    }","}"],"type":"file","highlights":[{"line":102}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame#Define-the-bounty-Endpoint":{"abstract":[{"text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics.","type":"text"}],"kind":"section","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Define-the-bounty-Endpoint","type":"section","title":"Define the bounty Endpoint","url":"\/tutorials\/spacekit\/flipcontractwritethegame#Define-the-bounty-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Retrieving-Information-from-the-Blockchain":{"type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","role":"article","abstract":[],"url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/retrieving-information-from-the-blockchain","kind":"article","title":"Retrieving Information from the Blockchain"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Calling-Contracts-Across-Shards":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","title":"Calling Contracts Across Shards","kind":"article","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/calling-contracts-across-shards","abstract":[],"type":"topic","role":"article"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Declare-the-Callee-Proxy":{"url":"\/tutorials\/spacekit\/asynccalls#Declare-the-Callee-Proxy","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"title":"Declare the Callee Proxy","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Blockchain-Context-Data":{"abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"url":"\/tutorials\/spacekit\/getinfo#Accessing-Blockchain-Context-Data","role":"pseudoSymbol","title":"Accessing Blockchain Context Data","kind":"section","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data"},"FlipContractWriteTheGameSection3Step5.swift":{"fileName":"GameController.swift","syntax":"swift","identifier":"FlipContractWriteTheGameSection3Step5.swift","fileType":"swift","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    public func bounty() {","        let caller = Message.caller","        ","        require(","            !caller.isSmartContract,","            \"This endpoint cannot be called by a smart contract.\"","        )","        ","        var storageController = StorageController()","        ","        let lastBountyFlipId = storageController.lastBountyFlipId","        let lastFlipId = storageController.lastFlipId","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","        ","        bountyAddress.send(","            tokenIdentifier: flip.tokenIdentifier,","            nonce: flip.tokenNonce,","            amount: flip.bounty","        )","        ","        let profitIfWin = flip.amount * 2","        ","        let storageController = StorageController()","        ","        if isWin {","            if flip.tokenIdentifier.isEGLD {","                flip.playerAddress","                    .send(egldValue: profitIfWin)","            } else {","                flip.playerAddress","                    .send(","                        tokenIdentifier: flip.tokenIdentifier,","                        nonce: flip.tokenNonce,","                        amount: profitIfWin","                    )","            }","        } else {","            storageController.getTokenReserve(","                tokenIdentifier: flip.tokenIdentifier,","                tokenNonce: flip.tokenNonce","            )","            .update { $0 = $0 + profitIfWin }","        }","        ","        storageController.$flipForId[flip.id].clear()","    }","}"],"highlights":[{"line":90},{"line":91},{"line":92},{"line":93},{"line":94}],"type":"file"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractTestAdmin#Verify-the-Maximum-Bet-Configuration-Endpoints":{"url":"\/tutorials\/spacekit\/flipcontracttestadmin#Verify-the-Maximum-Bet-Configuration-Endpoints","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractTestAdmin#Verify-the-Maximum-Bet-Configuration-Endpoints","kind":"section","abstract":[{"type":"text","text":"Admin endpoints are critical to the contract’s integrity. They not only control configuration parameters, but also grant access to withdraw the contract’s token reserves."}],"role":"pseudoSymbol","title":"Verify the Maximum Bet Configuration Endpoints"},"FlipContractWriteTheGameSection3Step6.swift":{"type":"file","identifier":"FlipContractWriteTheGameSection3Step6.swift","fileName":"GameController.swift","fileType":"swift","highlights":[{"line":95},{"line":96},{"line":97},{"line":98},{"line":99}],"syntax":"swift","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    public func bounty() {","        let caller = Message.caller","        ","        require(","            !caller.isSmartContract,","            \"This endpoint cannot be called by a smart contract.\"","        )","        ","        var storageController = StorageController()","        ","        let lastBountyFlipId = storageController.lastBountyFlipId","        let lastFlipId = storageController.lastFlipId","        ","        require(","            lastBountyFlipId < lastFlipId,","            \"No flip to bounty.\"","        )","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","        ","        bountyAddress.send(","            tokenIdentifier: flip.tokenIdentifier,","            nonce: flip.tokenNonce,","            amount: flip.bounty","        )","        ","        let profitIfWin = flip.amount * 2","        ","        let storageController = StorageController()","        ","        if isWin {","            if flip.tokenIdentifier.isEGLD {","                flip.playerAddress","                    .send(egldValue: profitIfWin)","            } else {","                flip.playerAddress","                    .send(","                        tokenIdentifier: flip.tokenIdentifier,","                        nonce: flip.tokenNonce,","                        amount: profitIfWin","                    )","            }","        } else {","            storageController.getTokenReserve(","                tokenIdentifier: flip.tokenIdentifier,","                tokenNonce: flip.tokenNonce","            )","            .update { $0 = $0 + profitIfWin }","        }","        ","        storageController.$flipForId[flip.id].clear()","    }","}"]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges":{"title":"Handling Heap Allocation Challenges","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"kind":"section","role":"pseudoSymbol","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Handling-Heap-Allocation-Challenges"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Configure-the-Initial-Blockchain-State":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Configure-the-Initial-Blockchain-State","role":"pseudoSymbol","url":"\/tutorials\/spacekit\/flipcontractinittests#Configure-the-Initial-Blockchain-State","type":"section","title":"Configure the Initial Blockchain State","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}],"kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Write-Tests-for-the-Setup-Helpers":{"type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Write-Tests-for-the-Setup-Helpers","role":"pseudoSymbol","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}],"url":"\/tutorials\/spacekit\/flipcontractinittests#Write-Tests-for-the-Setup-Helpers","kind":"section","title":"Write Tests for the Setup Helpers"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Build-a-Coin-Flip-Smart-Contract":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/build-a-coin-flip-smart-contract","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Build-a-Coin-Flip-Smart-Contract","kind":"article","abstract":[],"role":"article","title":"Build a Coin Flip Smart Contract"},"doc://SpaceKit/tutorials/SpaceKit/FlipContractInitTests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract":{"url":"\/tutorials\/spacekit\/flipcontractinittests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract","role":"pseudoSymbol","kind":"section","title":"Create Helper Functions to Deploy and Configure the Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractInitTests#Create-Helper-Functions-to-Deploy-and-Configure-the-Contract","type":"section","abstract":[{"type":"text","text":"Smart contracts are permissionless programs that often manage valuable assets. Because of this, writing comprehensive tests for both successful and failure scenarios is essential."}]},"doc://SpaceKit/tutorials/SpaceKit/FlipContractWriteTheGame#Implement-the-makeFlip-Function":{"url":"\/tutorials\/spacekit\/flipcontractwritethegame#Implement-the-makeFlip-Function","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FlipContractWriteTheGame#Implement-the-makeFlip-Function","kind":"section","abstract":[{"type":"text","text":"With the storage and administrative endpoints complete, it’s time to build the core gameplay mechanics."}],"role":"pseudoSymbol","title":"Implement the makeFlip Function"},"FlipContractWriteTheGameSection1Step18.swift":{"syntax":"swift","highlights":[{"line":66},{"line":67},{"line":68},{"line":69},{"line":70},{"line":71},{"line":72},{"line":73},{"line":74},{"line":75},{"line":76},{"line":77}],"identifier":"FlipContractWriteTheGameSection1Step18.swift","type":"file","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","    }","}"],"fileType":"swift","fileName":"GameController.swift"},"FlipContractWriteTheGameSection3Step7.swift":{"type":"file","identifier":"FlipContractWriteTheGameSection3Step7.swift","fileName":"GameController.swift","fileType":"swift","highlights":[{"line":100},{"line":101}],"syntax":"swift","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","        ","        let tokenReserve = storageController","            .getTokenReserve(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBet = storageController","            .getMaximumBet(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let maximumBetPercent = storageController","            .getMaximumBetPercent(","                tokenIdentifier: payment.tokenIdentifier,","                tokenNonce: payment.nonce","            )","            .get()","        ","        let hundred_percent = BigUint(value: HUNDRED_PERCENT)","        ","        let maximumBetPercentComputed = tokenReserve * BigUint(value: maximumBetPercent) \/ hundred_percent","        let maximumAllowedBet = maximumBet.min(other: maximumBetPercentComputed)","        ","        let ownerFees = payment.amount * BigUint(value: storageController.ownerPercentFees) \/ hundred_percent","        let bounty = payment.amount * BigUint(value: storageController.bountyPercentFees) \/ hundred_percent","        ","        let amount = payment.amount - ownerFees - bounty","        ","        require(","            amount <= maximumAllowedBet,","            \"Bet is too high. Maximum allowed bet: \\(maximumAllowedBet)\"","        )","        ","        let lastFlipId = storageController.lastFlipId","        let flipId = lastFlipId + 1","        ","        let flip = Flip(","            id: flipId,","            playerAddress: Message.caller,","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce,","            amount: amount,","            bounty: bounty,","            blockNonce: Blockchain.getBlockNonce(),","            minimumBlockBounty: storageController.minimumBlockBounty","        )","        ","        storageController.getTokenReserve(","            tokenIdentifier: payment.tokenIdentifier,","            tokenNonce: payment.nonce","        )","        .set(tokenReserve - amount)","        ","        if payment.tokenIdentifier.isEGLD {","            Blockchain.getOwner()","                .send(egldValue: ownerFees)","        } else {","            Blockchain.getOwner()","                .send(","                    tokenIdentifier: payment.tokenIdentifier,","                    nonce: payment.nonce,","                    amount: ownerFees","                )","        }","        ","        storageController.flipForId[flipId] = flip","        storageController.lastFlipId = flipId","    }","    ","    public func bounty() {","        let caller = Message.caller","        ","        require(","            !caller.isSmartContract,","            \"This endpoint cannot be called by a smart contract.\"","        )","        ","        var storageController = StorageController()","        ","        let lastBountyFlipId = storageController.lastBountyFlipId","        let lastFlipId = storageController.lastFlipId","        ","        require(","            lastBountyFlipId < lastFlipId,","            \"No flip to bounty.\"","        )","        ","        let currentBlockNonce = Blockchain.getBlockNonce()","    }","    ","    private func makeFlip(","        bountyAddress: Address,","        flip: Flip","    ) {","        let randomNumber = Randomness.nextUInt8InRange(min: 0, max: 2)","        let isWin = randomNumber == 1","        ","        bountyAddress.send(","            tokenIdentifier: flip.tokenIdentifier,","            nonce: flip.tokenNonce,","            amount: flip.bounty","        )","        ","        let profitIfWin = flip.amount * 2","        ","        let storageController = StorageController()","        ","        if isWin {","            if flip.tokenIdentifier.isEGLD {","                flip.playerAddress","                    .send(egldValue: profitIfWin)","            } else {","                flip.playerAddress","                    .send(","                        tokenIdentifier: flip.tokenIdentifier,","                        nonce: flip.tokenNonce,","                        amount: profitIfWin","                    )","            }","        } else {","            storageController.getTokenReserve(","                tokenIdentifier: flip.tokenIdentifier,","                tokenNonce: flip.tokenNonce","            )","            .update { $0 = $0 + profitIfWin }","        }","        ","        storageController.$flipForId[flip.id].clear()","    }","}"]},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Perform-an-Asynchronous-Call":{"url":"\/tutorials\/spacekit\/asynccalls#Perform-an-Asynchronous-Call","kind":"section","type":"section","role":"pseudoSymbol","title":"Perform an Asynchronous Call","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}]},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract":{"url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Fungible-Token-from-Your-Contract","role":"pseudoSymbol","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","type":"section","title":"Issuing a Fungible Token from Your Contract","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/Build-a-Coin-Flip-Contract/Set-Up-Testing-in-the-SwiftVM":{"url":"\/tutorials\/spacekit\/build-a-coin-flip-contract\/set-up-testing-in-the-swiftvm","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Build-a-Coin-Flip-Contract\/Set-Up-Testing-in-the-SwiftVM","kind":"article","abstract":[],"role":"article","title":"Set Up Testing in the SwiftVM"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Declare-the-Callee-Proxy":{"type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","url":"\/tutorials\/spacekit\/synccalls#Declare-the-Callee-Proxy","title":"Declare the Callee Proxy","kind":"section","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}],"role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens":{"url":"\/tutorials\/spacekit\/understandtokens","estimatedTime":"15min","role":"project","kind":"project","title":"Understand the ESDT Standard","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens","type":"topic","abstract":[{"text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}]},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Testing-the-Contract":{"url":"\/tutorials\/spacekit\/codingyourfirstcontract#Testing-the-Contract","role":"pseudoSymbol","kind":"section","title":"Testing the Contract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract","type":"section","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}]},"FlipContractWriteTheGameSection1Step7.swift":{"fileType":"swift","syntax":"swift","type":"file","identifier":"FlipContractWriteTheGameSection1Step7.swift","highlights":[{"line":8},{"line":9}],"fileName":"GameController.swift","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000","","@Controller public struct GameController {","    public func flip() {","        let payment = Message.egldOrSingleEsdtTransfer","        ","        var storageController = StorageController()","    }","}"]},"FlipContractWriteTheGameSection1Step3.swift":{"type":"file","fileName":"GameController.swift","content":["import SpaceKit","","let HUNDRED_PERCENT: UInt64 = 10_000"],"identifier":"FlipContractWriteTheGameSection1Step3.swift","syntax":"swift","highlights":[{"line":2},{"line":3}],"fileType":"swift"}}}
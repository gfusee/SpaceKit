{"identifier":{"url":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","interfaceLanguage":"swift"},"sections":[{"chapter":"Calling Contracts Across Shards","kind":"hero","content":[{"type":"paragraph","inlineContent":[{"text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources.","type":"text"}]},{"inlineContent":[{"type":"text","text":"In a sharded blockchain, each wallet is associated with a specific shard, and any smart contract deployed resides within that shard. Communication between contracts on different shards requires an asynchronous approach, differing from the synchronous communication methods covered earlier due to the nature of inter-shard interactions."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Executing an asynchronous contract-to-contract (SC-to-SC) call is similar to issuing an HTTP request in traditional web development. Within a transaction, the async call is initiated, and a callback is provided to handle success or failure. It is important to note that errors in the called contract do not automatically revert the entire transaction. Handling state reversion must be explicitly managed within the callback logic.","type":"text"}]}],"title":"Interacting with Contracts Across Shards","estimatedTimeInMinutes":15},{"tasks":[{"anchor":"Declare-the-Callee-Proxy","title":"Declare the Callee Proxy","contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This section builds upon the contract code from the previous chapter covering synchronous calls, as the setup is similar."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example focuses on the "},{"type":"codeVoice","code":"deposit"},{"type":"text","text":" endpoint, assumed to return a "},{"type":"codeVoice","code":"TokenPayment"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The objective is to return the payment to the initial caller upon a successful deposit. If the deposit fails, the original value must be refunded.","type":"text"}]}],"mediaPosition":"trailing"}],"stepsSection":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Review the contract provided in the previous chapter.","type":"text"}]}],"type":"step","runtimePreview":null,"caption":[],"media":null,"code":"AsyncCallsSection1Step1.swift"},{"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The example assumes that the caller and callee are on different shards."}]}],"type":"step","code":"AsyncCallsSection1Step2.swift","runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"Reuse the structure of the caller contract from the previous chapter. The proxy setup is used for both synchronous and asynchronous calls."}],"type":"paragraph"}],"media":null}]},{"anchor":"Perform-an-Asynchronous-Call","title":"Perform an Asynchronous Call","stepsSection":[{"runtimePreview":null,"caption":[],"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Review the complete code from the previous section."}]}],"type":"step","code":"AsyncCallsSection1Step2.swift","media":null},{"code":"AsyncCallsSection2Step2.swift","type":"step","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Add the endpoint that users will call to initiate the deposit async call.","type":"text"}]}],"media":null,"caption":[]},{"caption":[],"media":null,"runtimePreview":null,"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Retrieve the payment provided by the user.","type":"text"}]}],"code":"AsyncCallsSection2Step3.swift"},{"content":[{"inlineContent":[{"text":"Initiate the async call using the ","type":"text"},{"type":"codeVoice","code":"registerPromise"},{"text":" method on the proxy.","type":"text"}],"type":"paragraph"}],"type":"step","code":"AsyncCallsSection2Step4.swift","runtimePreview":null,"caption":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Note: Unlike synchronous calls, all changes made before and after the registration are committed to the blockchain, regardless of the call’s result."}]}],"media":null},{"type":"step","caption":[{"inlineContent":[{"type":"text","text":"Technically, a callback acts as an endpoint, but it is protected and only callable by SpaceVM after an async call."}],"type":"paragraph"}],"code":"AsyncCallsSection2Step5.swift","content":[{"inlineContent":[{"text":"Define the callback function, annotated with ","type":"text"},{"type":"codeVoice","code":"@Callback"},{"type":"text","text":". The function can take arguments to store information computed during the initial execution phase, before the async call."}],"type":"paragraph"}],"media":null,"runtimePreview":null},{"content":[{"type":"paragraph","inlineContent":[{"text":"Retrieve the result of the asynchronous call.","type":"text"}]}],"type":"step","media":null,"code":"AsyncCallsSection2Step6.swift","caption":[{"type":"paragraph","inlineContent":[{"text":"Note: The result is represented as ","type":"text"},{"type":"codeVoice","code":"AsyncCallResult<T>"},{"text":", where ","type":"text"},{"type":"codeVoice","code":"T"},{"type":"text","text":" is the return type of the endpoint."}]}],"runtimePreview":null},{"content":[{"inlineContent":[{"type":"text","text":"Handle success and error cases."}],"type":"paragraph"}],"caption":[{"inlineContent":[{"type":"text","text":"In the event of success, the result contains the execution output; in the event of failure, it contains the error."}],"type":"paragraph"}],"code":"AsyncCallsSection2Step7.swift","runtimePreview":null,"type":"step","media":null},{"type":"step","media":null,"runtimePreview":null,"caption":[],"code":"AsyncCallsSection2Step8.swift","content":[{"inlineContent":[{"type":"text","text":"Forward the received payment to the original user upon successful completion."}],"type":"paragraph"}]},{"media":null,"runtimePreview":null,"type":"step","caption":[],"content":[{"inlineContent":[{"type":"text","text":"Refund the original payment to the user in the event of failure."}],"type":"paragraph"}],"code":"AsyncCallsSection2Step9.swift"},{"media":null,"caption":[{"inlineContent":[{"type":"text","text":"Ensure that the "},{"type":"codeVoice","code":"gasForCallback"},{"type":"text","text":" parameter of the "},{"type":"codeVoice","code":"$"},{"type":"text","text":" function is set to provide sufficient gas for callback execution."}],"type":"paragraph"}],"code":"AsyncCallsSection2Step10.swift","runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"@Callback"},{"type":"text","text":" annotation generates a "},{"code":"$","type":"codeVoice"},{"text":" function that is used to populate the callback parameter in ","type":"text"},{"code":"registerPromise","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}],"type":"step"}],"contentSection":[{"mediaPosition":"trailing","kind":"contentAndMedia","content":[{"inlineContent":[{"type":"text","text":"After setting up the proxy, initiate the asynchronous call and declare the callback."}],"type":"paragraph"}]}]}],"kind":"tasks"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/tutorials\/spacekit\/asynccalls"]}],"hierarchy":{"paths":[["doc:\/\/SpaceKit\/tutorials\/SpaceKit","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts","doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards"]],"modules":[{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools"},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","projects":[{"sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues"}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo","sections":[{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data","kind":"task"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain"},{"projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","projects":[{"sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract","kind":"task"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens"}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens","kind":"task"}]}]},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens","kind":"task"}]}]},{"projects":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","sections":[{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint","kind":"task"},{"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint","kind":"task"},{"kind":"task","reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint"}]}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes"}],"reference":"doc:\/\/SpaceKit\/tutorials\/SpaceKit"},"kind":"project","schemaVersion":{"minor":3,"major":0,"patch":0},"metadata":{"categoryPathComponent":"SpaceKit","category":"SpaceKit","role":"project","title":"Interacting with Contracts Across Shards"},"references":{"doc://SpaceKit/tutorials/SpaceKit/GetInfo":{"url":"\/tutorials\/spacekit\/getinfo","role":"project","title":"Retrieving Information from the Blockchain","estimatedTime":"10min","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}],"type":"topic","kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-lockFunds-Endpoint":{"kind":"section","title":"Implementing the lockFunds Endpoint","type":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-lockFunds-Endpoint","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-lockFunds-Endpoint","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens","url":"\/tutorials\/spacekit\/operationsonfungibletokens","estimatedTime":"15min","role":"project","type":"topic","abstract":[{"text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with.","type":"text"}],"title":"Managing Fungible Tokens","kind":"project"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Setting-Up-the-SpaceKit-CLI":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Setting-Up-the-SpaceKit-CLI","type":"section","kind":"section","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}],"title":"Setting Up the SpaceKit CLI","url":"\/tutorials\/spacekit\/installingtools#Setting-Up-the-SpaceKit-CLI"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Assign-Create-AddQuantity-and-Burn-Roles","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Assign-Create-AddQuantity-and-Burn-Roles","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"type":"section","title":"Assign Create, AddQuantity, and Burn Roles"},"AsyncCallsSection2Step7.swift":{"type":"file","content":["import SpaceKit","","@Proxy enum CalleeProxy {","    case deposit","}","","@Controller public struct MyController {","    ","    public mutating func initiateDeposit(receiverAddress: Address) {","        let payment = Message.egldValue","        ","        CalleeProxy","            .deposit","            .registerPromise(","                receiver: receiverAddress,","                gas: 60_000_000,","                callback: \/\/ We will set this parameter later","            )","    }","    ","    @Callback public func depositCallback(sentPayment: BigUint, originalCaller: Address) {","        let result: AsyncCallResult<TokenPayment> = Message.asyncCallResult()","        ","        switch result {","        case .success(let resultPayment):","            \/\/ The deposit is a success, we can send the payment to the original caller","            ","        case .error(_):","            \/\/ The deposit is an error and the payment made in the async call has been cancelled.","            \/\/ We have to send it back to the original caller","            ","        }","    }","}"],"fileName":"lib.swift","identifier":"AsyncCallsSection2Step7.swift","fileType":"swift","highlights":[{"line":23},{"line":24},{"line":25},{"line":26},{"line":27},{"line":28},{"line":29},{"line":30},{"line":31},{"line":32}],"syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Non-Fungible-Tokens":{"kind":"article","title":"Managing Non-Fungible Tokens","type":"topic","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-non-fungible-tokens","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Non-Fungible-Tokens","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Create-a-New-Nonce":{"kind":"section","title":"Create a New Nonce","url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Create-a-New-Nonce","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"role":"pseudoSymbol","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Create-a-New-Nonce"},"AsyncCallsSection2Step4.swift":{"content":["import SpaceKit","","@Proxy enum CalleeProxy {","    case deposit","}","","@Controller public struct MyController {","    ","    public mutating func initiateDeposit(receiverAddress: Address) {","        let payment = Message.egldValue","        ","        CalleeProxy","            .deposit","            .registerPromise(","                receiver: receiverAddress,","                gas: 60_000_000,","                callback: \/\/ We will set this parameter later","            )","    }","    ","}"],"type":"file","fileType":"swift","identifier":"AsyncCallsSection2Step4.swift","fileName":"lib.swift","syntax":"swift","highlights":[{"line":11},{"line":12},{"line":13},{"line":14},{"line":15},{"line":16},{"line":17},{"line":18}]},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes","url":"\/tutorials\/spacekit\/tokenattributes","estimatedTime":"15min","role":"project","type":"topic","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"title":"Enhance Your Contracts with Token Attributes","kind":"project"},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Installing-SpaceKits-Dependencies":{"kind":"section","title":"Installing SpaceKit's Dependencies","type":"section","url":"\/tutorials\/spacekit\/installingtools#Installing-SpaceKits-Dependencies","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Installing-SpaceKits-Dependencies","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}]},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Building-Your-First-Smart-Contract":{"role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Building-Your-First-Smart-Contract","type":"topic","abstract":[],"kind":"article","url":"\/tutorials\/spacekit\/getting-started\/building-your-first-smart-contract","title":"Building Your First Smart Contract"},"AsyncCallsSection2Step6.swift":{"type":"file","content":["import SpaceKit","","@Proxy enum CalleeProxy {","    case deposit","}","","@Controller public struct MyController {","    ","    public mutating func initiateDeposit(receiverAddress: Address) {","        let payment = Message.egldValue","        ","        CalleeProxy","            .deposit","            .registerPromise(","                receiver: receiverAddress,","                gas: 60_000_000,","                callback: \/\/ We will set this parameter later","            )","    }","    ","    @Callback public func depositCallback(sentPayment: BigUint, originalCaller: Address) {","        let result: AsyncCallResult<TokenPayment> = Message.asyncCallResult()","    }","}"],"fileName":"lib.swift","fileType":"swift","syntax":"swift","identifier":"AsyncCallsSection2Step6.swift","highlights":[{"line":22}]},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools":{"estimatedTime":"10min","abstract":[{"text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed.","type":"text"}],"title":"Install the Necessary Tools","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools","role":"project","url":"\/tutorials\/spacekit\/installingtools","type":"topic","kind":"project"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls":{"kind":"project","role":"project","url":"\/tutorials\/spacekit\/asynccalls","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls","title":"Interacting with Contracts Across Shards","estimatedTime":"15min","type":"topic"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-BigUint-Type":{"abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-BigUint-Type","type":"section","title":"Working with the BigUint Type","url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-BigUint-Type","role":"pseudoSymbol","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Persisting-Data-Across-Executions":{"url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/persisting-data-across-executions","role":"article","kind":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Persisting-Data-Across-Executions","abstract":[],"type":"topic","title":"Persisting Data Across Executions"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues":{"abstract":[{"text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory.","type":"text"}],"role":"project","kind":"project","url":"\/tutorials\/spacekit\/storevalues","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues","title":"Persist Values Between Executions","type":"topic","estimatedTime":"15min"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","title":"Issuing a Semi-Fungible Token from Your Contract","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Semi-Fungible-Token-from-Your-Contract","kind":"section","type":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Working-with-the-Vector-Type":{"kind":"section","title":"Working with the Vector Type","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Working-with-the-Vector-Type","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Working-with-the-Vector-Type","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}]},"AsyncCallsSection1Step2.swift":{"type":"file","syntax":"swift","identifier":"AsyncCallsSection1Step2.swift","highlights":[],"fileType":"swift","content":["import SpaceKit","","@Proxy enum CalleeProxy {","    case deposit","}","","@Controller public struct MyController {","    ","}"],"fileName":"lib.swift"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Mint-New-Tokens":{"kind":"section","title":"Mint New Tokens","type":"section","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Mint-New-Tokens","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Mint-New-Tokens","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}]},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Working-with-Storage-for-Single-Value-Persistence":{"url":"\/tutorials\/spacekit\/storevalues#Working-with-Storage-for-Single-Value-Persistence","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Working-with-Storage-for-Single-Value-Persistence","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}],"type":"section","title":"Working with @Storage for Single Value Persistence"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Enhancing-Contracts-with-Token-Attributes":{"kind":"article","title":"Enhancing Contracts with Token Attributes","type":"topic","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/enhancing-contracts-with-token-attributes","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Enhancing-Contracts-with-Token-Attributes","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Understanding-the-Buffer-Type":{"abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Understanding-the-Buffer-Type","type":"section","title":"Understanding the Buffer Type","kind":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Understanding-the-Buffer-Type","role":"pseudoSymbol"},"AsyncCallsSection2Step5.swift":{"type":"file","content":["import SpaceKit","","@Proxy enum CalleeProxy {","    case deposit","}","","@Controller public struct MyController {","    ","    public mutating func initiateDeposit(receiverAddress: Address) {","        let payment = Message.egldValue","        ","        CalleeProxy","            .deposit","            .registerPromise(","                receiver: receiverAddress,","                gas: 60_000_000,","                callback: \/\/ We will set this parameter later","            )","    }","    ","    @Callback public func depositCallback(sentPayment: BigUint, originalCaller: Address) {","        ","    }","}"],"fileName":"lib.swift","fileType":"swift","syntax":"swift","identifier":"AsyncCallsSection2Step5.swift","highlights":[{"line":21},{"line":22},{"line":23}]},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens","role":"project","title":"Managing Non-Fungible Tokens","estimatedTime":"15min","type":"topic","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract":{"title":"Issuing a Meta ESDT from Your Contract","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Meta-ESDT-from-Your-Contract","role":"pseudoSymbol","type":"section","kind":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"text":" ","type":"text"},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Meta-ESDT-from-Your-Contract"},"doc://SpaceKit/tutorials/SpaceKit":{"abstract":[{"text":"Discover how SpaceKit simplifies blockchain development using Swift. Dive into the world of Web3 with ease and efficiency.","type":"text"}],"role":"overview","type":"topic","kind":"overview","title":"Meet SpaceKit","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit","url":"\/tutorials\/spacekit"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Initializing-the-Project":{"kind":"section","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Initializing-the-Project","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"role":"pseudoSymbol","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Initializing-the-Project","title":"Initializing the Project"},"AsyncCallsSection2Step9.swift":{"fileType":"swift","fileName":"lib.swift","content":["import SpaceKit","","@Proxy enum CalleeProxy {","    case deposit","}","","@Controller public struct MyController {","    ","    public mutating func initiateDeposit(receiverAddress: Address) {","        let payment = Message.egldValue","        ","        CalleeProxy","            .deposit","            .registerPromise(","                receiver: receiverAddress,","                gas: 60_000_000,","                callback: \/\/ We will set this parameter later","            )","    }","    ","    @Callback public func depositCallback(sentPayment: BigUint, originalCaller: Address) {","        let result: AsyncCallResult<TokenPayment> = Message.asyncCallResult()","        ","        switch result {","        case .success(let resultPayment):","            \/\/ The deposit is a success, we can send the payment to the original caller","            originalCaller.send(","                tokenIdentifier: resultPayment.tokenIdentifier,","                nonce: resultPayment.nonce,","                amount: resultPayment.amount","            )","        case .error(_):","            \/\/ The deposit is an error and the payment made in the async call has been cancelled.","            \/\/ We have to send it back to the original caller","            originalCaller.send(egldValue: sentPayment)","        }","    }","}"],"type":"file","highlights":[{"line":35}],"identifier":"AsyncCallsSection2Step9.swift","syntax":"swift"},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint":{"role":"pseudoSymbol","title":"Implementing the changeTokenLockDuration Endpoint","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-changeTokenLockDuration-Endpoint","kind":"section","abstract":[{"type":"text","text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets."}],"type":"section","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-changeTokenLockDuration-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Transaction-Context-Data":{"kind":"section","title":"Accessing Transaction Context Data","type":"section","url":"\/tutorials\/spacekit\/getinfo#Accessing-Transaction-Context-Data","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Transaction-Context-Data","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}]},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Fungible-Token-from-Your-Contract","type":"section","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"kind":"section","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Fungible-Token-from-Your-Contract","title":"Issuing a Fungible Token from Your Contract"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Burn-Tokens":{"kind":"section","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Burn-Tokens","title":"Burn Tokens","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"role":"pseudoSymbol","type":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Burn-Tokens"},"AsyncCallsSection2Step10.swift":{"content":["import SpaceKit","","@Proxy enum CalleeProxy {","    case deposit","}","","@Controller public struct MyController {","    ","    public mutating func initiateDeposit(receiverAddress: Address) {","        let payment = Message.egldValue","        ","        CalleeProxy","            .deposit","            .registerPromise(","                receiver: receiverAddress,","                gas: 60_000_000,","                callback: self.$depositCallback(","                    sentPayment: payment,","                    originalCaller: Message.caller,","                    gasForCallback: 50_000_000","                )","            )","    }","    ","    @Callback public func depositCallback(sentPayment: BigUint, originalCaller: Address) {","        let result: AsyncCallResult<TokenPayment> = Message.asyncCallResult()","        ","        switch result {","        case .success(let resultPayment):","            \/\/ The deposit is a success, we can send the payment to the original caller","            originalCaller.send(","                tokenIdentifier: resultPayment.tokenIdentifier,","                nonce: resultPayment.nonce,","                amount: resultPayment.amount","            )","        case .error(_):","            \/\/ The deposit is an error and the payment made in the async call has been cancelled.","            \/\/ We have to send it back to the original caller","            originalCaller.send(egldValue: sentPayment)","        }","    }","}"],"syntax":"swift","highlights":[{"line":17},{"line":18},{"line":19},{"line":20},{"line":21}],"fileName":"lib.swift","identifier":"AsyncCallsSection2Step10.swift","type":"file","fileType":"swift"},"AsyncCallsSection1Step1.swift":{"fileName":"CalleeProxy.swift","content":["import SpaceKit","","@Controller public struct CalleeController {","    public func deposit() -> TokenPayment {","        \/\/ Implements the logic to handle a deposit.","        \/\/ This endpoint requires an input EGLD payment.","    }","}"],"fileType":"swift","type":"file","identifier":"AsyncCallsSection1Step1.swift","syntax":"swift","highlights":[]},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Writing-the-Contract-Code":{"role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Writing-the-Contract-Code","title":"Writing the Contract Code","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Writing-the-Contract-Code","kind":"section","type":"section","abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}]},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Interacting-with-Other-Contracts":{"url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/interacting-with-other-contracts","role":"article","kind":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Interacting-with-Other-Contracts","abstract":[],"type":"topic","title":"Interacting with Other Contracts"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnFungibleTokens#Assign-Mint-and-Burn-Roles","abstract":[{"type":"text","text":"Fungible tokens function similarly to traditional currencies, making them the simplest type of token to work with."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/operationsonfungibletokens#Assign-Mint-and-Burn-Roles","type":"section","kind":"section","title":"Assign Mint and Burn Roles"},"AsyncCallsSection2Step3.swift":{"identifier":"AsyncCallsSection2Step3.swift","type":"file","syntax":"swift","content":["import SpaceKit","","@Proxy enum CalleeProxy {","    case deposit","}","","@Controller public struct MyController {","    ","    public mutating func initiateDeposit(receiverAddress: Address) {","        let payment = Message.egldValue","    }","    ","}"],"highlights":[{"line":10}],"fileName":"lib.swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Perform-an-Asynchronous-Call":{"url":"\/tutorials\/spacekit\/asynccalls#Perform-an-Asynchronous-Call","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Perform-an-Asynchronous-Call","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"type":"section","title":"Perform an Asynchronous Call"},"doc://SpaceKit/tutorials/SpaceKit/AsyncCalls#Declare-the-Callee-Proxy":{"url":"\/tutorials\/spacekit\/asynccalls#Declare-the-Callee-Proxy","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/AsyncCalls#Declare-the-Callee-Proxy","abstract":[{"type":"text","text":"Blockchain platforms using SpaceVM enable seamless execution within a sharded environment. Sharding divides a blockchain’s global state and validation workload into smaller, manageable units known as shards. This method enhances scalability without compromising decentralization, allowing nodes to operate without significant computational resources."}],"type":"section","title":"Declare the Callee Proxy"},"AsyncCallsSection2Step8.swift":{"content":["import SpaceKit","","@Proxy enum CalleeProxy {","    case deposit","}","","@Controller public struct MyController {","    ","    public mutating func initiateDeposit(receiverAddress: Address) {","        let payment = Message.egldValue","        ","        CalleeProxy","            .deposit","            .registerPromise(","                receiver: receiverAddress,","                gas: 60_000_000,","                callback: \/\/ We will set this parameter later","            )","    }","    ","    @Callback public func depositCallback(sentPayment: BigUint, originalCaller: Address) {","        let result: AsyncCallResult<TokenPayment> = Message.asyncCallResult()","        ","        switch result {","        case .success(let resultPayment):","            \/\/ The deposit is a success, we can send the payment to the original caller","            originalCaller.send(","                tokenIdentifier: resultPayment.tokenIdentifier,","                nonce: resultPayment.nonce,","                amount: resultPayment.amount","            )","        case .error(_):","            \/\/ The deposit is an error and the payment made in the async call has been cancelled.","            \/\/ We have to send it back to the original caller","            ","        }","    }","}"],"identifier":"AsyncCallsSection2Step8.swift","syntax":"swift","fileName":"lib.swift","type":"file","fileType":"swift","highlights":[{"line":27},{"line":28},{"line":29},{"line":30},{"line":31}]},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract#Testing-the-Contract":{"abstract":[{"type":"text","text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract#Testing-the-Contract","type":"section","title":"Testing the Contract","url":"\/tutorials\/spacekit\/codingyourfirstcontract#Testing-the-Contract","role":"pseudoSymbol","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/CodingYourFirstContract":{"abstract":[{"text":"In this tutorial, you’ll create a simple smart contract that manages a counter. Users can increment or decrement the counter, and the changes are persisted across contract executions.","type":"text"}],"role":"project","kind":"project","url":"\/tutorials\/spacekit\/codingyourfirstcontract","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/CodingYourFirstContract","title":"Building Your First Smart Contract","type":"topic","estimatedTime":"20min"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Exploring-SpaceKit's-Types":{"kind":"article","title":"Exploring SpaceKit's Types","type":"topic","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/exploring-spacekit's-types","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Exploring-SpaceKit's-Types","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract":{"abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"type":"text","text":" "},{"type":"text","text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","type":"section","title":"Issuing a Non-Fungible Token from Your Contract","url":"\/tutorials\/spacekit\/understandtokens#Issuing-a-Non-Fungible-Token-from-Your-Contract","role":"pseudoSymbol","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage":{"kind":"section","title":"Leveraging @Mapping for Dynamic Key-Value Storage","type":"section","url":"\/tutorials\/spacekit\/storevalues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/StoreValues#Leveraging-Mapping-for-Dynamic-Key-Value-Storage","abstract":[{"type":"text","text":"Each time a smart contract is invoked, it runs a single operation. The contract is temporarily loaded into the SpaceVM memory, the operation is executed, and then the contract is removed from memory."}]},"doc://SpaceKit/tutorials/SpaceKit/Getting-Started/Installing-the-Tools":{"kind":"article","title":"Installing the Tools","type":"topic","url":"\/tutorials\/spacekit\/getting-started\/installing-the-tools","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Getting-Started\/Installing-the-Tools","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract":{"kind":"section","title":"Initializing and Compiling Your First Smart Contract","type":"section","url":"\/tutorials\/spacekit\/installingtools#Initializing-and-Compiling-Your-First-Smart-Contract","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/InstallingTools#Initializing-and-Compiling-Your-First-Smart-Contract","abstract":[{"type":"text","text":"Before writing your first smart contract with SpaceKit, ensure you have the necessary tools installed."}]},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Managing-Fungible-Tokens":{"kind":"article","title":"Managing Fungible Tokens","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/managing-fungible-tokens","abstract":[],"role":"article","type":"topic","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Managing-Fungible-Tokens"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Perform-a-Synchronous-Call":{"abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Perform-a-Synchronous-Call","type":"section","title":"Perform a Synchronous Call","url":"\/tutorials\/spacekit\/synccalls#Perform-a-Synchronous-Call","role":"pseudoSymbol","kind":"section"},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Creating-Your-Own-Types":{"kind":"section","title":"Creating Your Own Types","type":"section","url":"\/tutorials\/spacekit\/familiarizewithtypes#Creating-Your-Own-Types","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Creating-Your-Own-Types","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}]},"doc://SpaceKit/tutorials/SpaceKit/TokenAttributes#Implementing-the-unlockFunds-Endpoint":{"title":"Implementing the unlockFunds Endpoint","url":"\/tutorials\/spacekit\/tokenattributes#Implementing-the-unlockFunds-Endpoint","role":"pseudoSymbol","type":"section","kind":"section","abstract":[{"text":"The ESDT standard enables embedding custom data within non-fungible tokens, allowing developers to extend the functionality of their smart contracts. This additional data, referred to as “attributes,” is tied to the token and transfers along with it between wallets.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/TokenAttributes#Implementing-the-unlockFunds-Endpoint"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Burn-Tokens":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Burn-Tokens","role":"pseudoSymbol","kind":"section","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Burn-Tokens","abstract":[{"type":"text","text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details."}],"type":"section","title":"Burn Tokens"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls#Declare-the-Callee-Proxy":{"kind":"section","title":"Declare the Callee Proxy","type":"section","url":"\/tutorials\/spacekit\/synccalls#Declare-the-Callee-Proxy","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls#Declare-the-Callee-Proxy","abstract":[{"type":"text","text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems."}]},"AsyncCallsSection2Step2.swift":{"identifier":"AsyncCallsSection2Step2.swift","type":"file","syntax":"swift","content":["import SpaceKit","","@Proxy enum CalleeProxy {","    case deposit","}","","@Controller public struct MyController {","    ","    public mutating func initiateDeposit(receiverAddress: Address) {","        ","    }","    ","}"],"highlights":[{"line":9},{"line":10},{"line":11},{"line":12}],"fileName":"lib.swift","fileType":"swift"},"doc://SpaceKit/tutorials/SpaceKit/UnderstandTokens":{"url":"\/tutorials\/spacekit\/understandtokens","type":"topic","kind":"project","estimatedTime":"15min","title":"Understand the ESDT Standard","role":"project","abstract":[{"type":"text","text":"Learn about the ESDT standard used in the SpaceKit framework, a token model that supports fungible tokens, non-fungible tokens (NFTs), semi-fungible tokens, and meta-esdt tokens."},{"text":" ","type":"text"},{"text":"The SpaceKit framework uses a token standard called ESDT. This standard defines four types of tokens: fungible, non-fungible (NFT), semi-fungible, and meta-esdt.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/UnderstandTokens"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Retrieving-Information-from-the-Blockchain":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Retrieving-Information-from-the-Blockchain","title":"Retrieving Information from the Blockchain","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/retrieving-information-from-the-blockchain","abstract":[],"role":"article","kind":"article","type":"topic"},"doc://SpaceKit/tutorials/SpaceKit/SyncCalls":{"url":"\/tutorials\/spacekit\/synccalls","role":"project","title":"Interact with Other Contracts","estimatedTime":"15min","type":"topic","abstract":[{"text":"Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.","type":"text"}],"kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/SyncCalls"},"doc://SpaceKit/tutorials/SpaceKit/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce":{"url":"\/tutorials\/spacekit\/operationsonnonfungibletokens#Add-Quantity-to-an-Existing-Nonce","abstract":[{"text":"Non-fungible tokens (NFTs) are unique digital assets that cannot be interchanged. Each NFT is associated with a unique identifier, known as a nonce. You can think of it like an airline ticket—each ticket is assigned to a specific passenger, with individual preferences and details.","type":"text"}],"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/OperationsOnNonFungibleTokens#Add-Quantity-to-an-Existing-Nonce","type":"section","kind":"section","title":"Add Quantity to an Existing Nonce","role":"pseudoSymbol"},"doc://SpaceKit/tutorials/SpaceKit/Create-and-Manage-Tokens/Creating-and-Understanding-Tokens":{"role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Create-and-Manage-Tokens\/Creating-and-Understanding-Tokens","type":"topic","abstract":[],"kind":"article","url":"\/tutorials\/spacekit\/create-and-manage-tokens\/creating-and-understanding-tokens","title":"Creating and Understanding Tokens"},"doc://SpaceKit/tutorials/SpaceKit/GetInfo#Accessing-Blockchain-Context-Data":{"kind":"section","title":"Accessing Blockchain Context Data","type":"section","url":"\/tutorials\/spacekit\/getinfo#Accessing-Blockchain-Context-Data","role":"pseudoSymbol","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/GetInfo#Accessing-Blockchain-Context-Data","abstract":[{"type":"text","text":"Many smart contracts rely on contextual data to execute their operations effectively. This data can include input payments, the caller’s address, the current time, the balance of a specific account, or even the contract owner."}]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges":{"identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes#Handling-Heap-Allocation-Challenges","abstract":[{"type":"text","text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM."}],"role":"pseudoSymbol","url":"\/tutorials\/spacekit\/familiarizewithtypes#Handling-Heap-Allocation-Challenges","type":"section","kind":"section","title":"Handling Heap Allocation Challenges"},"doc://SpaceKit/tutorials/SpaceKit/Deep-Dive-into-SpaceKit-Concepts/Calling-Contracts-Across-Shards":{"kind":"article","title":"Calling Contracts Across Shards","type":"topic","url":"\/tutorials\/spacekit\/deep-dive-into-spacekit-concepts\/calling-contracts-across-shards","role":"article","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/Deep-Dive-into-SpaceKit-Concepts\/Calling-Contracts-Across-Shards","abstract":[]},"doc://SpaceKit/tutorials/SpaceKit/FamiliarizeWithTypes":{"url":"\/tutorials\/spacekit\/familiarizewithtypes","role":"project","title":"Exploring SpaceKit's Types","estimatedTime":"20min","type":"topic","abstract":[{"text":"SpaceKit provides types that allow you to leverage the full potential of the SpaceVM.","type":"text"}],"kind":"project","identifier":"doc:\/\/SpaceKit\/tutorials\/SpaceKit\/FamiliarizeWithTypes"}}}
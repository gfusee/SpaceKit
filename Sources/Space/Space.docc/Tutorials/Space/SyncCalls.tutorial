@Tutorial(time: 15) {
    @Intro(title: "Interact with Other Contracts") {
        Smart contracts can interact not only with users but also with other smart contracts. This enables more advanced protocols by leveraging existing ones. For example, you could integrate a decentralized exchange directly into your contract to perform token swaps. Decentralized applications often involve multiple contracts, each with a dedicated role, working together to achieve complex functionality—similar to microservices in backend systems.

        In this tutorial, you will learn how to implement synchronous interactions between smart contracts. These interactions are only possible when both the calling and the called contracts reside on the same shard, a concept that we will explore in more detail later.

        A synchronous call is executed immediately, and once the called contract finishes execution, the control returns to the caller. If the call fails, the entire transaction is reverted, meaning no changes are recorded on the blockchain.
    }

    @Section(title: "Declare the Callee Proxy") {
        @ContentAndMedia {
            A proxy represents the endpoints and parameters of the called contract. It defines the structure of the calls that will be made. However, you will specify the actual contract to call separately in your contract's logic.

            The proxy is an enum annotated with `@Proxy`, where:

            - Each case name corresponds to an endpoint of the contract you want to call.
            - The associated values represent the parameters for that endpoint.
        }

        @Steps {
            @Step {
                Consider this contract. We will create another contract that will call it.
                
                You don’t always need access to the contract's Swift code. All you need is the endpoint name and the types of the parameters (in the correct order). You can find this information in the contract’s ABI or reverse-engineer it from a blockchain explorer.

                @Code(name: "CalleeContractProxy.swift", file: "SyncCallsSection1Step1.swift")
            }

            @Step {
                Now, create the structure for the contract that will call the previous one.

                @Code(name: "lib.swift", file: "SyncCallsSection1Step2.swift")
            }

            @Step {
                Declare the `@Proxy` enum, which will describe the endpoints of the called contract.

                @Code(name: "lib.swift", file: "SyncCallsSection1Step3.swift")
            }

            @Step {
                Add a case for the `deposit` endpoint.

                Since `deposit` doesn't require any parameters, no associated value is necessary.

                @Code(name: "lib.swift", file: "SyncCallsSection1Step4.swift")
            }

            @Step {
                Add a case for the `withdraw` endpoint.

                Note: The proxy only defines the input parameters, not the return types.

                @Code(name: "lib.swift", file: "SyncCallsSection1Step5.swift")
            }

            @Step {
                Add a case for the `getTotalDepositedAmount` endpoint.

                Note: The proxy doesn't describe the return type of the endpoint.

                @Code(name: "lib.swift", file: "SyncCallsSection1Step6.swift")
            }
        }
    }

    @Section(title: "Perform a Synchronous Call") {
        @ContentAndMedia {
            Once you have set up the proxy, invoking the contract is straightforward.
        }

        @Steps {
            @Step {
                Here is the complete code from the previous section.

                @Code(name: "lib.swift", file: "SyncCallsSection1Step6.swift")
            }

            @Step {
                Add an endpoint called `callDeposit` that will trigger the `deposit` endpoint.

                @Code(name: "lib.swift", file: "SyncCallsSection2Step1.swift")
            }

            @Step {
                The `deposit` endpoint requires an EGLD payment. Retrieve it, and you'll pass it along during the call setup in a later step.

                @Code(name: "lib.swift", file: "SyncCallsSection2Step2.swift")
            }

            @Step {
                Instantiate the `deposit` case from the `@Proxy` enum.

                @Code(name: "lib.swift", file: "SyncCallsSection2Step3.swift")
            }

            @Step {
                Use the `callAndIgnoreResult` method, which is auto-generated by `@Proxy`, to invoke the contract. Set the `receiver` parameter to the on-chain address of the CalleeContractProxy.
                
                Note: Since `deposit` doesn't return any value, use `callAndIgnoreResult` instead of `call`.

                @Code(name: "lib.swift", file: "SyncCallsSection2Step4.swift")
            }

            @Step {
                Forward the EGLD payment using the optional `egldValue` parameter to complete the call.
                
                Note: If you need to transfer ESDT tokens, use the `esdtTransfers` parameter.

                @Code(name: "lib.swift", file: "SyncCallsSection2Step5.swift")
            }

            @Step {
                Add an endpoint called `callWithdraw` that will invoke the `withdraw` endpoint. This function should accept an `amount` parameter that will be passed to the `withdraw` endpoint.

                @Code(name: "lib.swift", file: "SyncCallsSection2Step6.swift")
            }

            @Step {
                Instantiate the `withdraw` case from the `@Proxy` enum and pass the `amount` argument.

                @Code(name: "lib.swift", file: "SyncCallsSection2Step7.swift")
            }

            @Step {
                Use the `call` method to execute the contract call, passing the called contract’s address as the `receiver`, just like before.

                @Code(name: "lib.swift", file: "SyncCallsSection2Step8.swift")
            }

            @Step {
                Store the returned value in a variable named `payment`.

                Important: Because the `@Proxy` enum does not define return values, you must explicitly declare the type here.

                @Code(name: "lib.swift", file: "SyncCallsSection2Step9.swift")
            }

            @Step {
                Ensure that the resulting payment is greater than zero.

                @Code(name: "lib.swift", file: "SyncCallsSection2Step10.swift")
            }
        }
    }
}
